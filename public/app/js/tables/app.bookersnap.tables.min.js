var _APIMESAS_DOMAIN = "http://apimesas.studework.vm";
var _WEBAPP_DOMAIN = "http://weblaravel.studework.vm";
var _SOCKET_DOMAIN = "http://weblaravel.studework.vm";



(function() {
    'use strict';
    // var idMicrositio = obtenerIdMicrositio();
    angular.module('tables.app', [
            //'auth.app',//proximanente
            'turn.app',
            'zone.app',
            'book.app',
            'block.app',
            'guest.app',
            'calendar.app',
            'floor.app',
            'reservation.app',
            'customtag.app',
            'configuration.app',
            'availability.app',
            'grid.app',
            'widget.app',
            'notification.app'
        ])
        .constant("IdMicroSitio", _MICROSITE_ID)
        .constant("DomainBookersnapAdmin", env("_WEBAPP_DOMAIN"))
        .constant("UrlServerNotify", env("_SOCKET_DOMAIN")+":1337")
        .constant("ApiUrlMesas", env('_APIMESAS_DOMAIN')+'/v1/es/microsites/' + _MICROSITE_ID)
        .constant("ApiUrlRoot", env('_APIMESAS_DOMAIN')+'/v1/es')
        .config(function($stateProvider, $urlRouterProvider, $httpProvider) {
            $stateProvider
                .state('mesas', {
                    url: '/mesas',
                    templateUrl: ''
                });
        })
        .run(function($http, ServerNotification, IdMicroSitio) {
            $http.defaults.headers.common.Authorization = "Bearer " + _TOKEN_SESSION;
            ServerNotification.createConnection();
            ServerNotification.createRoom("microsites" + _MICROSITE_ID);
        });
})();
angular.module('availability.app', ['availability.controller', 'availability.service'])
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.availability', {
                url: '/availability-search',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/availability/view/index.html',
                        controller: 'AvailabilityController',
                        controllerAs: 'vm',
                    }
                }
            });
    });
angular.module('availability.controller', [])
    .controller('AvailabilityController', ['AvailabilityService', 'ReservationTemporalService', '$scope', function(AvailabilityService, ReservationTemporalService, $scope) {
        var vm = this;

        //Variables
        vm.dateMin = moment().format(vm.format);
        vm.date = new Date();
        vm.format = 'yyyy-MM-dd';

        vm.configuration = {
            date: moment(vm.Date).format('YYYY-MM-DD'),
            hour: null,
            num_guest: null,
            zone: null,
        };

        //Funciones
        vm.getAvailability = getAvailability;
        vm.openCalendar = openCalendar;
        vm.changeHour = changeHour;
        vm.reservationTemporal = reservationTemporal;
        vm.searchEventAvailability = searchEventAvailability;

        function getZones() {
            AvailabilityService.getZones(vm.configuration).then(function success(response) {
                vm.zones = response;
                vm.configuration.zone = vm.zones.length > 0 ? vm.zones[0].id : null;
            }, function success(response) {
                messageErrorApi(response.data, "Error", "warning");
            });
        }

        function getHours() {
            AvailabilityService.getHours(vm.configuration).then(function success(response) {
                vm.hours = response;
                vm.configuration.hour = vm.hours.length > 0 ? vm.hours[0] : null;
                console.log(vm.hours);
                getEvents();
            }, function success(response) {
                messageErrorApi(response.data, "Error", "warning");
            // vm.hours = []{
            //     option_user: "No existe Horarios Disponibles",
            //     option: "06:00:00",
            //     next_day: 1,
            //     index: 120
            // };
                console.log(vm.hours);
            });
        }

        function getEvents() {
            vm.loadingSearchEvent = true;
            AvailabilityService.getEvents(vm.configuration).then(function success(response) {
                vm.events = response;
                console.log(vm.events);
                vm.loadingSearchEvent = false;
            }, function success(response) {
                messageErrorApi(response.data, "Error", "warning");
                vm.loadingSearchEvent = false;
            });
        }

        function getGuest() {
            AvailabilityService.getConfig().then(function success(response) {
                vm.guests = AvailabilityService.getGuest(response.max_people);
                vm.configuration.num_guest = vm.guests.length > 0 ? 1 : null;
            }, function success(response) {
                messageErrorApi(response.data, "Error", "warning");
            });
        }

        function getAvailability() {
            vm.loadingSearch = true;
            console.log(vm.configuration);
            AvailabilityService.getAvailability(vm.configuration).then(function success(response) {
                vm.availabilities = response;
                console.log(vm.availabilities);
                vm.loadingSearch = false;
            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning");
                vm.loadingSearch = false;
            });
        }


        function openCalendar($event, opened) {
            $event.preventDefault();
            $event.stopPropagation();
            vm.opened = true;
        }

        function changeHour(hour) {
            getEvents();
        }

        function reservationTemporal(hour) {
            console.log(hour);
        }

        function searchEventAvailability(event) {
            console.log(event, vm.configuration);
        }

        $scope.$watch('vm.date', function(newValue, oldValue) {
            if (!moment(newValue).isSame(oldValue)) {
                vm.configuration.date = moment(newValue).format('YYYY-MM-DD');
                getHours();
                getZones();
            }
        });

        (function init() {
            getZones();
            getGuest();
            getHours();
        })();

    }]);
angular.module('availability.service', [])
    .service('AvailabilityDataService', function($http, ApiUrlMesas) {
        return {
            getAvailability: function(config) {
                return $http.get(ApiUrlMesas + "/availability/basic", {
                    params: {
                        date: config.date,
                        hour: config.hour.option,
                        next_day: config.hour.next_day,
                        num_guests: config.num_guest,
                        zone_id: config.zone_id
                    }
                });
            },
            getZones: function(config) {
                return $http.get(ApiUrlMesas + "/availability/zones", {
                    params: {
                        date: config.date
                    }
                });
            },
            getHours: function(config) {
                return $http.get(ApiUrlMesas + "/availability/hours", {
                    params: {
                        date: config.date,
                        zone_id: config.zoneId
                    }
                });
            },
            getEvents: function(config) {
                return $http.get(ApiUrlMesas + "/availability/events", {
                    params: {
                        date: config.date,
                        hour: config.hour.option,
                        next_day: config.hour.next_day,
                        zone_id: config.zone
                    }
                });
            },
        };
    })
    .service('ReservationTemporalDataService', function($http, ApiUrlMesas) {
        return {
            createReservationTemporal: function(config) {
                return $http.post(ApiUrlMesas + "/reservationtemporal", {}, {
                    params: {
                        date: config.date,
                        hour: config.hour.option,
                        next_day: config.hour.next_day,
                        num_guests: config.num_guests,
                        zone_id: config.zone
                    }
                });
            },
        };
    })
    .service('ReservationTemporalService', function($q, ReservationTemporalDataService) {
        return {
            createReservationTemporal: function(config) {
                var defered = $q.defer();
                var promise = defered.promise;
                ReservationTemporalDataService.createReservationTemporal(config).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            }
        };
    })
    .service('AvailabilityService', function($q, AvailabilityDataService, ConfigurationDataService) {
        return {
            getAvailability: function(config) {
                var defered = $q.defer();
                var promise = defered.promise;
                AvailabilityDataService.getAvailability(config).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getZones: function(config) {
                var defered = $q.defer();
                var promise = defered.promise;
                AvailabilityDataService.getZones(config).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getHours: function(config) {
                var defered = $q.defer();
                var promise = defered.promise;
                AvailabilityDataService.getHours(config).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getEvents: function(config) {
                var defered = $q.defer();
                var promise = defered.promise;
                AvailabilityDataService.getEvents(config).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getConfig: function() {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.getConfiguration().success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getGuest: function(cant) {
                var guest = [];
                for (var i = 1; i <= cant; i++) {
                    guest.push({
                        id: i,
                        option: i + " " + "INVITADOS"
                    });
                }
                return guest;
            }
        };
    });
angular.module('block.app', ['block.controller', 'block.service', 'block.directive', "block.filter"])
    .constant("screenSizeBlock", {
        minSize: 450,
        header: 112,
        menu: 400
    })
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.floor.block', {
                url: '/:date/block',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/block/view/create.old.html',
                        controller: 'blockCtr',
                        cache: false,
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Crear Bloqueos';
                    },
                }
            })
            .state('mesas.book.block', {
                url: '/block',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/block/view/create.old.html',
                        controller: 'blockCtr',
                        cache: false,
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Crear Bloqueos';
                    },
                }
            })
            .state('mesas.floor.blockEdit', {
                url: '/:date/block/:block_id',

                views: {
                    '@': {
                        templateUrl: '/js/app/tables/block/view/edit.new.html',
                        controller: "blockCtr",
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Editar Bloqueo';
                    },
                }
            })
            .state('mesas.book.blockEdit', {
                url: '/:date/block/:block_id',

                views: {
                    '@': {
                        templateUrl: '/js/app/tables/block/view/edit.new.html',
                        controller: "blockCtr",
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Editar Bloqueo';
                    },
                }
            })
            .state('mesas.grid.block', {
                url: '/:date/block',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/block/view/create.old.html',
                        controller: 'blockCtr',
                        cache: false,
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Crear Bloqueos';
                    },
                }
            })
            .state('mesas.grid.block.edit', {
                url: '/:block_id/edit',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/block/view/edit.new.html',
                        controller: "blockCtr",
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Editar Bloqueo';
                    },
                }
            });
    });
angular.module('block.controller', [])
    .controller('blockCtr', function($scope, $http, $state, $sce, $stateParams, $document, $window, screenHelper, screenSizeBlock,
        ApiUrlMesas, BlockFactory, ZoneFactory, ZoneLienzoFactory, TableFactory, CalendarService, reservationService, $uibModal, IdMicroSitio) {

        $scope.date = null;
        $scope.zoneIndexShow = 0;

        $scope.itemTables = [];

        $scope.coversList = BlockFactory.coverList();
        $scope.boxTables = BlockFactory.boxTables();

        $scope.object = {};
        $scope.zones = [];

        //Carga la informacion de la pantalla add Block
        $scope.shifts = [];
        $scope.startTimes = [];
        $scope.endTimes = [];

        $scope.zone = null;

        var zoneIndexMax = 0;
        var zoneIndex = 0;

        var mesasFuturasBloqueadas = null;

        $scope.format = 'yyyy/MM/dd';
        var block_id = null;

        //Funcion ejecutado para agregar  o retirar una mesa bloqueada
        $scope.mesasBloqueadas = [];

        $scope.$watch("date", function(newValue, oldValue) {
            var fecha = convertFechaYYMMDD(newValue, "es-ES", {});
            var fechaOld = convertFechaYYMMDD(oldValue, "es-ES", {});

            if (fecha !== fechaOld) {
                InitModule(fecha);
                // listFormData(fecha);
                // listZones(fecha);
            }
        });

        // var listZones = function(fecha) {
        //     //Listado array de zonas incluyendo sus zonas
        //     reservationService.getZones(fecha, true).then(
        //         function success(response) {
        //             $scope.zones = response.data.data; // Lista de Zonas que contienen mesas
        //             zoneIndexMax = $scope.zones.length;
        //             $scope.zone = $scope.zones[0];
        //             getAllTablesBlockFuture(fecha, true);

        //         },
        //         function error(response) {
        //             console.error("error " + angular.toJson(response, true));
        //         }
        //     );
        // };

        // var getAllTablesBlockFuture = function(fecha, reload) {
        //     // Se obtiene de array de las mesas que estan en ese rango de fecha
        //     BlockFactory.getAllBlock("date=" + fecha, reload).then(
        //         function success(response) {
        //             mesasFuturasBloqueadas = response.data.data;
        //             $scope.selectZone($scope.zones[0]);

        //             if ($stateParams.block_id !== undefined) {
        //                 block_id = $stateParams.block_id;
        //                 listTablesBlock();
        //             }
        //         },
        //         function error(response) {
        //             console.error("error " + angular.toJson(response, true));
        //         }
        //     );
        // };

        var exitsReservationTable = function(tableId) {
            var validate = false;
            angular.forEach(mesasFuturasBloqueadas, function(value, key) {
                if (tableId == value.res_table_id) {
                    if (value.res_reservation_id !== null && value.res_block_id == $stateParams.block_id) {
                        validate = true;
                    }

                }
            });

            return validate;
        };

        // var listTablesBlock = function() {
        //     BlockFactory.getBlock(block_id).then(function success(response) {

        //             $scope.tableBlock = response.data.data;

        //             angular.forEach(response.data.data.tables, function(mesa, indexMesa) {
        //                 $scope.mesasBloqueadas.push(mesa.id);
        //             });

        //             BlockFactory.updateTablesBlocked($scope, $sce);

        //             angular.forEach($scope.zones, function(zona, key) {
        //                 angular.forEach(zona.tables, function(mesa, i) {

        //                     for (var p = 0; p < $scope.mesasBloqueadas.length; p++) {

        //                         var exitsReservation = exitsReservationTable(mesa.id);

        //                         if (mesa.id === $scope.mesasBloqueadas[p] && exitsReservation === false) {
        //                             $scope.zones[key].tables[i].class = "selected-table";
        //                         }
        //                     }

        //                 });

        //                 $scope.selectZone($scope.zones[0]);

        //             });

        //             timesSelectedDefault($scope.tableBlock);
        //             $scope.loadBlockTables();

        //         },
        //         function error(response) {
        //             console.log("error " + angular.toJson(response, true));
        //         }
        //     );
        // };

        // selecciona turno,start_time y end_time  al cargar el bloqueo
        var timesSelectedDefault = function(blockData) {

            var start_time_block = moment(blockData.start_time, "HH:mm:ss");
            var end_time_block = moment(blockData.end_time, "HH:mm:ss");

            angular.forEach($scope.shifts, function(shift) {
                var start_time_shift = moment(shift.times.startTime, "HH:mm:ss");
                var end_time_shift = moment(shift.times.endTime, "HH:mm:ss");

                if ((start_time_shift.isBetween(start_time_block, end_time_block, null, "()")) ||
                    (end_time_block.isBetween(start_time_shift, end_time_shift, null, "()")) ||
                    (start_time_shift.isSameOrBefore(start_time_block) && end_time_shift.isSameOrAfter(end_time_block))) {

                    $scope.shift = shift;
                }

            });

            $scope.changueRange($scope.shift);

            $scope.startTime = {
                index: getIndexHour(blockData.start_time, 0),
                hour24: blockData.start_time
            };

            $scope.endTime = {
                index: getIndexHour(blockData.end_time, 0),
                hour24: blockData.end_time
            };
        };

        // var listFormData = function(fecha) {
        //     clearForm();
        //     CalendarService.GetShiftByDate(fecha).then(
        //         function OnSuccess(Response) {
        //             var data = Response.data;
        //             angular.forEach(data.data, function(item, i) {
        //                 if (item.turn !== null) { // Se obtienes los Shifts que contienen datos

        //                     $scope.shifts.push({
        //                         id: item.id,
        //                         name: item.name,
        //                         times: {
        //                             startTime: item.turn.hours_ini,
        //                             endTime: item.turn.hours_end
        //                         },
        //                         startTimes: getRangoHours(item.turn.hours_ini, item.turn.hours_end),
        //                         endTimes: getRangoHours(addHourByMin(item.turn.hours_ini), item.turn.hours_end, true),
        //                     });

        //                     // Se muestra el primer array para cuando se esta creando el bloqueo
        //                     $scope.shift = $scope.shifts[0];
        //                     $scope.startTimes = $scope.shifts[0].startTimes;
        //                     $scope.endTimes = $scope.shifts[0].endTimes;

        //                     if ($scope.startTimes.length > 0) {
        //                         $scope.startTime = $scope.startTimes[0];
        //                     }

        //                     if ($scope.endTimes.length > 0) {
        //                         $scope.endTime = $scope.endTimes[0];
        //                     }
        //                 }
        //             });
        //         },
        //         function OnError(Response) {
        //             console.log("error " + angular.toJson(Response, true));
        //         }
        //     );
        // };

        var clearForm = function() {
            $scope.shifts.length = 0;
        };

        var listCovers = function(option) {

            var coverList = "";

            if (option == "min") {
                coverList = $scope.coversList.dataMin;
            } else {
                coverList = $scope.coversList.dataMax;
            }

            for (var i = 1; i <= 30; i++) {
                var data = {
                    label: i + " covers",
                    id: i
                };

                coverList.push(data);
            }

            if (option == "min") {
                $scope.coversList.selectedMin = coverList[0];
            } else {
                $scope.coversList.selectedMax = coverList[0];
            }
        };

        var getDataTableSelected = function(index) {

            $scope.indexTable = index;

            angular.element("#name-table").val($scope.itemTables[index].name);
            $scope.changeShapeTable($scope.itemTables[index].shape);

            $scope.itemTables[index].top = angular.element("#tb-item" + index).css("top").replace("px", "");
            $scope.itemTables[index].left = angular.element("#tb-item" + index).css("left").replace("px", "");

            $scope.coversList.selectedMin = {
                id: $scope.itemTables[$scope.indexTable].minCover,
                label: $scope.itemTables[$scope.indexTable].minCover + " covers"
            };

            $scope.coversList.selectedMax = {
                id: $scope.itemTables[$scope.indexTable].maxCover,
                label: $scope.itemTables[$scope.indexTable].maxCover + " covers"
            };

            $scope.sizeTableList.selectedOption = {
                id: TableFactory.getIdSize($scope.itemTables[index].size),
                label: $scope.itemTables[index].size
            };
        };

        //Esta clase recorre las mesas listadas y crea un nuevo objeto dataTable que se iterara en la vista para imprimir las mesas
        var loadTablesEdit = function(tables) {
            BlockFactory.initItemTables($scope, tables, TableFactory);
        };

        var setZoneName = function(i) {
            if ($scope.zones.length) {
                $scope.zoneName = $scope.zones[i].name;
            }
        };

        var saveBlock = function(blockData) {

            BlockFactory.saveBlock(blockData).then(
                function success(response) {
                    if (response.data.success === true) {
                        messageAlert("Success", response.data.msg, "success", 0, true);
                        redirect();
                    } else if (response.data.success === false) {
                        messageAlert("Warning", response.data.msg.join("\n"), "warning", 0, true);
                    }
                },
                function error(response) {
                    messageAlert("Warning", response.data.jsonError.join("\n"), "warning", 0, true);
                }
            );

        };

        var editBlock = function(id, blockData) {

            BlockFactory.editBlock(id, blockData).then(
                function success(response) {
                    if (response.data.success === true) {
                        messageAlert("Success", response.data.msg, "success", 3000, true);
                        redirect();
                    } else if (response.data.success === false) {
                        messageAlert("Warning", response.data.msg, "warning", 2000, true);
                    }
                },
                function error(response) {
                    messageErrorApi(response, "Error", "warning", 2000, true);
                }
            );

        };

        $scope.deleteBlock = function() {
            var options = {
                showCancelButton: true,
                confirmButtonText: "Si",
                cancelButtonText: "No",
            };
            message.confirmButton("Eliminar bloqueo", "¿Estas seguro que deseas eliminar este bloqueo ?", "info", options, function() {
                BlockFactory.deleteBlock($stateParams.block_id).then(
                    function success(response) {
                        if (response.data.success === true) {
                            messageAlert("Success", response.data.msg, "success", 3000, true);
                            redirect();
                        } else if (response.data.response === false) {
                            messageAlert("Warning", response.data.jsonError, "warning", 2000, true);
                        }
                    },
                    function error(response) {
                        messageErrorApi(response, "Error", "warning", 2000, true);
                    }
                );
            });
        };

        $scope.loadBlockTables = function() {

            if ($scope.endTime === null) {
                return;
            }

            var start_time = moment($scope.startTime.hour24, "HH:mm:ss");
            var end_time = moment($scope.endTime.hour24, "HH:mm:ss");

            angular.forEach($scope.zones, function(zona, key) {
                angular.forEach(zona.tables, function(mesa, i) {
                    // Iteracion para identificar las mesas bloqueadas 
                    for (var p = 0; p < mesasFuturasBloqueadas.length; p++) {

                        var start_block = moment(mesasFuturasBloqueadas[p].start_time, "HH:mm:ss");
                        var end_block = moment(mesasFuturasBloqueadas[p].end_time, "HH:mm:ss");

                        if (mesa.id == mesasFuturasBloqueadas[p].res_table_id) {

                            if (((start_time.isBetween(start_block, end_block, null, "()")) || (end_time.isBetween(start_block, end_block, null, "()")) ||
                                    (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) && mesasFuturasBloqueadas[p].res_reservation_id === null) {
                                if ($stateParams.block_id === undefined) {
                                    $scope.zones[key].tables[i].classBloqueado = "block-table";
                                } else if ($stateParams.block_id != mesasFuturasBloqueadas[p].res_block_id) {
                                    $scope.zones[key].tables[i].classBloqueado = "block-table";
                                }

                            } else {
                                $scope.zones[key].tables[i].classBloqueado = "";
                            }
                        }
                    }
                    // Iteracion para mostrar mesas bloqueadas en el mismo rango de fechas bloqueadas 
                });
            });

            $scope.selectZone($scope.zones[zoneIndex]);
        };

        $scope.nextZone = function() {

            if (zoneIndex < zoneIndexMax - 1) {
                zoneIndex++;
            } else {
                if (zoneIndex >= zoneIndexMax - 1) {
                    zoneIndex = 0;
                }
            }
            console.log("nextZone ", zoneIndex);
            $scope.selectZone($scope.zones[zoneIndex]);
        };

        $scope.prevZone = function() {

            if (zoneIndex - 1 >= 0) {
                zoneIndex--;
            } else {
                zoneIndex = zoneIndexMax - 1;
            }

            console.log("prevZone " + zoneIndex);
            $scope.selectZone($scope.zones[zoneIndex]);
        };

        $scope.selectZone = function(item) {
            angular.forEach($scope.zones, function(value, key) {

                if (value.id == item.id) {
                    $scope.zoneIndexShow = key;
                    $scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                    $scope.zone = $scope.zones[key];
                    loadTablesEdit(value.tables);
                }
            });
        };

        // Se cambia el rango del shift elegido de acuerdo a la eleccion   
        $scope.changueRange = function(item) {

            if (item === null) {
                return;
            }

            $scope.startTimes = item.startTimes;
            $scope.endTimes = item.endTimes;

            if ($scope.startTimes.length > 0) {
                $scope.startTime = $scope.startTimes[0];
            }

            if ($scope.endTimes.length > 0) {
                $scope.endTime = $scope.endTimes[0];
            }
        };

        $scope.activarTableOptions = function(index, data) {
            console.log("activarTableOptions ", index);
            BlockFactory.checkTable($scope, $sce, index, data);
        };

        $scope.desactivarTable = function(index, data) {
            console.log("desactivarTableOptions ", index);
            BlockFactory.uncheckTable($scope, $sce, index, data);
        };

        $scope.openCalendar = function($event, opened) {
            $event.preventDefault();
            $event.stopPropagation();
            $scope.opened = true;
        };

        var messages = [];

        $scope.saveZone = function(option) {
            var messages = [];
            if ($scope.date === undefined) {
                messages.push("Seleccione Fecha de reservacion");
            }

            if (!$scope.startTime) {
                messages.push("Seleccione Hora de inicio");
            }

            if (!$scope.endTime) {
                messages.push("Seleccione Hora final");
            }

            if (!$scope.mesasBloqueadas.length) {
                messages.push("Seleccione al menos una mesa a bloquear");
            }

            if (messages.length) {

                messageAlert("Alerta", messages.join("\n"), "warning", 3000, true);

            } else {

                //Se arma la estrutura de datos
                $scope.object = {
                    start_date: convertFechaYYMMDD($scope.date, "es-ES", {}),
                    start_time: $scope.startTime.hour24,
                    end_time: $scope.endTime.hour24,
                    tables: [],
                };

                //Se crea el array de mesas bloqueadas          
                for (var i = 0; i < $scope.mesasBloqueadas.length; i++) {
                    $scope.object.tables.push({
                        id: $scope.mesasBloqueadas[i]
                    });
                }

                if (option == "create") {
                    saveBlock($scope.object);
                } else {
                    editBlock(block_id, $scope.object);
                }

            }
        };

        $scope.selectAllTables = function() {
            BlockFactory.selectAllTables($scope, $sce, loadTablesEdit);
        };

        $scope.unselectAllTables = function() {
            BlockFactory.unselectAllTables($scope, $sce, loadTablesEdit);
        };

        $scope.cancel = function() {
            return redirect();
        };

        var redirect = function() {
            if ($state.is("mesas.book.block") || $state.is("mesas.book.blockEdit")) {
                $state.go("mesas.book", $stateParams);
            } else if ($state.is("mesas.grid.block.edit") || $state.is("mesas.grid.block")) {
                historyBack();
            } else {
                $state.go("mesas.floor.reservation");
            }
        };

        var resize = function() {
            $scope.size = screenHelper.size(screenSizeBlock);

            angular.element($window).bind('resize', function() {
                var size = screenHelper.size(screenSizeBlock);
                $scope.size = size;
                $scope.$digest();
            });
        };

        var clearData = function() {
            $scope.itemTables.length = 0;

            $scope.object = {};
            $scope.zones.length = 0;

            $scope.shifts.length = 0;
            $scope.startTimes.length = 0;
            $scope.endTimes.length = 0;

            $scope.zone = null;

            var zoneIndexMax = 0;
            var zoneIndex = 0;

            var mesasFuturasBloqueadas = null;

            $scope.mesasBloqueadas.length = 0;
            $scope.someSafeContent = "";
        };

        var InitModule = function(date) {
            if ($stateParams.block_id !== undefined) {
                block_id = $stateParams.block_id;
            }

            clearData();
            reservationService.blockMaster(date, block_id)
                .then(function(response) {
                    runZones(response.data.data.zones);
                    runShifts(response.data.data.shifts);
                    runBlocks(response.data.data.blockTables);
                    runBlock(response.data.data.block);
                }).catch(function(error) {
                    message.apiError(error);
                });
        };

        var runZones = function(zones) {
            $scope.zones = zones; // Lista de Zonas que contienen mesas
            zoneIndexMax = $scope.zones.length;
            $scope.zone = $scope.zones[0];
        };

        var runBlocks = function(blocks) {
            mesasFuturasBloqueadas = blocks;
            $scope.selectZone($scope.zones[0]);
        };

        var runBlock = function(block) {
            if (block === null) {
                return;
                // evaluar si el estado es editar, redireccionar.
            }

            $scope.tableBlock = block;

            angular.forEach($scope.tableBlock.tables, function(mesa, indexMesa) {
                $scope.mesasBloqueadas.push(mesa.id);
            });

            BlockFactory.updateTablesBlocked($scope, $sce);

            angular.forEach($scope.zones, function(zona, key) {
                angular.forEach(zona.tables, function(mesa, i) {

                    for (var p = 0; p < $scope.mesasBloqueadas.length; p++) {

                        var exitsReservation = exitsReservationTable(mesa.id);

                        if (mesa.id === $scope.mesasBloqueadas[p] && exitsReservation === false) {
                            $scope.zones[key].tables[i].class = "selected-table";
                        }
                    }

                });

                $scope.selectZone($scope.zones[0]);

            });

            timesSelectedDefault($scope.tableBlock);
            $scope.loadBlockTables();
        };

        runShifts = function(shifts) {
            clearForm();
            angular.forEach(shifts, function(item, i) {
                if (item.turn !== null) { // Se obtienes los Shifts que contienen datos

                    $scope.shifts.push({
                        id: item.id,
                        name: item.name,
                        times: {
                            startTime: item.turn.hours_ini,
                            endTime: item.turn.hours_end
                        },
                        startTimes: getRangoHours(item.turn.hours_ini, item.turn.hours_end),
                        endTimes: getRangoHours(addHourByMin(item.turn.hours_ini), item.turn.hours_end, true),
                    });

                    // Se muestra el primer array para cuando se esta creando el bloqueo
                    $scope.shift = $scope.shifts[0];
                    $scope.startTimes = $scope.shifts[0].startTimes;
                    $scope.endTimes = $scope.shifts[0].endTimes;

                    if ($scope.startTimes.length > 0) {
                        $scope.startTime = $scope.startTimes[0];
                    }

                    if ($scope.endTimes.length > 0) {
                        $scope.endTime = $scope.endTimes[0];
                    }
                }
            });
        };

        (function Init() {
            resize();

            $scope.date = convertFechaToDate($stateParams.date);

            InitModule($scope.date);

            // listZones($stateParams.date);
            // listFormData($stateParams.date);
        })();
    });
angular.module('block.directive', [])
  .directive('ngSelectTable', function() {

    function makeSelectTable(scope, element, attr) {

      var left = attr.x;
      var top = attr.y;

      element.css({
        position: 'absolute',
        cursor: 'pointer',
        top: top + 'px',
        left: left + 'px',
      });
      element.on('click', function(event) {

        event.preventDefault();
        if (this.classList.contains('selected-table') === true) {
          this.classList.remove('selected-table');
          scope.onDeselectFn();
        } else {
          if (this.classList.contains('selected-table')) {
            this.classList.remove('selected-table');
          } else {
            this.classList.add('selected-table');
          }
          scope.onSelectedFn();
        }

      });
    }

    return {
      link: makeSelectTable,
      scope: {
        onSelectedFn: '&',
        onDeselectFn: '&'
      }
    };

  });
angular.module("block.filter", [])
    .filter("blockHour", [function() {
        return function(list, start, end) {
            if (!start) {
                return list;
            }

            var salida = [];
            var index = 0;
            
            for (var i = 0; i < list.length; i++) {
                if (list[i].hour24 == start.hour24) {
                    index = i;
                    break;
                }
            }

            index = index > 0 ? index+1 : index;
            for (var x = index; x < list.length; x++) {
                salida.push(list[x]);
            }

            return salida;
        };
    }]);
angular.module('block.service', [])
    .factory('BlockFactory', function($http, ApiUrlMesas, HttpFactory) {
        var zonesCalendar;
        var blocksAll;
        var blocks;
        var block;
        return {
            getZonesCalendar: function(date, reload) {
                zonesCalendar = HttpFactory.get(ApiUrlMesas + "/calendar/" + date + "/zones", {}, zonesCalendar, reload);
                return zonesCalendar;
            },
            getAllBlock: function(vDate, reload) {
                return $http.get(ApiUrlMesas + "/blocks/tables?" + vDate);
            },
            getBlocks: function(reload, params) {
                params = (params === undefined || params === null) ? "" : params;
                blocks = HttpFactory.get(ApiUrlMesas + "/blocks?" + params, null, blocks, reload);
                return blocks;
            },
            getBlock: function(vId, reload) {
                return $http.get(ApiUrlMesas + "/blocks/" + vId);
            },
            saveBlock: function(data) {
                return $http.post(ApiUrlMesas + "/blocks", data);
            },
            deleteBlock: function(id_block) {
                return $http.delete(ApiUrlMesas + "/blocks/" + id_block);
            },
            editBlock: function(id_block, data) {
                return $http.put(ApiUrlMesas + "/blocks/" + id_block, data);
            },
            coverList: function() {
                return {
                    dataMin: [],
                    selectedMin: '',
                    dataMax: [],
                    selectedMax: ''
                };
            },
            boxTables: function() {
                return {
                    items: true,
                    item: false
                };
            },
            updateTablesBlocked: function(scope, sce) {
                var res = scope.mesasBloqueadas.toString().replace(/,/g, ", ");
                scope.someSafeContent = sce.trustAsHtml("<b>" + res + "</b>");
            },
            checkTable: function(scope, sce, index, data) {

                //Se crea crea el metodo para poder identificar cual es la clase que esta seleccionada  
                //Se carga la clase a la mesa para poder mostrar en el sistema
                var zoneSelect = scope.zone;
                angular.forEach(scope.zones, function(value, key) {

                    if (value.id == zoneSelect.id) {
                        scope.zones[key].tables[index].class = "selected-table";
                    }

                });

                scope.mesasBloqueadas.push(data.id);
                this.updateTablesBlocked(scope, sce);
            },
            uncheckTable: function(scope, sce, index, data) {

                //Se crea crea el metodo para poder identificar cual es la clase que esta seleccionada  
                //Se carga la clase a la mesa para poder mostrar en el sistema
                var zoneSelect = scope.zone;
                angular.forEach(scope.zones, function(value, key) {

                    if (value.id == zoneSelect.id) {
                        scope.zones[key].tables[index].class = "";
                    }

                });

                var item = scope.mesasBloqueadas.indexOf(data.id);

                if (item > -1) {
                    data.class = "";
                    scope.mesasBloqueadas.splice(item, 1);
                }

                this.updateTablesBlocked(scope, sce);
            },
            selectAllTables: function(scope, sce, loadTablesEdit) {

                var zoneIndexShow = scope.zoneIndexShow;

                angular.forEach(scope.zones[zoneIndexShow].tables, function(mesa, i) {
                    scope.zones[zoneIndexShow].tables[i].class = "selected-table";
                    // Se agrega la mesa bloqueada en el array de mesasBloqueadas
                    if (scope.mesasBloqueadas.indexOf(scope.zones[zoneIndexShow].tables[i].id) == -1) {
                        scope.mesasBloqueadas.push(scope.zones[zoneIndexShow].tables[i].id);
                    }
                });

                this.updateTablesBlocked(scope, sce);

                var posicion = scope.zones.indexOf(scope.zone);
                if (posicion != -1) {
                    var item = scope.zones[posicion];
                    angular.forEach(scope.zones, function(value, key) {
                        if (value.id == item.id) {
                            scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                            loadTablesEdit(value.tables);
                        }
                    });
                }
            },
            unselectAllTables: function(scope, sce, loadTablesEdit) {

                var zoneIndexShow = scope.zoneIndexShow;

                // Se remuven todas las mesas bloqueadas de una zona
                angular.forEach(scope.zones[zoneIndexShow].tables, function(mesa, i) {
                    scope.zones[zoneIndexShow].tables[i].class = "";
                    var tableId = scope.zones[zoneIndexShow].tables[i].id;
                    var pos = scope.mesasBloqueadas.indexOf(tableId);
                    if (pos > -1) {
                        scope.mesasBloqueadas.splice(pos, 1);
                    }
                });

                this.updateTablesBlocked(scope, sce);

                var posicion = scope.zones.indexOf(scope.zone);
                if (posicion != -1) {
                    var item = scope.zones[posicion];
                    angular.forEach(scope.zones, function(value, key) {
                        if (value.id == item.id) {
                            scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                            loadTablesEdit(value.tables);
                        }
                    });
                }
            },
            initItemTables: function(scope, tables, TableFactory) {

                angular.forEach(tables, function(data) {

                    var position = data.config_position.split(",");
                    var dataTable = {
                        name: data.name,
                        class: data.class,
                        classBloqueado: data.classBloqueado,
                        minCover: data.min_cover,
                        maxCover: data.max_cover,
                        left: position[0],
                        top: position[1],
                        shape: TableFactory.getLabelShape(data.config_forme),
                        size: TableFactory.getLabelSize(data.config_size),
                        rotate: data.config_rotation,
                        id: data.id,
                        status: data.status
                    };

                    if (data.status == 1) {
                        scope.itemTables.push(dataTable);
                    } else {
                        //scope.itemTablesDeleted.push(dataTable);
                    }

                });
            }

        };

    });
angular.module('book.app', ['book.controller', 'book.service', 'book.directive', 'book.filter'])
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.book', {
                url: '/book?date&date_end&turns&zones&sources&search_text&sort',
                views: {
                    "@": {
                        templateUrl: '/js/app/tables/book/view/parent.html',
                        controller: 'BookNotificationCtrl'
                    },
                    'index@mesas.book': {
                        templateUrl: '/js/app/tables/book/view/index.html',
                        controller: 'BookCtrl',
                        controllerAs: 'vm'
                    },
                },
                resolve: {
                    $title: function() {
                        return 'Book';
                    }
                }
            });

    });
angular.module('book.controller', [])
    .controller('BookCtrl', function($uibModal, $scope, $stateParams, $location, $timeout, orderByFilter, BookFactory,
        CalendarService, reservationService, BookDataFactory, $state, ConfigurationDataService, BookConfigFactory, FloorFactory) {

        var vm = this;
        vm.fecha_actual = moment().format('YYYY-MM-DD');
        vm.btnRageCalendar = false;

        /**
         * Manejo de rango de fechas
         */

        /**
         * Fecha de inicio (hoy), se aplica UTC,
         * datepicker covierte la zona horaria a utc y agrega/remueve horas
         * @type {[Date | String]}
         */
        var dp_date = moment().utc().toDate();

        vm.startDate = dp_date;
        vm.endDate = dp_date;
        // vm.maxDate = dp_date;

        /**
         * Limpia el casillero de informacion de rango de fechas
         * @return {[Void]}
         */
        vm.clearDateInfo = function() {
            vm.date_info = null;
        };

        /**
         * Rango de fechas restando hacia atras
         * @param  {Integer} start [numero de dias]
         * @param  {Integer} end   [numero de dias]
         * @param  {$event | DOM} event [manipular las clases]
         * @return  void
         */
        vm.changeDateCustom = function(start, end, event, init) {
            vm.startDate = moment().add(end, "days").utc().toDate();
            vm.endDate = moment().add(start, "days").utc().toDate();

            setConfigUserDate(end);

            if (init === true) {
                initDateEvent(event.currentTarget);
            } else {
                fireDateEvent();
            }
        };

        /**
         * Rango de fechas por bloque, esta semana | mes
         * @param  {String} block [semana | mes]
         * @param  {$event | DOM} event [manipular clases]
         * @return  void
         */
        vm.changeDateBlock = function(block, event, init) {
            vm.startDate = moment().startOf(block).utc().toDate();
            vm.endDate = moment().endOf(block).utc().toDate();

            setConfigUserDate(block);

            if (init === true) {
                initDateEvent(event.currentTarget);
            } else {
                fireDateEvent();
            }
        };

        /**
         * Rango de fechas del mes pasado
         * @param  {$event | DOM} event [manipular clases]
         * @return void
         */
        vm.changeDateLastMonth = function(event, init) {
            var date = moment().startOf('month').subtract(1, "days");
            vm.startDate = date.startOf('month').utc().toDate();
            vm.endDate = date.endOf('month').utc().toDate();

            setConfigUserDate('last-month');

            if (init === true) {
                initDateEvent(event.currentTarget);
            } else {
                fireDateEvent();
            }
        };

        /**
         * Mostrar calendario de rango de fechas
         * @param  {$event | DOM} event [manipular clases]
         * @return void
         */
        vm.showDateRange = function(event) {
            setConfigUserDate('range');
            initDateEvent(event.currentTarget, true);
            vm.btnRageCalendar = true;
        };

        /**
         * Manipulacion de clases y dom
         * @type {DOM} element [manipulacion de clases]
         * @type {Boolean} dp_range [mostrar o esconder calendario]
         */
        var checkElem = angular.element('<i class="zmdi zmdi-check zmdi-hc-fw pull-right"></i>');
        var selectDpMenu = function(element) {
            var list = document.querySelectorAll(".list-group .list-group-item");
            angular.element(list).removeClass("active");
            angular.forEach(list, function(item) {
                var check = item.querySelector(".zmdi");
                angular.element(check).remove();
            });
            var current = angular.element(element).addClass("active").append(checkElem);
        };

        var initDateEvent = function(element, dp_range) {
            selectDpMenu(element);
            if (!dp_range) hideRangeCalendar();
            vm.dp_range = !dp_range ? false : true;
            fireDateEvent();
        };

        /**
         * Cambio de fecha de fin por accion del usuario | click en calendario
         * @return void
         */
        vm.changeDateEnd = function(userClick) {
            if (userClick) {
                hideRangeCalendar();
                fireDateEvent();
            }
        };

        var hideRangeCalendar = function() {
            angular.element(document.querySelector("[bs-toggle-click]")).click();
        };

        var fireDateEvent = function() {

            var date_start = convertFechaYYMMDD(vm.startDate, "es-ES", {});
            var date_end = convertFechaYYMMDD(vm.endDate, "es-ES", {});

            updateUrl(date_start, date_end, false);
        };

        /**
         * End
         */

        /**
         *  Data para validacion de alerta para conteo de lista de invitados
         */
        var guest_list_count = function(reservations) {
            reservations.reduce(function(data, item, i) {
                if (!item.reservation) return data;
                Object.assign(item.reservation, {
                    men: 0,
                    women: 0,
                    children: 0
                });
                item.reservation.guest_list.reduce(function(reservation, item) {
                    if (item.type_person === 1) {
                        reservation.men++;
                    } else if (item.type_person === 2) {
                        reservation.women++;
                    } else if (item.type_person === 3) {
                        reservation.children++;
                    }
                    return reservation;
                }, item.reservation);
            }, this);
        };
        /**
         * END
         */

        vm.turns = [];
        vm.hoursTurns = []; //Lista de horas segun los turnos
        vm.listBook = []; //Listado del book para los filtros
        vm.listBookReserva = []; //Listado del book,solo reservaciones
        vm.listBookMaster = []; //Listado del book original (no se afecta con los filtros)
        vm.sources = [];
        vm.zones = [];
        vm.statusReservation = []; //Listado de status para reservaciones       

        vm.bookFilter = {
            typeTurn: [],
            sources: [],
            zones: [],
            noStatus: [],
            blocks: true,
            date: '',
            options: {
                turnAll: false,
                sourcesAll: false,
                zonesAll: false,
                noStatusFree: true,
                noStatusCancel: true,
                blocks: true,
            },
            text: '',
            search_text: '',
            numGuest: {
                data: [],
                selected: 0,
                textMore: '+',
            },
            params_url: null
        };

        //Ordernar book general
        vm.bookOrderBy = {
            general: {
                value: 'time',
                reverse: false
            },
            resBlock: {
                value: '',
                reverse: false,
                status: '+reservation.res_reservation_status_id',
                covers: '+reservation.num_guest',
                guest: '-reservation.guest_filter',
                table: '-reservation.table_filter',
                date: '-reservation.start_date'
            },
            reservation: {
                time: 'time.desc',
                status: 'status.desc',
                covers: 'covers.desc',
                guest: 'guest.desc',
                table: 'table.desc'
            }
        };

        //vm.hideFields = {};

        //Book View (Reservaciones)
        vm.bookView = false;

        //Cabecera del book
        vm.resumenBook = {
            reservations: 0,
            pax: 0,
            ingresos: 0,
            conversion: 0
        };

        //MDS
        vm.mds = '';

        //Configuracion de reservaciones - modulo config
        vm.configReservation = null;

        //Data default localStorage configuracion del usuario 
        vm.configUserDefault = {
            reservationView: false,
            rangeDate: {
                hoy: false,
                week: false, //esta semana
                lastSevenDays: false, //ultimos 7 dias
                lastThirtyDays: false, //ultimos 30 dias
                thisMonth: false, //este mes
                lastMonth: false, //mes pasado
                range: false //rango de fechas
            },
            url: null,
            filters: {
                turns: [],
                status: [],
                sources: [],
                zones: [],
            },
            order: 'time.asc',
            page_size: 30,
            page: 1,
            fields: {
                consume: true,
                messages: true,
                listguests: true,
                source: true
            }
        };

        //Fechas formato string (2016-11-24) , para los filtros
        vm.datesText = {
            start_date: '',
            end_date: ''
        };

        //Notas turnos
        vm.notesBox = false;
        vm.notesBoxValida = false;

        vm.notesData = {
            texto: '',
            res_type_turn_id: ''
        };

        vm.notesSave = false; // se activa cuando creamos notas

        var validaNumGuestClick = false;
        var validaUpdateBookRes;
        var timeoutNotes;

        //para la paginacion de reservaciones
        vm.paginate_reservation = {
            page: 1,
            total_pages: 0,
            page_size: 10,
            selected: 1,
            max_size: 5,
            options: []
        };

        /*Filtros de ajustes en footer */
        vm.filterAjustes = function(option) {
            switch (option) {
                case 'show.released':
                    vm.filterBook('released', {
                        "id": 5
                    });
                    break;
                case 'show.canceled':
                    vm.filterBook('canceled', {
                        "id": 6
                    });
                    break;
                case 'show.blocks':
                    vm.filterBook('blocks', null);
                    break;
                case 'fields.consume':
                    vm.changeShowFieldsReservations('consume');
                    break;
                case 'fields.messages':
                    vm.changeShowFieldsReservations('messages');
                    break;
                case 'fields.listguests':
                    vm.changeShowFieldsReservations('listguests');
                    break;
                case 'fields.source':
                    vm.changeShowFieldsReservations('source');
                    break;
            }
        };

        vm.showFieldReservation = function(option) {
            var result = true;
            switch (option) {
                case 'consume':
                    result = vm.configUserDefault.fields.consume;
                    break;
                case 'messages':
                    result = vm.configUserDefault.fields.messages;
                    break;
                case 'listguests':
                    result = vm.configUserDefault.fields.listguests;
                    break;
                case 'source':
                    result = vm.configUserDefault.fields.source;
                    break;
                default:
            }
            return result;
        };

        /* Cambio de estados para Ocultar campos de reservacion */
        vm.changeShowFieldsReservations = function(option) {
            switch (option) {
                case 'consume':
                    vm.configUserDefault.fields.consume = !vm.configUserDefault.fields.consume;
                    break;
                case 'messages':
                    vm.configUserDefault.fields.messages = !vm.configUserDefault.fields.messages;
                    break;
                case 'listguests':
                    vm.configUserDefault.fields.listguests = !vm.configUserDefault.fields.listguests;
                    break;
                case 'source':
                    vm.configUserDefault.fields.source = !vm.configUserDefault.fields.source;
                    break;
            }
            BookConfigFactory.save();
        };

        /* Modificar opciones de filtro de Book reservations */
        vm.filterBook = function(option, value) {

            switch (option) {

                case 'released':
                    vm.configUserDefault.show.released = !vm.configUserDefault.show.released;
                    BookFactory.addNoStatusByFilter(value, vm.bookFilter.noStatus, vm.status, vm.configUserDefault.show.released);
                    vm.configUserDefault.filters.status = vm.bookFilter.noStatus;
                    break;
                case 'canceled':
                    vm.configUserDefault.show.canceled = !vm.configUserDefault.show.canceled;
                    BookFactory.addNoStatusByFilter(value, vm.bookFilter.noStatus, vm.status, vm.configUserDefault.show.canceled);
                    vm.configUserDefault.filters.status = vm.bookFilter.noStatus;
                    break;
                case 'blocks':
                    vm.configUserDefault.show.blocks = !vm.configUserDefault.show.blocks;
                    vm.bookFilter.blocks = vm.configUserDefault.show.blocks;
                    break;
                case 'turn':
                    if (value !== "all") {
                        if (value.turn === null) {
                            return;
                        }
                    }
                    vm.bookFilter.options.turnAll = (value == "all") ? !vm.bookFilter.options.turnAll : vm.bookFilter.options.turnAll;
                    BookFactory.addTurnsByFilter(value, vm.bookFilter.typeTurn, vm.turns, vm.bookFilter.options.turnAll);
                    vm.configUserDefault.filters.turns = vm.bookFilter.typeTurn;
                    break;
                case 'source':
                    vm.bookFilter.options.sourcesAll = (value == "all") ? !vm.bookFilter.options.sourcesAll : vm.bookFilter.options.sourcesAll;
                    BookFactory.addSourcesByFilter(value, vm.bookFilter.sources, vm.sources, vm.bookFilter.options.sourcesAll);
                    vm.configUserDefault.filters.sources = vm.bookFilter.sources;
                    break;
                case 'zones':
                    vm.bookFilter.options.zonesAll = (value == "all") ? !vm.bookFilter.options.zonesAll : vm.bookFilter.options.zonesAll;
                    BookFactory.addZonesByFilter(value, vm.bookFilter.zones, vm.zones, vm.bookFilter.options.zonesAll);
                    vm.configUserDefault.filters.zones = vm.bookFilter.zones;
                    break;
                case 'reservations':
                    vm.orderBook(value);
                    break;
                default:
                    vm.orderBook('time');
                    break;
            }

            BookConfigFactory.save();

            if (option !== "reservations" && option !== "time") {
                vm.searchReservations();
            }
        };

        vm.orderBook = function(value) {

            if (value === vm.bookOrderBy.resBlock.value && vm.bookView === true) {
                return;
            }

            if (vm.bookView === true && value !== "reservations") {
                setOrderBookReservation(value, true);
                return;
            }

            var reservations = BookFactory.filterReservationsAndBlocks(vm.listBook, vm.bookView);
            var pos = value.indexOf(".");
            value = value.substring(0, pos);
            switch (value) {
                case 'time':
                    vm.bookOrderBy.general.reverse = (vm.bookOrderBy.general.value == value) ? !vm.bookOrderBy.general.reverse : false;
                    vm.bookOrderBy.general.value = 'time';
                    vm.listBook = orderByFilter(vm.listBook, 'time', vm.bookOrderBy.general.reverse);
                    break;
                case 'status':
                    vm.bookOrderBy.resBlock.value = 'status';

                    var filterStatus = orderByFilter(reservations.reservations, [vm.bookOrderBy.resBlock.status]);
                    vm.listBook = filterStatus.concat(reservations.availables);
                    vm.bookOrderBy.resBlock.status = (vm.bookOrderBy.resBlock.status === "+reservation.res_reservation_status_id") ? "-reservation.res_reservation_status_id" : "+reservation.res_reservation_status_id";

                    break;
                case 'covers':
                    vm.bookOrderBy.resBlock.value = "covers";

                    var filterCovers = orderByFilter(reservations.reservations, [vm.bookOrderBy.resBlock.covers]);
                    vm.listBook = filterCovers.concat(reservations.availables);
                    vm.bookOrderBy.resBlock.covers = (vm.bookOrderBy.resBlock.covers === "+reservation.num_guest") ? "-reservation.num_guest" : "+reservation.num_guest";

                    break;
                case 'guest':
                    vm.bookOrderBy.resBlock.value = "guest";

                    var filterGuest = orderByFilter(reservations.reservations, [vm.bookOrderBy.resBlock.guest]);
                    vm.listBook = filterGuest.concat(reservations.availables);
                    vm.bookOrderBy.resBlock.guest = (vm.bookOrderBy.resBlock.guest === "-reservation.guest_filter") ? "+reservation.guest_filter" : "-reservation.guest_filter";

                    break;
                case 'table':
                    vm.bookOrderBy.resBlock.value = "table";

                    var filterTable = orderByFilter(reservations.reservations, [vm.bookOrderBy.resBlock.table]);
                    vm.listBook = filterTable.concat(reservations.availables);
                    vm.bookOrderBy.resBlock.table = (vm.bookOrderBy.resBlock.table === "-reservation.table_filter") ? "+reservation.table_filter" : "-reservation.table_filter";

                    break;
                case 'date':
                    vm.bookOrderBy.resBlock.value = "date";

                    var filterDate = orderByFilter(reservations.reservations, [vm.bookOrderBy.resBlock.date]);
                    vm.listBook = filterDate.concat(reservations.availables);
                    vm.bookOrderBy.resBlock.date = (vm.bookOrderBy.resBlock.date === "-reservation.hours_reservation") ? "+reservation.hours_reservation" : "-reservation.hours_reservation";

                    break;
                case 'reservations':
                    var filterRes = orderByFilter(reservations.reservations, [vm.bookOrderBy.resBlock.date]);
                    vm.listBook = filterRes;
                    // vm.bookOrderBy.resBlock.date = (vm.bookOrderBy.resBlock.date === "-reservation.hours_reservation") ? "+reservation.hours_reservation" : "-reservation.hours_reservation";

                    break;
            }
        };

        vm.openCalendar = function($event, opened) {
            $event.preventDefault();
            $event.stopPropagation();
            vm.calendar = true;
        };

        //Habilita modo reserva
        vm.changeBookView = function(reloadUrl) {
            var date_ini = $stateParams.date;

            if (vm.bookView === false) {
                vm.bookOrderBy.general.reverse = true;
                vm.filterBook('time', 'time');
                date_ini = vm.fecha_actual;
            }

            vm.configUserDefault.reservationView = vm.bookView;
            BookConfigFactory.save();
            if (reloadUrl === true) {
                updateUrl(date_ini, $stateParams.date_end, false);
            }
        };

        //Actualiza la reservacion cuando clickeamos
        vm.numGuestChange = function(type, option, value) {

            vm.blockClickBook();
            if (validaUpdateBookRes) $timeout.cancel(validaUpdateBookRes);

            switch (option) {
                case 'men':
                    value.reservation.num_people_1 = (type == "-") ? value.reservation.num_people_1 - 1 : value.reservation.num_people_1 + 1;
                    value.reservation.num_people_1 = (value.reservation.num_people_1 <= 0) ? 0 : value.reservation.num_people_1;
                    break;
                case 'women':
                    value.reservation.num_people_2 = (type == "-") ? value.reservation.num_people_2 - 1 : value.reservation.num_people_2 + 1;
                    value.reservation.num_people_2 = (value.reservation.num_people_2 <= 0) ? 0 : value.reservation.num_people_2;
                    break;
                case 'child':
                    value.reservation.num_people_3 = (type == "-") ? value.reservation.num_people_3 - 1 : value.reservation.num_people_3 + 1;
                    value.reservation.num_people_3 = (value.reservation.num_people_3 <= 0) ? 0 : value.reservation.num_people_3;
                    break;
            }

            vm.resumenBook.ingresos = (type == "-") ? vm.resumenBook.ingresos - 1 : vm.resumenBook.ingresos + 1;

            validaUpdateBookRes = $timeout(function() {
                var resUpdate = {
                    id: value.reservation.id,
                    num_people_1: value.reservation.num_people_1,
                    num_people_2: value.reservation.num_people_2,
                    num_people_3: value.reservation.num_people_3
                };
                updateReservationBook(resUpdate);
            }, 1000);
        };

        vm.blockClickBook = function() {
            validaNumGuestClick = true;
            $timeout(function() {
                validaNumGuestClick = false;
            }, 500);
        };

        vm.updateStatusReservation = function(reservation, status) {
            vm.blockClickBook();

            var resUpdate = {
                id: reservation.id,
                res_reservation_status_id: status
            };

            updateReservationBook(resUpdate);
        };

        vm.updateConsumeReservation = function(reservation) {
            vm.blockClickBook();

            if (validaUpdateBookRes) $timeout.cancel(validaUpdateBookRes);

            validaUpdateBookRes = $timeout(function() {
                var resUpdate = {
                    id: reservation.id,
                    consume: reservation.consume,
                };
                updateReservationBook(resUpdate);
            }, 1000);
        };

        vm.saveNotes = function(turn) {

            if (timeoutNotes) $timeout.cancel(timeoutNotes);

            vm.notesData.id = turn.notes.id;
            vm.notesData.res_type_turn_id = turn.id;
            vm.notesData.texto = turn.notes.texto;
            vm.notesData.date_add = turn.notes.date_add;

            timeoutNotes = $timeout(function() {
                reservationService.blackList.key(vm.notesData);

                FloorFactory.createNotes(vm.notesData).then(
                    function success(response) {
                        vm.notesSave = true;
                    },
                    function error(response) {
                        message.apiError(response);
                        console.error("saveNotes " + angular.toJson(response, true));
                    }
                );
            }, 1000);
        };

        vm.readNotes = function(notification) {
            vm.notesBoxValida = true;
            vm.notesNotification = false;
        };

        vm.listenNotes = function(notification) {
            vm.notesBoxValida = false;
            vm.notesNotification = false;
        };

        vm.editReservation = function(item) {
            if (validaNumGuestClick === true) {
                return;
            }
            $state.go('mesas.book-reservation-edit', {
                id: item.reservation.id,
                date: item.reservation.date_reservation
            });
        };

        vm.createReservation = function(data) {
            if (data.block === null) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'ModalCreateBookReservation.html',
                    controller: 'ModalBookReservationCtrl',
                    controllerAs: 'br',
                    size: '',
                    resolve: {
                        data: function() {
                            return data;
                        },
                        date: function() {
                            return vm.bookFilter.date;
                        }
                    }
                });
            } else {
                $state.go('mesas.floor.blockEdit', {
                    date: data.block.start_date,
                    block_id: data.block.id
                });
            }
        };

        vm.checkGuestList = function(reservation) {
            vm.blockClickBook();

            var modalInstance = $uibModal.open({
                templateUrl: 'ModalCheckGuestList.html',
                controller: 'ModalCheckGuestListBookCtrl',
                controllerAs: 'gl',
                size: 'md',
                resolve: {
                    reservation: function() {
                        return reservation;
                    },
                    configuration: function() {
                        return vm.configReservation;
                    }
                }
            });
        };

        vm.mailReservartion = function(reservation) {
            vm.blockClickBook();
            var modalInstance = $uibModal.open({
                templateUrl: 'ModalMailReservation.html',
                controller: 'ModalMailReservationCtrl',
                controllerAs: 'vm',
                size: '',
                resolve: {
                    reservation: function() {
                        return reservation;
                    }
                }
            });
        };

        vm.changeResultPagination = function() {
            vm.paginate_reservation.page_size = vm.paginate_reservation.selectedPageSize.id;
            vm.configUserDefault.page_size = vm.paginate_reservation.page_size;
            vm.changePagination();
        };

        vm.changePagination = function() {
            vm.paginate_reservation.page = vm.paginate_reservation.selected;
            vm.configUserDefault.page = vm.paginate_reservation.page;
            setDatesText(vm.startDate, vm.endDate);
            var params_url = paramsFilterReservation(true);
            pushParamsUrl(params_url);
            setUrlNavigationConfig(null);
            BookConfigFactory.save();
            generatedListBookPagination(vm.datesText.start_date, vm.datesText.end_date);
        };

        vm.searchReservations = function() {
            if (vm.bookView === true) {
                vm.changePagination();
            } else {
                setUrlNavigationConfig(null);
            }
        };

        $scope.$on("NotifyBookConfigReload", function(evt, message) {
            alert(message + " Se requiere volver a cargar la página.");
            location.reload();
        });

        $scope.$on("NotifyNewReservation", function(evt, data) {

            var response = addNewReservation(data.data, data.action);
            // if (response === true) {
            //     if (!reservationService.blackList.contains(data.key)) {
            //         // alertMultiple("Notificación", data.user_msg, "info", null);
            //         // generatedHeaderInfoBook(vm.datesText.start_date, vm.datesText.end_date);
            //     }
            // }
        });

        $scope.$watch('vm.bookFilter.date', function(newDate, oldDate) {
            if (newDate !== oldDate) {
                newDate = convertFechaYYMMDD(newDate, "es-ES", {});
                updateUrl(newDate, $stateParams.date_end, true);
            }
        });

        $scope.$watch("vm.listBook", guest_list_count, true, vm.listBook.reservation);

        $scope.$on('resumenBookUpdate', function(evt, data) {
            vm.resumenBook = data;
        });

        $scope.$on("floorNotesReload", function(evt, note) {
            if (!reservationService.blackList.contains(note.key)) {
                angular.forEach(vm.turns, function(typeTurn) {
                    if (typeTurn.turn) {
                        if (note.data.res_type_turn_id == typeTurn.turn.res_type_turn_id) {
                            typeTurn.notes = typeTurn.notes ? typeTurn.notes : {};
                            typeTurn.notes.texto = note.data.texto;
                        }
                    }
                });

                if (!vm.notesBoxValida) {
                    vm.notesNotification = true;
                }

                $scope.$apply();
            }
        });

        var init = function() {
            BookFactory.init($scope);
            loadConfigViewReservation();
            listNumGuest();
            listResultsPagination();
        };

        var setUrlNavigationConfig = function(url) {
            url = paramsFilterReservation(true);
            vm.configUserDefault.url = url;
            BookConfigFactory.setConfig(vm.configUserDefault);
        };

        var listNumGuest = function() {
            vm.bookFilter.numGuest.data.push({
                id: 0,
                text: 'Todos'
            });

            for (var i = 1; i <= 22; i++) {
                var text = (i === 1) ? " invitado" : " invitados";
                vm.bookFilter.numGuest.data.push({
                    id: i,
                    text: i + text
                });
            }
            vm.bookFilter.numGuest.selected = vm.bookFilter.numGuest.data[0];
        };

        var listResultsPagination = function() {
            vm.paginate_reservation.optionsPageSise = [];
            var index = 0;
            var value = 0;
            for (var i = 0; i <= 10; i++) {
                value = value + 10;
                vm.paginate_reservation.optionsPageSise.push({
                    id: value,
                    text: value + ' Reservaciones por página'
                });
                if (value == vm.configUserDefault.page_size) {
                    index = i;
                }
            }
            vm.paginate_reservation.selected = vm.configUserDefault.page;
            vm.paginate_reservation.page_size = vm.configUserDefault.page_size;
            vm.paginate_reservation.selectedPageSize = vm.paginate_reservation.optionsPageSise[index];
        };

        var getSortByFilterReservation = function() {
            var order = "";
            switch (vm.bookOrderBy.resBlock.value) {
                case 'time':
                    order = vm.bookOrderBy.reservation.time;
                    break;
                case 'status':
                    order = vm.bookOrderBy.reservation.status;
                    break;
                case 'covers':
                    order = vm.bookOrderBy.reservation.covers;
                    break;
                case 'guest':
                    order = vm.bookOrderBy.reservation.guest;
                    break;
                case 'table':
                    order = vm.bookOrderBy.reservation.table;
                    break;
                default:
                    break;
            }
            return order;
        };

        var paramsFilterReservation = function(filter) {
            var orderSortBy = getSortByFilterReservation();
            var params_url = {
                date: vm.datesText.start_date,
                date_end: vm.datesText.end_date,
                /*status: ($stateParams.status === undefined || vm.bookFilter.status.toString() !== "") ? vm.bookFilter.status.toString() : $stateParams.status,
                blocks: ($stateParams.blocks === undefined || vm.bookFilter.blocks == true) ? vm.bookFilter.blocks.toString() : $stateParams.blocks,*/
                turns: ($stateParams.turns === undefined || vm.bookFilter.typeTurn.toString() !== "") ? vm.bookFilter.typeTurn.toString() : $stateParams.turns,
                zones: ($stateParams.zones === undefined || vm.bookFilter.zones.toString() !== "") ? vm.bookFilter.zones.toString() : $stateParams.zones,
                sources: ($stateParams.sources === undefined || vm.bookFilter.sources.toString() !== "") ? vm.bookFilter.sources.toString() : $stateParams.sources,
                search_text: ($stateParams.search_text === undefined || vm.bookFilter.search_text !== "") ? vm.bookFilter.search_text : $stateParams.search_text,
                sort: ($stateParams.sort === undefined || orderSortBy !== "") ? orderSortBy : $stateParams.sort
            };

            if (params_url.start_date === "") {
                delete params_url.start_date;
            }

            if (params_url.search_text === "") {
                delete params_url.search_text;
            }

            if (params_url.status === "") {
                delete params_url.status;
            }
            if (params_url.blocks === "") {
                delete params_url.blocks;
            }

            if (params_url.turns === "") {
                delete params_url.turns;
            }
            if (params_url.zones === "") {
                delete params_url.zones;
            }

            if (params_url.sources === "") {
                delete params_url.sources;
            }

            if (params_url.sort === "") {
                delete params_url.sort;
            }

            if (filter === true) {
                if (vm.bookFilter.search_text === "") {
                    delete params_url.search_text;
                }

                if (vm.bookFilter.zones.length <= 0) {
                    delete params_url.zones;
                }

                if (vm.bookFilter.sources.length <= 0) {
                    delete params_url.sources;
                }

                if (vm.bookFilter.typeTurn.length <= 0) {
                    delete params_url.turns;
                }
            }

            vm.bookFilter.params_url = params_url;

            return vm.bookFilter.params_url;
        };

        var pushParamsUrl = function(params) {
            var url = $location.absUrl();
            var index = url.indexOf("?");
            url = url.substring(0, index);

            params = getAsUriParameters(params);
            history.replaceState('', 'Pagina', url + "?" + params);
        };

        var setOrderBookReservation = function(option, search) {

            var orderVal = validateOrderBy(option);
            var order = orderVal.split(".");

            var order_type = (order[1] === "asc") ? "desc" : "asc";
            switch (order[0]) {
                case 'time':
                    vm.bookOrderBy.reservation.time = (search === true) ? order[0] + "." + order_type : orderVal;
                    vm.bookOrderBy.resBlock.value = "time";
                    break;
                case 'status':
                    vm.bookOrderBy.reservation.status = (search === true) ? order[0] + "." + order_type : orderVal;
                    vm.bookOrderBy.resBlock.value = 'status';
                    break;
                case 'covers':
                    vm.bookOrderBy.reservation.covers = (search === true) ? order[0] + "." + order_type : orderVal;
                    vm.bookOrderBy.resBlock.value = "covers";
                    break;
                case 'guest':
                    vm.bookOrderBy.reservation.guest = (search === true) ? order[0] + "." + order_type : orderVal;
                    vm.bookOrderBy.resBlock.value = "guest";
                    break;
                case 'table':
                    vm.bookOrderBy.reservation.table = (search === true) ? order[0] + "." + order_type : orderVal;
                    vm.bookOrderBy.resBlock.value = "table";
                    break;
                case 'date':
                    //vm.bookOrderBy.resBlock.value = (vm.bookOrderBy.resBlock.value === "time" || vm.bookOrderBy.resBlock.value === "time.asc") ? "time.desc" : "time.asc";
                    break;
            }

            if (search === true) {
                vm.searchReservations();
            }
        };

        var validateOrderBy = function(value) {
            var pos = value.indexOf(".");
            if (pos < 0) {
                value = value + ".asc";
            }
            return value;
        };

        var setDatesText = function(startDate, endDate) {
            vm.datesText.start_date = (typeof startDate === 'string') ? startDate : convertFechaYYMMDD(startDate, "es-ES", {});
            vm.datesText.end_date = (endDate !== null) ? convertFechaYYMMDD(endDate, "es-ES", {}) : '';
        };

        var defaultConfigCalendar = function() {
            vm.configUserDefault.rangeDate.hoy = false;
            vm.configUserDefault.rangeDate.week = false;
            vm.configUserDefault.rangeDate.lastSevenDays = false;
            vm.configUserDefault.rangeDate.lastThirtyDays = false;
            vm.configUserDefault.rangeDate.thisMonth = false;
            vm.configUserDefault.rangeDate.lastMonth = false;
            vm.configUserDefault.rangeDate.range = false;
        };

        var setConfigUserDate = function(date) {
            defaultConfigCalendar();
            switch (date) {
                case 0:
                    vm.configUserDefault.rangeDate.hoy = true;
                    break;
                case 'week':
                    vm.configUserDefault.rangeDate.week = true;
                    break;
                case -7:
                    vm.configUserDefault.rangeDate.lastSevenDays = true;
                    break;
                case -30:
                    vm.configUserDefault.rangeDate.lastThirtyDays = true;
                    break;
                case 'month':
                    vm.configUserDefault.rangeDate.thisMonth = true;
                    break;
                case 'last-month':
                    vm.configUserDefault.rangeDate.lastMonth = true;
                    break;
                case 'range':
                    vm.configUserDefault.rangeDate.range = true;
                    break;
            }

            BookConfigFactory.setConfig(vm.configUserDefault);
        };

        var loadConfigViewReservation = function() {

            vm.configUserDefault = BookConfigFactory.getConfig();
            vm.bookFilter.noStatus = vm.configUserDefault.filters.status;
            vm.bookFilter.blocks = vm.configUserDefault.show.blocks;

            vm.fecha_actual = ($stateParams.date === undefined || $stateParams.date === "") ? vm.fecha_actual : $stateParams.date;

            vm.bookView = vm.configUserDefault.reservationView;
            vm.paginate_reservation.page_size = vm.configUserDefault.page_size;
            vm.paginate_reservation.selected = vm.configUserDefault.page;
            vm.paginate_reservation.page = vm.configUserDefault.page;

            if (vm.bookView === false) {
                listTurnAvailable(vm.fecha_actual, null, true);
                setDateBookFilter(vm.fecha_actual);
                setDatesText(vm.fecha_actual, null);
            } else {

                if (vm.configUserDefault.rangeDate.hoy === true) {
                    vm.changeDateCustom(0, 0, null, false);
                }

                if (vm.configUserDefault.rangeDate.week === true) {
                    vm.changeDateBlock('week', null, false);
                }

                if (vm.configUserDefault.rangeDate.lastSevenDays === true) {
                    vm.changeDateCustom(0, -7, null, false);
                }

                if (vm.configUserDefault.rangeDate.lastThirtyDays === true) {
                    vm.changeDateCustom(0, -30, null, false);
                }

                if (vm.configUserDefault.rangeDate.thisMonth === true) {
                    vm.changeDateBlock('month', null, false);
                }

                if (vm.configUserDefault.rangeDate.lastMonth === true) {
                    vm.changeDateLastMonth(null, false);
                }

                //console.log("loadConfigViewReservation " + angular.toJson(vm.configUserDefault, true));

                if ($stateParams.sort !== undefined) {
                    setOrderBookReservation($stateParams.sort, false);
                }

                vm.startDate = ($stateParams.date === undefined) ? vm.startDate : convertFechaToDate($stateParams.date);
                vm.endDate = ($stateParams.date_end === undefined || vm.endDate === undefined) ? vm.startDate : convertFechaToDate($stateParams.date_end);

                setDatesText(vm.startDate, vm.endDate);

                listTurnAvailable(vm.datesText.start_date, vm.datesText.end_date, true, function() {
                    setParamsUrlFilters();
                });

            }
        };

        //Asigna los parametros del filtro ,obtenidos por la url
        var setParamsUrlFilters = function() {
            vm.bookFilter.search_text = ($stateParams.search_text !== undefined) ? $stateParams.search_text : "";

            if ($stateParams.turns !== undefined && $stateParams.turns !== "") {

                var turnsUrl = $stateParams.turns.split(",");
                turnsUrl = BookFactory.parseTurnIdToObjectFilter(turnsUrl);

                vm.bookFilter.options.turnAll = false;

                angular.forEach(turnsUrl, function(value) {
                    BookFactory.addTurnsByFilter(value, vm.bookFilter.typeTurn, vm.turns, vm.bookFilter.options.turnAll);
                });
            }

            if ($stateParams.sources !== undefined && $stateParams.sources !== "") {
                var sourcesUrl = $stateParams.sources.split(",");
                sourcesUrl = BookFactory.parseSourceIdToObjectFilter(sourcesUrl);

                vm.bookFilter.options.sourcesAll = false;

                angular.forEach(sourcesUrl, function(value) {
                    BookFactory.addSourcesByFilter(value, vm.bookFilter.sources, vm.sources, vm.bookFilter.options.sourcesAll);
                });
            }

            if ($stateParams.zones !== undefined && $stateParams.zones !== "") {
                var zonesUrl = $stateParams.zones.split(",");
                zonesUrl = BookFactory.parseZoneIdToObjectFilter(zonesUrl);

                vm.bookFilter.options.zonesAll = false;

                angular.forEach(zonesUrl, function(value) {
                    BookFactory.addZonesByFilter(value, vm.bookFilter.zones, vm.zones, vm.bookFilter.options.zonesAll);
                });
            }
        };

        //Asigna la fecha al objeto date (calendario por defecto de busquedas)
        var setDateBookFilter = function(date) {
            vm.bookFilter.date = convertFechaToDate(date);
        };

        var updateUrl = function(date, date_end, reload) {
            if (reload === true) {
                setDateBookFilter(date);
            }

            if (vm.bookView === false) {
                $location.url("/mesas/book?date=" + date);
            } else {
                date_end = (date_end === undefined) ? convertFechaYYMMDD(vm.endDate, "es-ES", {}) : date_end;

                var url = "/mesas/book?date=" + date + "&date_end=" + date_end;
                var params_url = (vm.bookFilter.params_url === null) ? paramsFilterReservation(false) : vm.bookFilter.params_url;

                delete params_url.date_end;
                delete params_url.date;
                url = url + "&" + getAsUriParameters(params_url);

                $location.url(url);
            }
        };

        var reloadPageByUrl = function(params) {
            console.log("reloadPageByUrl", params);
            //setUrlNavigationConfig("");
            $location.url("/mesas/book?" + params);
        };

        var listTurnAvailable = function(date, date_end, reload, action) {
            action = (typeof action == "function") ? action : function() {};

            var params = {
                date: date,
                date_end: (date_end === null) ? date : date_end,
            };

            if (vm.bookView === false) {
                generatedListBook(params, action);
            } else {
                generatedListBookHistory(params, action);
            }
        };

        var generatedListBook = function(params, action) {
            var params_final = getAsUriParameters(params);

            BookDataFactory.getBook(params_final).then(
                function success(response) {
                    response = response.data;

                    vm.status = response.data.status;
                    vm.turns = response.data.shifts;
                    vm.sources = response.data.sourceTypes;
                    vm.zones = response.data.zones;

                    listHoursTurns(vm.turns, response.data);
                    action();
                },
                function error(response) {
                    console.error("listTurnAvailable ", angular.toJson(response, true));
                }
            );
        };

        var generatedListBookHistory = function(params, action) {

            params.page_size = vm.paginate_reservation.page_size;
            var params_url = (vm.bookFilter.params_url === null) ? paramsFilterReservation(false) : vm.bookFilter.params_url;

            params.page = vm.paginate_reservation.page;
            params.turns = (params_url.turns === undefined) ? "" : params_url.turns;
            params.sources = (params_url.sources === undefined) ? "" : params_url.sources;
            params.zones = (params_url.zones === undefined) ? "" : params_url.zones;
            params.nstatus = (vm.bookFilter.noStatus === undefined) ? "" : vm.bookFilter.noStatus;
            params.sort = (params_url.sort === undefined) ? "time" : params_url.sort;

            if (params_url.search_text !== undefined) {
                params.search_text = params_url.search_text;
            }

            var params_final = getAsUriParameters(params);

            BookDataFactory.getBookHistory(params_final).then(
                function success(response) {
                    response = response.data;
                    vm.turns = response.data.shifts;
                    vm.sources = response.data.sourceTypes;
                    vm.zones = response.data.zones;
                    vm.status = response.data.status;

                    listHoursTurns(vm.turns, response.data);
                    action();
                },
                function error(response) {
                    console.error("listTurnAvailable ", angular.toJson(response, true));
                }
            );
        };

        var generatedListBookPagination = function(date, date_end) {

            var params = {
                date: date,
                date_end: (date_end === null) ? date : date_end,
            };

            params.page_size = vm.paginate_reservation.page_size;
            var params_url = (vm.bookFilter.params_url === null) ? paramsFilterReservation(false) : vm.bookFilter.params_url;

            params.page = vm.paginate_reservation.page;
            params.turns = (params_url.turns === undefined) ? "" : params_url.turns;
            params.sources = (params_url.sources === undefined) ? "" : params_url.sources;
            params.zones = (params_url.zones === undefined) ? "" : params_url.zones;
            params.nstatus = (vm.bookFilter.noStatus === undefined) ? "" : vm.bookFilter.noStatus.toString();
            params.sort = (params_url.sort === undefined) ? "time" : params_url.sort;

            if (params_url.search_text !== undefined) {
                params.search_text = params_url.search_text;
            }

            var params_final = getAsUriParameters(params);

            BookDataFactory.getBookReservations(params_final).then(
                function success(response) {
                    response = response.data;
                    response.data.config = vm.configReservation;
                    listHoursTurns(vm.turns, response.data);
                },
                function error(response) {
                    console.error("listTurnAvailable ", angular.toJson(response, true));
                }
            );
        };

        var listHoursTurns = function(turns, data) {
            reservationService.getHours(turns).then(
                function success(response) {
                    vm.hoursTurns = response.hours;
                    vm.configReservation = data.config;

                    var listBook = [];

                    if (vm.bookView === true) {
                        listBook = BookFactory.listBookReservation(data.reservations);
                        vm.listBookReserva = listBook;
                    } else {
                        listBook = BookFactory.listBook(vm.hoursTurns, vm.bookView, data.reservations, data.blocks, data.availabilityTables);
                        vm.listBook = listBook;
                        vm.listBookMaster = listBook;
                    }

                    vm.resumenBook.reservations = data.stadistics.TOTAL;
                    vm.resumenBook.pax = data.stadistics.PAX;
                    vm.resumenBook.ingresos = data.stadistics.PAX_INGRESO;
                    vm.resumenBook.conversion = data.stadistics.CONVERSION;
                    vm.mds = data.stadistics.MESAS_OCUPADAS + " / " + data.stadistics.MESAS_RESERVADAS;

                    vm.paginate_reservation.total_pages = data.reservations.last_page * vm.paginate_reservation.page_size;

                    BookFactory.setConfigReservation(vm.configReservation);
                    vm.fecha_actual = moment().format('YYYY-MM-DD');
                },
                function error(response) {
                    console.error("getHours " + angular.toJson(response, true));
                }
            );
        };

        var updateReservationBook = function(data) {
            reservationService.blackList.key(data);
            reservationService.patchReservation(data).then(
                function success(response) {
                    console.log("updateReservationBook " + angular.toJson(response.data, true));
                },
                function error(response) {
                    console.error("updateReservationBook " + angular.toJson(response.data, true));
                }
            );
        };

        var listStatusReservation = function() {
            reservationService.getStatuses().then(
                function success(response) {
                    vm.statusReservation = response.data.data;
                },
                function error(response) {
                    console.log("listStatusReservation " + angular.toJson(response.data, true));
                }
            );
        };

        var addNewReservation = function(reservation, action) {

            var date_calendar = convertFechaYYMMDD(vm.bookFilter.date, "es-ES", {});

            var dates = {
                start_date: (vm.bookView === true) ? $stateParams.date : date_calendar,
                end_date: (vm.bookView === true) ? $stateParams.date_end : date_calendar
            };

            reservation = (Array.isArray(reservation) === true) ? reservation[0] : reservation;

            var response = BookFactory.addNewReservation(dates, vm.hoursTurns, vm.listBook, vm.listBookMaster, reservation, action);

            return response;
        };

        init();

    })
    .controller("ModalBookReservationCtrl", function($rootScope, $state, $uibModalInstance, $q, reservationService, reservationHelper, $timeout, data, date, FloorFactory, global, $table) {

        var vm = this;
        var auxiliar;

        vm.reservation = {};
        vm.reservation.status_id = 1;
        vm.reservation.tables = [];
        vm.addGuest = true;
        vm.buttonText = 'Agregar a lista de espera';
        vm.title = "Nueva entrada";
        vm.covers = [];
        vm.guestList = [];

        var tables, blocks;

        date = date ? moment(date).format("YYYY-MM-DD") : moment().format("YYYY-MM-DD");

        var listGuest = function() {
            var deferred = $q.defer();
            reservationService.getGuest()
                .then(function(guests) {
                    vm.covers = guests;
                    vm.reservation.covers = 2;
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    deferred.resolve();
                });

            return deferred.promise;
        };

        var loadZones = function() {
            var deferred = $q.defer();
            reservationService.getZones(date, true)
                .then(function(response) {
                    deferred.resolve(response.data.data);
                }).catch(function(error) {
                    message.apiError(error);
                });

            return deferred.promise;
        };

        var loadBlocks = function() {
            var deferred = $q.defer();

            reservationService.getBlocks(date, true)
                .then(function(response) {
                    blocks = response.data.data;
                    deferred.resolve(response.data.data);
                }).catch(function(error) {
                    message.apiError(error);
                });

            return deferred.promise;
        };

        //Search guest list
        vm.searchGuest = function(name) {
            if (auxiliar) $timeout.cancel(auxiliar);
            if (!name) {
                vm.guestList.length = 0;
                return;
            }
            var search = function() {
                reservationService.getGuestList(name)
                    .then(function(response) {
                        vm.guestList = response.data.data.data;
                    }).catch(function(error) {
                        message.apiError(error);
                    });
            };

            auxiliar = $timeout(search, 500);
        };

        vm.selectGuest = function(guest) {
            vm.reservation.guest_id = guest.id;
            vm.guest = guest;
            vm.addGuest = false;
        };

        vm.removeGuest = function() {
            vm.reservation.guest_id = null;
            vm.newGuest = null;
            vm.guestList = [];
            vm.addGuest = true;
        };
        //End Search

        vm.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        vm.save = function() {
            if (!vm.reservation.guest_id) {
                if (vm.newGuest) {
                    delete vm.reservation.guest_id;
                    vm.reservation.guest = vm.newGuest;
                }
            } else {
                delete vm.reservation.guest;
            }

            if (vm.reservation.tables.length === 0) {
                return vm.redirectReservation();
            }

            vm.reservation.date = date;
            vm.reservation.hour = data.time;

            vm.reservation.guest = vm.newGuest;
            vm.buttonText = 'Enviando ...';

            save();
        };

        var save = function() {
            vm.waitingResponse = true;
            reservationService.blackList.key(vm.reservation);

            console.log("save", angular.toJson(vm.reservation, true));
            vm.error = {};
            
            reservationService.save(vm.reservation).then(
                function success(response) {
                    $rootScope.$broadcast("addReservationList", response.data.data);
                    vm.waitingResponse = false;
                    message.success(response.data.msg);
                    $uibModalInstance.dismiss('cancel');
                },
                function error(error) {
                    vm.waitingResponse = false;
                    vm.error = error.data;
                    console.log("vm.error : ",vm.error);
                    message.apiError(error);
                });
        };

        var listResource = function() {
            return $q.all([
                loadZones(),
                loadBlocks(),
                listGuest()
            ]).then(function(data) {
                tables = reservationHelper.loadTable(data[0]).tables;
                parseInfo();
            });
        };

        var parseInfo = function() {
            vm.info = {
                date: moment(date).format("dddd, MM/DD"),
                time: data.time_text,
            };
            vm.suggestTables();
        };

        vm.suggestTables = function() {
            var table = $table.tablesSuggestedDinamyc(tables, blocks, vm.reservation.covers, data.time);
            vm.reservation.duration = $table.duration(vm.reservation.covers);
            if (table) {
                vm.reservation.tables = [table.id];
                vm.info.table = true;
            } else {
                vm.reservation.tables = null;
                vm.info.table = false;
            }

            vm.info.tableName = table ? "MESA " + table.name : "No hay mesas para " + vm.reservation.covers;
        };

        vm.redirectReservation = function() {
            $uibModalInstance.dismiss('cancel');

            $state.go("mesas.book-reservation-add-params", {
                date: date,
                tables: [{
                    id: (vm.reservation.tables !== null) ? vm.reservation.tables[0] : null
                }],
                hour: data.time,
                guest: vm.reservation.covers
            });
        };

        var init = function() {
            listResource();
        };

        init();
    })
    .controller("ModalCheckGuestListBookCtrl", ["$uibModalInstance", "$q", "reservationService", "reservation", "configuration", function($uibModalInstance, $q, reservationService, reservation, configuration) {

        var vm = this;
        vm.guestListAdd = [];
        vm.person = {
            man: {
                quantity: 0,
                auxiliar: 0,
                min: 0
            },
            woman: {
                quantity: 0,
                auxiliar: 0,
                min: 0
            },
            children: {
                quantity: 0,
                auxiliar: 0,
                min: 0
            },
            total: 0
        };

        var person = {
            man: 1,
            woman: 2,
            children: 3
        };

        vm.changeArrived = function(item) {
            if (!item.arrived) item.type_person = null;
            vm.countPerson();
        };

        vm.addGuest = function() {
            var guest = {
                name: vm.newGuest,
                arrived: 0,
                type_person: null
            };
            vm.guestListAdd.push(guest);
            vm.newGuest = null;
        };

        vm.countPerson = function(item, key) {
            vm.person.man.quantity = 0;
            vm.person.woman.quantity = 0;
            vm.person.children.quantity = 0;
            vm.person.man.auxiliar = vm.person.man.min;
            vm.person.woman.auxiliar = vm.person.woman.min;
            vm.person.children.auxiliar = vm.person.children.min;
            vm.person.total = 0;
            angular.forEach(vm.guestList, function(item) {
                if (!item.status) return;
                if (item.type_person === 1) {
                    vm.person.man.quantity++;
                    if (vm.person.man.quantity > vm.person.man.min) {
                        vm.person.man.auxiliar = vm.person.man.quantity;
                    }
                } else if (item.type_person === 2) {
                    vm.person.woman.quantity++;
                    if (vm.person.woman.quantity > vm.person.woman.min) {
                        vm.person.woman.auxiliar = vm.person.woman.quantity;
                    }
                } else if (item.type_person === 3) {
                    vm.person.children.quantity++;
                    if (vm.person.children.quantity > vm.person.children.min) {
                        vm.person.children.auxiliar = vm.person.children.quantity;
                    }
                }

                vm.person.total += item.arrived;
            });

            angular.forEach(vm.guestListAdd, function(item) {
                if (item.type_person === 1) {
                    vm.person.man.quantity++;
                    if (vm.person.man.quantity > vm.person.man.min) {
                        vm.person.man.auxiliar = vm.person.man.quantity;
                    }
                } else if (item.type_person === 2) {
                    vm.person.woman.quantity++;
                    if (vm.person.woman.quantity > vm.person.woman.min) {
                        vm.person.woman.auxiliar = vm.person.woman.quantity;
                    }
                } else if (item.type_person === 3) {
                    vm.person.children.quantity++;
                    if (vm.person.children.quantity > vm.person.children.min) {
                        vm.person.children.auxiliar = vm.person.children.quantity;
                    }
                }

                vm.person.total += item.arrived;
            });
        };

        vm.changePerson = function(item, key) {
            var auxiliar = item[key];

            item.man = 0;
            item.woman = 0;
            item.children = 0;
            item[key] = auxiliar;

            if (item[key] === 0) {
                item.type_person = null;
                item.arrived = 0;
            } else {
                item.type_person = person[key];
                item.arrived = 1;
            }

            vm.countPerson();
        };

        var initList = function() {
            angular.forEach(vm.guestList, function(item) {
                if (item.type_person === 1) {
                    item.man = 1;
                } else if (item.type_person === 2) {
                    item.woman = 1;
                } else if (item.type_person === 3) {
                    item.children = 1;
                }
            });

            angular.forEach(vm.guestListAdd, function(item) {
                if (item.type_person === 1) {
                    item.man = 1;
                } else if (item.type_person === 2) {
                    item.woman = 1;
                } else if (item.type_person === 3) {
                    item.children = 1;
                }
            });

            vm.countPerson();
        };

        vm.removeGuestListAdd = function(i) {
            vm.guestListAdd.splice(i, 1);
            vm.countPerson();
        };

        vm.removeGuestList = function(item) {
            item.status = 0;
            item.arrived = 0;
            item.type_person = null;
            vm.countPerson();
        };

        vm.save = function() {
            vm.waitingResponse = true;
            reservationService.guestList(reservation.id, {
                guest_list: vm.guestList,
                guest_list_add: vm.guestListAdd
            }).then(
                function success(response) {
                    angular.forEach(response.data.data, function(value, key) {
                        reservation[key] = value;
                    });
                    message.success("Se actualizo lista de invitados");
                    vm.waitingResponse = false;
                    vm.cancel();
                },
                function error(error) {
                    message.apiError(error);
                    vm.waitingResponse = false;
                });
        };

        vm.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        var initModule = function() {
            vm.configPeople = configuration.status_people_1 + configuration.status_people_2 + configuration.status_people_3;
            vm.configuration = configuration;
            vm.person.man.min = reservation.num_people_1 * 1;
            vm.person.woman.min = reservation.num_people_2 * 1;
            vm.person.children.min = reservation.num_people_3 * 1;

            vm.guestList = angular.copy(reservation.guest_list);
            initList();
        };

        (function init() {
            initModule();
        })();
    }]);
angular.module('book.directive', [])
    .directive('ngEnter', [function() {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                element.bind("keydown keypress", function(event) {
                    if (event.which === 13) {
                        scope.$apply(function() {
                            scope.$eval(attrs.ngEnter);
                        });
                        event.preventDefault();
                    }
                });
            }
        };
    }]);
angular.module('book.filter', [])
    .filter('blocksFilter', function(BookFactory) {
        return function(books, blocksView, bookView) {
            var listBook = [];
            if (blocksView === false && bookView === false) {
                angular.forEach(books, function(book, key) {
                    if (book.block === null) {
                        listBook.push(book);
                    }
                });
            } else {
                listBook = books;
            }

            if (bookView === false) {
                BookFactory.getResumenBook(listBook);
            }

            return listBook;
        };
    })
    .filter('turnsFilter', function(BookFactory) {
        return function(books, turns, bookView) {
            var listBook = [];

            if (turns.length > 0 && bookView === false) {

                angular.forEach(books, function(book, key) {
                    //console.log(book);
                    if (turns.indexOf(book.turn_id) != -1) {
                        listBook.push(book);
                    }
                });
            } else {
                listBook = books;
            }

            if (bookView === false) {
                BookFactory.getResumenBook(listBook);
            }

            return listBook;
        };
    })
    .filter('numGuestFilter', function(BookFactory) {
        return function(books, numGuest, bookView) {
            var listBook = [];

            if (bookView === false) {
                angular.forEach(books, function(book, key) {
                    if (book.tables.length > 0) {
                        var numGuestsValidate = 0;

                        angular.forEach(book.tables, function(table, key) {
                            if (numGuest.id >= table.min_cover && numGuest.id <= table.max_cover || numGuest.id === 0) {
                                numGuestsValidate += 1;
                            }
                        });

                        books[key].available = (numGuestsValidate > 0) ? true : false;
                    }
                });
                listBook = books;
            } else {
                listBook = books;
            }

            // BookFactory.getResumenBook(listBook);

            return listBook;
        };
    })
    .filter('noStatusFilter', function(BookFactory) {
        return function(books, noStatus, bookView) {
            var listBook = [];
            if (noStatus.length > 0 && bookView === false) {
                angular.forEach(books, function(book, key) {
                    if (book.reservation !== null) {
                        if ((noStatus.indexOf(book.reservation.status.id) == -1)) {
                            listBook.push(book);
                        }
                    } else {
                        listBook.push(book);
                    }
                });
            } else {
                listBook = books;
            }

            if (bookView === false) {
                BookFactory.getResumenBook(listBook);
            }

            return listBook;
        };
    })
    .filter('sourcesFilter', function(BookFactory) {
        return function(books, sources, bookView) {
            var listBook = [];

            if (sources.length > 0 && bookView === false) {
                angular.forEach(books, function(book, key) {
                    if (book.reservation !== null) {
                        if (sources.indexOf(book.reservation.source.id) != -1) {
                            listBook.push(book);
                        }
                    }
                });
            } else {
                listBook = books;
            }

            if (bookView === false) {
                BookFactory.getResumenBook(listBook);
            }

            return listBook;
        };
    })
    .filter('zonesFilter', function(BookFactory) {
        return function(books, zones, bookView) {
            var listBook = [];

            if (zones.length > 0 && bookView === false) {
                angular.forEach(books, function(book, key) {
                    if (book.reservation !== null) {
                        var existsTableZone = BookFactory.existsTablesByZone(book.reservation.tables, zones);
                        if (existsTableZone === true) {
                            listBook.push(book);
                        }
                    }
                });
            } else {
                listBook = books;
            }

            if (bookView === false) {
                BookFactory.getResumenBook(listBook);
            }

            return listBook;
        };
    });
angular.module("book.controller")

.controller('BookNotificationCtrl', function($scope, ServerNotification) {

    var serverSocket = ServerNotification.getConnection();

    serverSocket.on("b-mesas-floor-res", function(data) {
        $scope.$broadcast("NotifyNewReservation", data);
    });

    serverSocket.on("b-mesas-floor-notes", function(data) {
        $scope.$broadcast("floorNotesReload", data);
    });

    serverSocket.on("b-mesas-config-update", function(data) {
        $scope.$broadcast("NotifyBookConfigReload", data.user_msg);
    });

});
angular.module('book.service', [])
    .factory('BookDataFactory', function($http, ApiUrlMesas, FloorDataFactory, FloorFactory, CalendarService) {
        var typeTurns, sources, zones;
        return {
            getTypeTurns: function(date, reload) {
                typeTurns = FloorFactory.listTurnosActivos(date, reload);
                return typeTurns;
            },
            getSources: function(reload) {
                sources = FloorDataFactory.getSourceTypes(reload);
                return sources;
            },
            getZones: function(params) {
                zones = CalendarService.GetZones(params.date_ini, params.date_end, params.reload);
                return zones;
            },
            getBook: function(params) {
                return $http.get(ApiUrlMesas + "/web-app/book?" + params);
            },
            getBookReservations: function(params) {
                return $http.get(ApiUrlMesas + "/web-app/book/history/reservations?" + params);
            },
            getBookHistory: function(params) {
                return $http.get(ApiUrlMesas + "/web-app/book/history?" + params);
            }
        };
    })
    .factory('TablesDataFactory', function($http, ApiUrlMesas) {
        return {
            getAvailability: function(params) {
                return $http.get(ApiUrlMesas + "/tables/availability?" + params);
            }
        };
    })
    .factory('BookFactory', function($q, reservationService, CalendarService, BlockFactory, BookResumenFactory,
        ConfigurationDataService, TablesDataFactory) {
        var scopeMain = null;
        var configReservation = null;
        return {
            //Genera el book en base a las horas (disponibles de los turnos)
            listBook: function(hours, bookView, reservations, blocks, tablesAvailability) {
                var self = this;
                var book = [];

                var reservation = {
                    data: null,
                    hour_ini: null,
                    hour_end: null,
                    hour_duration: null
                };

                hours = (bookView === false) ? hours : self.generatedHoursAll();

                angular.forEach(hours, function(hour, key) {
                    var existsReservation = self.existsReservation(hour, reservations, bookView);
                    var existsBlocks = self.existsBlocks(hour, blocks);

                    var dataBook = {
                        time: hour.time,
                        index: hour.index,
                        time_text: hour.name,
                        turn_id: hour.turn_id,
                        block: null,
                        reservation: null,
                        available: false,
                        tables: []
                    };

                    if (existsBlocks.exists === false && existsReservation.exists === false) {
                        book.push(dataBook);
                    } else {

                        angular.forEach(existsBlocks.data, function(block, key) {
                            book.push({
                                time: hour.time,
                                index: hour.index,
                                time_text: hour.name,
                                turn_id: hour.turn_id,
                                block: block,
                                reservation: null,
                                available: false,
                                tables: []
                            });
                        });

                        if (existsBlocks.exists === true || existsReservation.exists === true) {
                            book.push(dataBook);
                        }

                        angular.forEach(existsReservation.data, function(reservation, key) {
                            var hoursTest = moment(reservation.date_reservation + ' ' + reservation.hours_reservation);
                            book.push({
                                time: hour.time,
                                index: hour.index,
                                time_text: hoursTest.format("hh:mm A"),
                                date_text: hoursTest.format("L"),
                                turn_id: hour.turn_id,
                                block: null,
                                reservation: reservation,
                                available: false,
                                tables: []
                            });
                        });
                    }
                });

                //actualizar tablesAvailables con las reservaciones
                self.durationsReservaAvailableBook(reservations, tablesAvailability, bookView);
                //Asignamos las mesas disponibles a la hora
                angular.forEach(book, function(value, key) {
                    if (value.block === null && value.reservation === null) {
                        value = self.assignTablesAvailabilityBook(value, tablesAvailability, reservations, bookView);
                    }
                });
                //console.log("books " + angular.toJson(tablesAvailability, true));
                //book = self.assignAvailabilityTable(book, reservations, bookView);
                //console.log("books " + angular.toJson(book, true));
                return book;
            },
            listBookReservation: function(reservations) {
                var book = [];
                var self = this;

                reservations = self.parseReservations(reservations, true);
                angular.forEach(reservations, function(reserva, key) {
                    var hoursTest = moment(reserva.date_reservation + ' ' + reserva.hours_reservation);
                    book.push({
                        time: reserva.hours_reservation,
                        time_text: hoursTest.format("hh:mm A"),
                        date_text: hoursTest.format("L"),
                        turn_id: 0,
                        block: null,
                        reservation: reserva,
                        available: false,
                        tables: []
                    });
                });

                return book;
            },
            //Asignamos disponibilidad si hay reservas,analizamos el tiempo de duración
            durationsReservaAvailableBook: function(reservations, tablesAvailability, bookView) {
                var self = this;

                angular.forEach(tablesAvailability, function(table, key) {
                    var exists = self.existsTableReservaInBook(reservations, table.id, bookView);
                    if (exists.exists === true) {
                        self.updateTablesAvailability(table.id, tablesAvailability[key], exists.data);
                        // console.log("la mesa esta reservada " + table.id);
                    }
                });
            },
            //Actualiza la lista de Mesas - Disponibilidad  si tiene reservacion
            updateTablesAvailability: function(tableId, table, reservations) {
                angular.forEach(reservations, function(reservation, key) {
                    if (tableId === table.id) {
                        var date_res = moment(reservation.date_reservation);

                        var hour_ini = moment(reservation.datetime_input).format("HH:mm:ss");
                        var hour_end = moment(reservation.datetime_output).format("HH:mm:ss");
                        var indexHourIni = getIndexHour(hour_ini, 0);
                        var indexHourEnd = getIndexHour(hour_end, 0);

                        var date_ini = moment(reservation.datetime_input).format("YYYY-MM-DD");
                        var date_end = moment(reservation.datetime_output).format("YYYY-MM-DD");

                        if (moment(reservation.date_reservation).isBefore(date_ini)) {
                            indexHourIni += 96;
                        }
                        if (moment(reservation.date_reservation).isBefore(date_end)) {
                            indexHourEnd += 96;
                        }

                        var indexHour = getIndexHour(reservation.hours_reservation, 0);
                        for (var i = indexHourIni; i <= indexHourEnd; i++) {

                            table.availability[i].reserva = true;
                        }
                    }
                });
            },
            //Devuelve las reservaciones, modo reserva tiene otra esctructura de datos (solo contenedor)
            parseReservations: function(reservations, bookView) {
                var existPaginator = angular.toJson(reservations, true);
                reservations = (bookView === true && existPaginator.indexOf('last_page') > -1) ? reservations.data : reservations;

                return reservations;
            },
            //Evalua si la mesa existe en la reserva del book
            existsTableReservaInBook: function(reservations, table, bookView) {
                var self = this;
                var exists = {
                    data: [],
                    exists: false
                };

                reservations = self.parseReservations(reservations, bookView);

                angular.forEach(reservations, function(reservation, key) {
                    angular.forEach(reservation.tables, function(value, key) {
                        if (table === value.id) {
                            exists.exists = true;
                            exists.data.push(reservation);
                        }
                    });
                });

                return exists;
            },
            //Asignamos las mesas con disponibilidad
            assignTablesAvailabilityBook: function(book, tables, reservations, bookView) {
                var self = this;
                angular.forEach(tables, function(table, key) {

                    if (table.availability[book.index].time == book.time) {

                        if (table.availability[book.index].rule_id > 0 && table.availability[book.index].reserva === false) {

                            book.tables.push({
                                id: table.id,
                                res_zone_id: table.res_zone_id,
                                min_cover: table.min_cover,
                                max_cover: table.max_cover,
                                name: table.name
                            });

                            return;
                        }
                    }
                });

                book.available = (book.tables.length > 0) ? true : false;

                return book;
            },
            //Filtramos solo las reservaciones y bloqueos del book
            filterReservationsAndBlocks: function(listBook, bookView) {
                var data = {
                    reservations: [],
                    blocks: [],
                    availables: []
                };

                angular.forEach(listBook, function(book) {
                    if (book.reservation === null && book.block === null) {
                        data.availables.push(book);
                    } else {

                        if (book.reservation !== null) {
                            book.reservation.table_filter = (book.reservation.tables.length > 0) ? book.reservation.tables[0].name : "";
                            book.reservation.guest_filter = (book.reservation.guest !== null) ? book.reservation.guest.first_name + " " + book.reservation.guest.last_name : "";
                        }

                        if (bookView === false) {
                            data.reservations.push(book);
                        } else {
                            if (book.block === null) {
                                data.reservations.push(book);
                            }
                        }


                    }
                });

                return data;
            },
            existsBlocks: function(hour, blocks) {
                var exists = {
                    exists: false,
                    data: []
                };

                angular.forEach(blocks, function(block, key) {
                    if (block.start_time == hour.time) {
                        exists.exists = true;
                        exists.data.push(block);
                    }
                });

                return exists;
            },
            existsReservation: function(hour, reservations, bookView) {
                var self = this;
                var exists = {
                    exists: false,
                    data: []
                };

                reservations = self.parseReservations(reservations, bookView);

                angular.forEach(reservations, function(reservation, key) {
                    if (hour.time === reservation.hours_reservation) {
                        exists.exists = true;
                        exists.data.push(reservation);
                    }
                });

                return exists;
            },
            //Habilita en la vista los types turns que hallamos marcados
            setCheckedTypeTurn: function(turns, turnId, checked) {
                angular.forEach(turns, function(turn, key) {
                    if (turn.turn !== null) {
                        if (turn.turn.id == turnId) {
                            turn.checked = checked;
                        }
                    }
                });
            },
            //Habilita en la vista los sources que hallamos marcados
            setCheckedSource: function(sources, sourceId, checked) {
                angular.forEach(sources, function(source, key) {
                    if (source.id == sourceId) {
                        source.checked = checked;
                    }
                });
            },
            //Habilita en la vista las zonas que hallamos marcados
            setCheckedZone: function(zones, zoneId, checked) {
                angular.forEach(zones, function(zone, key) {
                    if (zone.id == zoneId) {
                        zone.checked = checked;
                    }
                });
            },
            //Agrega los turnos (id) a la lista de marcados
            addTurnsByFilter: function(typeTurn, filterTypeTurns, turns, turnAll) {
                var self = this;
                if (typeTurn !== "all") {
                    if (filterTypeTurns.length > 0) {
                        var index = filterTypeTurns.indexOf(typeTurn.turn.id);
                        if (index == -1) {
                            filterTypeTurns.push(typeTurn.turn.id);
                            self.setCheckedTypeTurn(turns, typeTurn.turn.id, true);
                        } else {
                            filterTypeTurns.splice(index, 1);
                            self.setCheckedTypeTurn(turns, typeTurn.turn.id, false);
                        }

                    } else {
                        filterTypeTurns.push(typeTurn.turn.id);
                        self.setCheckedTypeTurn(turns, typeTurn.turn.id, true);
                    }
                } else {

                    filterTypeTurns.length = 0;

                    angular.forEach(turns, function(turn, key) {
                        if (turn.turn !== null) {

                            if (turnAll === false) {
                                self.setCheckedTypeTurn(turns, turn.turn.id, false);
                            } else {
                                filterTypeTurns.push(turn.turn.id);
                                self.setCheckedTypeTurn(turns, turn.turn.id, true);
                            }
                        }
                    });
                }
            },
            addNoStatusByFilter: function(state, filterStatus, statusList, showStatus) {
                var self = this;
                if (statusList.length > 0) {
                    var index = filterStatus.indexOf(state.id);
                    if (index == -1 && showStatus === false) {
                        filterStatus.push(state.id);
                    } else if (showStatus === true) {
                        filterStatus.splice(index, 1);
                    }
                }
            },
            //Agrega los sources (id) a la lista de marcados
            addSourcesByFilter: function(source, filterSources, sources, sourceAll) {
                var self = this;
                if (source !== "all") {
                    if (filterSources.length > 0) {
                        var index = filterSources.indexOf(source.id);
                        if (index == -1) {
                            filterSources.push(source.id);
                            self.setCheckedSource(sources, source.id, true);
                        } else {
                            filterSources.splice(index, 1);
                            self.setCheckedSource(sources, source.id, false);
                        }
                    } else {
                        filterSources.push(source.id);
                        self.setCheckedSource(sources, source.id, true);
                    }
                } else {
                    filterSources.length = 0;

                    angular.forEach(sources, function(value, key) {
                        if (sourceAll === false) {
                            self.setCheckedSource(sources, value.id, false);
                        } else {
                            filterSources.push(value.id);
                            self.setCheckedSource(sources, value.id, true);
                        }
                    });
                }
            },
            //Agrega las zones (id) a la lista de marcados
            addZonesByFilter: function(zone, filterZones, zones, zonesAll) {
                var self = this;

                if (zone !== "all") {
                    if (filterZones.length > 0) {
                        var index = filterZones.indexOf(zone.id);

                        if (index == -1) {
                            filterZones.push(zone.id);
                            self.setCheckedZone(zones, zone.id, true);
                        } else {
                            filterZones.splice(index, 1);
                            self.setCheckedZone(zones, zone.id, false);
                        }

                    } else {
                        filterZones.push(zone.id);
                        self.setCheckedZone(zones, zone.id, true);
                    }
                } else {
                    filterZones.length = 0;

                    angular.forEach(zones, function(value, key) {
                        if (zonesAll === false) {
                            self.setCheckedZone(zones, value.id, false);
                        } else {
                            filterZones.push(value.id);
                            self.setCheckedZone(zones, value.id, true);
                        }
                    });
                }
            },
            //Ver si alguna mesa pertenece a la zona
            existsTablesByZone: function(tables, zones) {
                var exists = false;

                angular.forEach(tables, function(table, key) {
                    if (zones.indexOf(table.res_zone_id) != -1) {
                        exists = true;
                    }
                });

                return exists;
            },
            //Calcula el resumen del book, n° reservaciones,invitados,ingresados,etc
            getResumenBook: function(listBook, config) {
                config = (config !== undefined && config !== null) ? config : configReservation;
                var resumen = BookResumenFactory.calculate(listBook, config);
                scopeMain.$broadcast('resumenBookUpdate', resumen);
            },
            setConfigReservation: function(config) {
                configReservation = config;
                return configReservation;
            },
            //Calcula total de mesas disponibles sobre las mesas ocupadas
            calculateMDS: function(listBook, zones) {

                var totalTables = BookResumenFactory.getTablesZones(zones);
                var totalResSit = BookResumenFactory.getTablesSitRes(listBook);

                var mds = totalResSit + "/" + totalTables;

                return mds;
            },
            //Devuelve el objeto status dentro de un array segun su id
            getStatusById: function(idStatus, statusData) {
                var status = {};
                angular.forEach(statusData, function(value, key) {
                    if (value.id === idStatus) {
                        status = value;
                    }
                });
                return status;
            },
            //Agrega la reservación que llego de la notificación,segun fecha del book
            addNewReservation: function(dates, hours, listBook, listBookMaster, reservation, action) {
                var add = false;
                var self = this;

                if (moment(reservation.date_reservation).isSameOrBefore(dates.end_date) &&
                    moment(reservation.date_reservation).isSameOrAfter(dates.start_date)) {

                    angular.forEach(hours, function(hour, key) {
                        if (reservation.hours_reservation == hour.time) {

                            scopeMain.$apply(function() {
                                self.addReservationBook(listBook, hour, reservation);
                                self.addReservationBook(listBookMaster, hour, reservation);
                                add = true;
                            });
                        }
                    });
                }

                return add;
            },
            //Agrega la reservacion al book
            addReservationBook: function(listBook, hour, reservation) {
                var valida = false;
                var self = this;

                angular.forEach(listBook, function(book, key) {
                    if (book.reservation !== null) {
                        if (book.reservation.id === reservation.id) {
                            book.reservation = reservation;
                            valida = true;
                        }
                    }
                });

                if (valida === false) {

                    var indexBook = self.getIndexHourBook(listBook, hour);

                    listBook.splice(indexBook, 0, {
                        time: hour.time,
                        time_text: hour.name,
                        turn_id: hour.turn_id,
                        block: null,
                        reservation: reservation,
                        available: false,
                        tables: []
                    });
                }
            },
            //Obtiene el indice del book segun la hora indicada
            getIndexHourBook: function(listBook, hour) {
                var index = 0;
                angular.forEach(listBook, function(book, key) {
                    if (book.time === hour.time) {
                        index = key;
                    }
                });
                return index;
            },
            deleteReservationBook: function(listBook, reservation) {
                angular.forEach(listBook, function(book, key) {
                    if (book.reservation !== null) {
                        if (book.reservation.id === reservation.id) {
                            listBook.splice(key);
                        }
                    }
                });
            },
            //Genera la horas desde 00:00:00 hasta las 24:00:00 (solo para reservaciones)
            generatedHoursAll: function() {
                var hoursBook = [];
                var hours = getRangoHours("00:00:00", "23:45:00", true);

                angular.forEach(hours, function(hour, key) {
                    hoursBook.push({
                        turn: "",
                        index: key,
                        time: hour.hour24,
                        name: hour.hour12,
                        turn_id: 0
                    });
                });

                return hoursBook;
            },
            //Obtenemos los turnos en el formato que acepta la funcion : addTurnsByFilter
            parseTurnIdToObjectFilter: function(turns) {
                var turnsData = [];

                angular.forEach(turns, function(value, key) {
                    turnsData.push({
                        turn: {
                            id: parseInt(value)
                        }
                    });
                });

                return turnsData;
            },
            //Obtenemos los colaboradores en el formato que acepta la funcion : addSourcesByFilter
            parseSourceIdToObjectFilter: function(sources) {
                var sourcesData = [];

                angular.forEach(sources, function(value, key) {
                    sourcesData.push({
                        id: parseInt(value)
                    });
                });

                return sourcesData;
            },
            //Obtenemos las zonas en el formato que acepta la funcion : addZonesByFilter
            parseZoneIdToObjectFilter: function(zones) {
                var zonesData = [];

                angular.forEach(zones, function(value, key) {
                    zonesData.push({
                        id: parseInt(value)
                    });
                });

                return zonesData;
            },
            init: function(scope) {
                scopeMain = scope;
            }
        };
    })
    .factory('BookConfigFactory', function($stateParams, $location) {

        var _BCONF = self;

        _BCONF.localStorageName = 'mesas.book.config';
        _BCONF.configBook = {
            reservationView: false,
            rangeDate: {
                hoy: true,
                week: false, //esta semana
                lastSevenDays: false, //ultimos 7 dias
                lastThirtyDays: false, //ultimos 30 dias
                thisMonth: false, //este mes
                lastMonth: false, //mes pasado
                range: false //rango de fechas
            },
            url: null,
            filters: {
                turns: [],
                status: [],
                sources: [],
                zones: [],
                date: moment().format('YYYY-MM-DD'),
                date_end: moment().format('YYYY-MM-DD'),
            },
            sort: 'time.asc',
            page_size: 30,
            page: 1,
            show: {
                released: true,
                canceled: true,
                blocks: true,
            },
            fields: {
                consume: true,
                messages: true,
                listguests: true,
                source: true
            }
        };

        _BCONF.setConfigBook = function(config) {

            if (config !== undefined) {
                _BCONF.configBook.reservationView = (_BCONF.configBook.reservationView !== undefined) ? config.reservationView : false;
                if (config.rangeDate !== undefined) {
                    _BCONF.configBook.rangeDate.hoy = (_BCONF.configBook.rangeDate.hoy !== undefined) ? config.rangeDate.hoy : false;
                    _BCONF.configBook.rangeDate.week = (_BCONF.configBook.rangeDate.week !== undefined) ? config.rangeDate.week : false;
                    _BCONF.configBook.rangeDate.lastSevenDays = (_BCONF.configBook.rangeDate.lastSevenDays !== undefined) ? config.rangeDate.lastSevenDays : false;
                    _BCONF.configBook.rangeDate.lastThirtyDays = (_BCONF.configBook.rangeDate.lastThirtyDays !== undefined) ? config.rangeDate.lastThirtyDays : false;
                    _BCONF.configBook.rangeDate.thisMonth = (_BCONF.configBook.rangeDate.thisMonth !== undefined) ? config.rangeDate.thisMonth : false;
                    _BCONF.configBook.rangeDate.lastMonth = (_BCONF.configBook.rangeDate.lastMonth !== undefined) ? config.rangeDate.lastMonth : false;
                    _BCONF.configBook.rangeDate.range = (_BCONF.configBook.rangeDate.range !== undefined) ? config.rangeDate.range : false;
                }
                if (config.show !== undefined) {
                    _BCONF.configBook.show.released = (_BCONF.configBook.show.released !== undefined) ? config.show.released : true;
                    _BCONF.configBook.show.canceled = (_BCONF.configBook.show.canceled !== undefined) ? config.show.canceled : true;
                    _BCONF.configBook.show.blocks = (_BCONF.configBook.show.blocks !== undefined) ? config.show.blocks : true;
                }

                if (config.fields !== undefined) {
                    _BCONF.configBook.fields.consume = (_BCONF.configBook.fields.consume !== undefined) ? config.fields.consume : true;
                    _BCONF.configBook.fields.messages = (_BCONF.configBook.fields.messages !== undefined) ? config.fields.messages : true;
                    _BCONF.configBook.fields.listguests = (_BCONF.configBook.fields.listguests !== undefined) ? config.fields.listguests : true;
                    _BCONF.configBook.fields.source = (_BCONF.configBook.fields.source !== undefined) ? config.fields.source : true;
                }
                if (config.filters !== undefined) {
                    _BCONF.configBook.filters.turns = (_BCONF.configBook.filters.turns !== undefined) ? config.filters.turns : [];
                    _BCONF.configBook.filters.status = (_BCONF.configBook.filters.status !== undefined) ? config.filters.status : [];
                    _BCONF.configBook.filters.sources = (_BCONF.configBook.filters.sources !== undefined) ? config.filters.sources : [];
                    _BCONF.configBook.filters.zones = (_BCONF.configBook.filters.zones !== undefined) ? config.filters.zones : [];
                    _BCONF.configBook.filters.date = (_BCONF.configBook.filters.date !== undefined) ? config.filters.date : moment().format('YYYY-MM-DD');
                    _BCONF.configBook.filters.date_end = (_BCONF.configBook.filters.date_end !== undefined) ? config.filters.date_end : moment().format('YYYY-MM-DD');
                }

                _BCONF.configBook.url = (_BCONF.configBook.url !== undefined) ? config.url : null;
                _BCONF.configBook.order = (_BCONF.configBook.order !== undefined) ? config.order : 'time.asc';
                _BCONF.configBook.page_size = (_BCONF.configBook.page_size !== undefined) ? config.page_size : 30;
                _BCONF.configBook.page = (_BCONF.configBook.page !== undefined) ? config.page : 30;
            }
            return _BCONF.configBook;
        };

        _BCONF.initUrlParamsByStorage = function() {

            _BCONF.configBook.url = {};
            _BCONF.configBook.url.date = moment().format("YYYY-MM-DD");
            if (_BCONF.configBook.filters.date !== "") {
                _BCONF.configBook.url.date = _BCONF.configBook.filters.date;
            }
            if (_BCONF.configBook.filters.date_end !== "" && _BCONF.configBook.reservationView) {
                _BCONF.configBook.url.date_end = _BCONF.configBook.filters.date_end;
            }
            if (_BCONF.configBook.filters.status.length > 0) {
                _BCONF.configBook.url.status = _BCONF.configBook.filters.status.toString();
            }
            if (_BCONF.configBook.filters.turns.length > 0) {
                _BCONF.configBook.url.turns = _BCONF.configBook.filters.turns.toString();
            }
            if (_BCONF.configBook.filters.sources.length > 0) {
                _BCONF.configBook.url.sources = _BCONF.configBook.filters.sources.toString();
            }
            if (_BCONF.configBook.page_size != 30) {
                _BCONF.configBook.url.page_size = _BCONF.configBook.page_size;
            }
            if (_BCONF.configBook.page > 1) {
                _BCONF.configBook.url.page = _BCONF.configBook.page;
            }
            if (_BCONF.configBook.sort !== "") {
                _BCONF.configBook.url.sort = _BCONF.configBook.sort;
            }
        };

        _BCONF.saveUrlParams = function() {
            _BCONF.configBook.url = {};
            _BCONF.configBook.url.date = moment().format("YYYY-MM-DD");
            //console.log('_BCONF.configBook: ', _BCONF.configBook);
            if ($stateParams.date !== undefined && $stateParams.date !== "") {
                _BCONF.configBook.url.date = $stateParams.date;
                _BCONF.configBook.filters.date = $stateParams.date;
            }
            if ($stateParams.date_end !== undefined && $stateParams.date_end !== "" && _BCONF.configBook.reservationView) {
                _BCONF.configBook.url.date_end = $stateParams.date_end;
                _BCONF.configBook.filters.date_end = $stateParams.date_end;
            }
            if ($stateParams.status !== undefined && $stateParams.status !== "") {
                _BCONF.configBook.url.status = $stateParams.status;
                _BCONF.configBook.filters.status = $stateParams.status.split(',');
            }
            if ($stateParams.blocks !== undefined && $stateParams.blocks !== "") {
                _BCONF.configBook.url.blocks = $stateParams.blocks;
                _BCONF.configBook.filters.blocks = $stateParams.blocks.split(',');
            }
            if ($stateParams.sources !== undefined && $stateParams.sources !== "") {
                _BCONF.configBook.url.sources = $stateParams.sources;
                _BCONF.configBook.filters.blocks = $stateParams.sources.split(',');
            }
            if ($stateParams.page_size !== undefined && $stateParams.page_size !== "") {
                _BCONF.configBook.url.page_size = $stateParams.page_size;
            }
            if ($stateParams.page !== undefined && $stateParams.page !== "") {
                _BCONF.configBook.url.page = $stateParams.page;
            }
            if ($stateParams.sort !== undefined && $stateParams.sort !== "") {
                _BCONF.configBook.url.sort = $stateParams.sort;
            }
        };

        _BCONF.replaceStateParams = function() {
            var url = $location.absUrl();
            var index = url.indexOf("?");
            url = url.substring(0, index);
            params = getAsUriParameters(_BCONF.configBook.url);
            console.log(url + "?" + params);
            history.replaceState('', 'Pagina', url + "?" + params);
        };

        /* Obtener configuracion de localstorage */
        _BCONF.get = function() {
            var config = (localStorage.getItem(_BCONF.localStorageName) !== null) ? JSON.parse(localStorage.getItem(_BCONF.localStorageName)) : null;
            _BCONF.setConfigBook(config);
        };
        /* Guardar configuracion en localstorage */
        _BCONF.save = function() {
            localStorage.setItem(_BCONF.localStorageName, angular.toJson(_BCONF.configBook));
        };
        /* Remover data de locastorage localstorage */
        _BCONF.remove = function() {
            localStorage.removeItem(_BCONF.localStorageName);
        };

        return {
            setFilter: function(option, values) {
                console.log(option, values);
                switch (option) {
                    case 'turns':
                        _BCONF.configBook.filters.turns = (values !== undefined) ? values : [];
                    case 'status':
                        _BCONF.configBook.filters.status = (values != undefined) ? values : [];
                        break;
                    case 'sources':
                        _BCONF.configBook.filters.sources = (values != undefined) ? values : [];
                        break;
                    case 'zones':
                        _BCONF.configBook.filters.zones = (values != undefined) ? values : [];
                        break;
                    case 'date':
                        _BCONF.configBook.filters.date = (values != undefined) ? values : moment().format('YYYY-MM-DD');
                        break;
                    case 'date_end':
                        _BCONF.configBook.filters.date_end = (values != undefined) ? values : moment().format('YYYY-MM-DD');
                        break;
                }
            },
            save: function() {
                _BCONF.save();
            },
            setConfig: function(config) {
                _BCONF.setConfigBook(config);
                _BCONF.save();
            },
            getConfig: function() {
                _BCONF.get();
                //_BCONF.initUrlParamsByStorage();
                //_BCONF.replaceStateParams();
                return _BCONF.configBook;
            },
            clearConfig: function() {
                _BCONF.remove();
            }
        };
    })
    .factory('BookResumenFactory', function($q) {

        return {
            calculate: function(listBook, configReservations) {
                var self = this;
                var resumenBook = {
                    reservations: 0,
                    pax: 0,
                    ingresos: 0,
                    conversion: 0
                };

                var resvSit = 0;

                angular.forEach(listBook, function(book, key) {
                    if (book.reservation !== null) {
                        resumenBook.reservations += 1;
                        resumenBook.ingresos += self.calculateIngresos(book, configReservations);
                        resumenBook.pax += book.reservation.num_guest;

                        if (book.reservation.status.id == 4 || book.reservation.status.id == 5) {
                            resvSit += 1;
                        }
                    }
                });

                if (resumenBook.resvSit > 0 || resumenBook.reservations > 0) {
                    resumenBook.conversion = (resvSit / resumenBook.reservations) * 100;
                    resumenBook.conversion = resumenBook.conversion.toFixed(2);
                }

                return resumenBook;
            },
            calculateIngresos: function(book, configRes) {
                var ingresos = 0;

                if (configRes !== null) {

                    if (configRes.status_people_1 === 1) {
                        ingresos += book.reservation.num_people_1;
                    }
                    if (configRes.status_people_2 === 1) {
                        ingresos += book.reservation.num_people_2;
                    }
                    if (configRes.status_people_3 === 1) {
                        ingresos += book.reservation.num_people_3;
                    }
                }

                return ingresos;
            },
            //Obtiene el total de mesas disponibles
            getTablesZones: function(zones) {
                var total = 0;

                angular.forEach(zones, function(zone, key) {
                    angular.forEach(zone.tables, function(table, key) {
                        if (table.status == 1) {
                            total += 1;
                        }
                    });
                });

                return total;
            },
            //Obtiene el total de mesas ocupadas (reservaciones)
            getTablesSitRes: function(listBook) {
                var total = 0;

                angular.forEach(listBook, function(book, key) {
                    if (book.reservation !== null) {
                        if (book.reservation.res_reservation_status_id == 4) {
                            total += book.reservation.tables.length;
                        }
                    }
                });

                return total;
            }

        };
    });
/**
 * Created by BS on 25/08/2016.
 */

angular.module('calendar.app', ['calendar.controller', 'calendar.service'])

.config(function($stateProvider) {
    $stateProvider
        .state('mesas.calendar', {
            url: '/calendar',
            views: {
                '@': {
                    templateUrl: '/js/app/tables/calendar/view/index.html',
                    controller: 'CalendarIndexController',
                    controllerAs: 'vm'
                }

            },
            resolve: {
                $title: function() {
                    return 'Calendario';
                }
            }
        });
});
/**
 * Created by BS on 25/08/2016.
 */

angular.module('calendar.controller', [])
    .controller('CalendarIndexController', function(CalendarService, MenuConfigFactory, $uibModal, $scope, $compile) {
        var vm = this;
        var now;

        function GetEvents() {
            var month = vm.calendar.fullCalendar('getDate').format('YYYY-MM');
            vm.loading = true;
            CalendarService.GetShiftsByMonth(month, {
                OnSuccess: function(Response) {
                    vm.events = Response.data.data;
                    updateCalendar();
                    vm.loading = false;
                },
                OnError: function(Response) {
                    vm.loading = false;
                }
            });
        }

        function updateCalendar() {
            vm.calendar.fullCalendar('removeEvents');
            vm.calendar.fullCalendar('addEventSource', vm.events);
        }

        function initCalendar() {
            vm.calendar = angular.element('#calendar');

            vm.calendar.fullCalendar({
                header: {
                    right: '',
                    center: 'prev, title, next',
                    left: 'today'
                },
                buttonText: {
                    today: "Hoy"
                },
                locale: 'es',
                theme: true,
                selectable: true,
                selectHelper: true,
                events: vm.events,
                eventOrder: 'start_time',
                eventClick: function(calEvent, jsEvent, view) {
                    OpenDay(calEvent.date);
                },
                dayClick: function(date, jsEvent, view) {
                    var $date = date.format('YYYY-MM-DD');
                    OpenDay($date);
                },
                viewRender: function(view, element) {
                    GetEvents();
                },
                eventRender: function(event, element) {
                    if (CalendarService.isBefore(event.date, now)) {
                        $(element).addClass('event-disabled');
                    }

                    var $text = '<div class="fc-content" >';
                    $text += '<h5 class="text-center" style="color:white;margin: 2px;white-space: pre-line">' + event.title + '</h5>';
                    $text += '<div class="fc-title text-center">' + CalendarService.FormatTime(event.date, event.start_time) + ' - ' + CalendarService.FormatTime(event.date, event.end_time) + '</div>';
                    $text += '</div>';
                    element.html($text);
                }
            });

            var loadingBoxElement = angular.element('<loading-box wait="vm.loading" time="5000" size="xxl"></loading-box>');
            var loadingBox = $compile(loadingBoxElement)($scope);
            var content = vm.calendar.contents().get(1);
            angular.element(content).addClass("pos-r");
            angular.element(content).append(loadingBox);
        }

        function OpenDay($date) {
            if (CalendarService.isBefore($date, now)) {
                return false;
            }

            var modalInstance = $uibModal.open({
                templateUrl: 'addEvent.html',
                controller: 'DayShiftController',
                controllerAs: 'vm',
                backdrop: 'static',
                keyboard: false,
                resolve: {
                    data: function() {
                        return {
                            date: $date,
                            GetEvents: function() {
                                GetEvents();
                            }
                        };
                    }
                }
            });
        }

        function DateNow() {
            now = moment();
            now.set({
                'hour': 0,
                'minute': 0,
                'second': 0,
                'millisecond': 0
            });
        }

        function init() {
            DateNow();
            initCalendar();
            MenuConfigFactory.menuActive(2);
        }

        init();
    })
    .controller('DayShiftController', function(data, $uibModalInstance, CalendarService, $uibModal, $state) {
        var vm = this;
        vm.date = data.date;
        vm.flags = {
        isLoading: false
        };

        vm.shifts = [];

        vm.dismiss = function() {
            $uibModalInstance.dismiss();
        };

        vm.AddSchedule = function(type_shift_id, $name) {
            openDialogShedule(type_shift_id, $name);
        };

        vm.moduleEdit = function(turn) {
            $state.go('mesas.turn.edit', {
                turn: turn
            });
            vm.dismiss();
        };

        vm.removeSchedule = function(id) {
            swal({
                title: "Confimar",
                text: "Se va eliminar el turno",
                type: "warning",
                showCancelButton: true,
                confirmButtonColor: "#DD6B55",
                confirmButtonText: "Sí, borrar ahora",
                cancelButtonText: "No, cancelar",
                closeOnConfirm: true,
                closeOnCancel: true
            }, function(isConfirm) {
                if (isConfirm) {
                    vm.loading = true;
                    CalendarService.DeleteShift(id, vm.date, {
                        OnSuccess: function(Response) {
                            GetData();
                            data.GetEvents();
                            vm.dismiss();
                            vm.loading = false;
                        },
                        OnError: function(Response) {
                            vm.loading = false;
                            message.apiError(Response);
                        }
                    });
                }
            });
        };

        function GetData() {
            vm.loading = true;
            CalendarService.GetShiftByDate(vm.date).then(
                function OnSuccess(Response) {
                    vm.shifts = Response.data.data;
                    vm.loading = false;
                },
                function OnError(Response) {
                    vm.loading = false;
                    message.apiError(Response);
                }
            );
        }

        function openDialogShedule(type_shift_id, $name) {
            vm.flags.isLoading = true;
            CalendarService.GetShiftsByType(type_shift_id, {
                OnSuccess: function(Response) {
                    vm.flags.isLoading = false;
                    try {
                        var $type_shift = {
                            id: type_shift_id,
                            name: $name
                        };
                        var modalInstance = $uibModal.open({
                            templateUrl: 'schedule.html',
                            controller: 'ScheduleShiftController',
                            controllerAs: 'vm',
                            backdrop: 'static',
                            keyboard: false,
                            resolve: {
                                data: function() {
                                    return {
                                        modalInstance: $uibModalInstance,
                                        typeShift: $type_shift,
                                        date: vm.date,
                                        shifts: Response.data.data,
                                        updateShifts: function() {
                                            GetData();
                                            data.GetEvents();
                                        }
                                    };
                                }
                            }
                        });
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                },
                OnError: function(Response) {
                    vm.flags.isLoading = false;
                    try {
                        if (Response.status == 401 || Response.status == 403) {
                            swal("Error", "No tiene permisos para realizar esta acción", "error");
                        } else {
                            swal("Error", "Ocurrió un error en el servidor", "error");
                        }
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                }
            });
        }

        vm.changeSchedule = function(type_shift_id, $name, turn_id) {
            openDialogChangeShedule(type_shift_id, $name, turn_id);
        };

        function openDialogChangeShedule(type_shift_id, $name, turn_id) {
            vm.flags.isLoading = true;
            CalendarService.GetShiftsByType(type_shift_id, {
                OnSuccess: function(Response) {
                    vm.flags.isLoading = false;
                    try {
                        var $type_shift = {
                            id: type_shift_id,
                            name: $name
                        };
                        var modalInstance = $uibModal.open({
                            templateUrl: 'changeSchedule.html',
                            controller: 'ScheduleChangeController',
                            controllerAs: 'vm',
                            backdrop: 'static',
                            keyboard: false,
                            resolve: {
                                data: function() {
                                    return {
                                        modalInstance: $uibModalInstance,
                                        turn_id: turn_id,
                                        typeShift: $type_shift,
                                        date: vm.date,
                                        shifts: Response.data.data,
                                        updateShifts: function() {
                                            GetData();
                                            data.GetEvents();
                                        }
                                    };
                                }
                            }
                        });
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                },
                OnError: function(Response) {
                    vm.flags.isLoading = false;
                    try {
                        if (Response.status == 401 || Response.status == 403) {
                            swal("Error", "No tiene permisos para realizar esta acción", "error");
                        } else {
                            swal("Error", "Ocurrió un error en el servidor", "error");
                        }
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                }
            });
        }

        function init() {
            var $date = moment(vm.date);

            vm.fulldate = ($date.format("dddd D [de] MMMM [de] YYYY"));

            GetData();
        }

        init();
    })
    .controller('ScheduleShiftController', function(data, $uibModalInstance, CalendarService) {
        var vm = this;
        vm.typeShift = data.typeShift;
        vm.shifts = data.shifts;
        vm.date = data.date;
        vm.flags = {
            isLoading: false
        };
        var modalInstanceBefore = data.modalInstance;

        vm.dismiss = function() {
            $uibModalInstance.dismiss();
        };

        vm.am_pm = function(time) {
            return CalendarService.FormatTime(vm.date, time);
        };

        vm.schedule = function(shift_id) {
            vm.flags.isLoading = true;
            CalendarService.ScheduleShift(shift_id, vm.date, {
                OnSuccess: function(Response) {
                    vm.flags.isLoading = false;
                    try {
                        if (Response.data.statuscode == 201) {
                            data.updateShifts();
                            messageAlert('Turno Programado', '', 'success');
                            vm.dismiss();
                            modalInstanceBefore.dismiss();
                        }
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                },
                OnError: function(Response) {
                    vm.flags.isLoading = false;
                    try {
                        swal("Error", Response.data.error.user_msg, "error");
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                }
            });
        };

        function init() {
            var $moment = moment(vm.date);
            vm.formatted_date = $moment.format('MMMM DD');
            vm.day_name = $moment.format('dddd') + ($moment.day() == 6 || $moment.day() === 0 ? 's' : '');
        }

        init();
    })
    .controller('ScheduleChangeController', function(data, $uibModalInstance, CalendarService) {
        var vm = this;
        vm.typeShift = data.typeShift;
        vm.date = data.date;
        var turn_id = data.turn_id;
        var modalInstanceBefore = data.modalInstance;

        vm.dismiss = function() {
            $uibModalInstance.dismiss();
        };

        vm.am_pm = function(time) {
            return CalendarService.FormatTime(vm.date, time);
        };

        vm.changeCheduless = function(shift_id) {
            vm.loading = true;
            CalendarService.ChangeSchedule(turn_id, shift_id, vm.date, {
                OnSuccess: function(Response) {
                    vm.loading = false;
                    try {
                        if (Response.data.statuscode == 201) {
                            data.updateShifts();
                            message.success('Turno Reprogramado');
                            vm.dismiss();
                            modalInstanceBefore.dismiss();
                        }
                    } catch (e) {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                },
                OnError: function(Response) {
                    vm.loading = false;
                    message.apiError(Response);
                }
            });
        };

        function removeShift(shifts) {
            for (var i = shifts.length - 1; i >= 0; i--) {
                if (shifts[i].id == turn_id) {
                    shifts.splice(i, 1);
                    break;
                }
            }

            return shifts;
        }

        function init() {
            vm.shifts = removeShift(data.shifts);
        }

        init();
    });
/**
 * Created by BS on 25/08/2016.
 */

angular.module('calendar.service', [])

.service('CalendarService', function($http, ApiUrlMesas, HttpFactory) {
    var zones, shifts;
    return {
        FormatTime: function(str_date, str_hour) {
            return moment(str_hour, "HH:mm:ss").format("hh:mm A");
        },
        isBefore: function(date, now) {
            var dateCalendar = moment(date);
            return moment(dateCalendar).isBefore(now);
        },
        GetShiftsByMonth: function($month, $listener) {
            $http.get(ApiUrlMesas + '/calendar/' + $month, null).then($listener.OnSuccess, $listener.OnError);
        },
        GetShiftByDate: function($date, $listener) {
            shifts = HttpFactory.get(ApiUrlMesas + '/calendar/' + $date + '/shifts', {}, shifts, true);
            return shifts;
        },
        GetShiftsByType: function(id, $listener) {
            $http.get(ApiUrlMesas + '/turns?type_turn=' + id, null).then($listener.OnSuccess, $listener.OnError);
            //var $res = {};
            //var $response = [
            //    {id: 1, name: 'Turno D1', hours_ini: '07:00:00', hours_end: '10:00:00'},
            //    {id: 2, name: 'Turno D2', hours_ini: '08:00:00', hours_end: '11:00:00'},
            //    {id: 3, name: 'Turno D3', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 4, name: 'Turno D4', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 5, name: 'Turno D5', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 6, name: 'Turno D6', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 7, name: 'Turno D7', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 8, name: 'Turno D8', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 9, name: 'Turno D9', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 10, name: 'Turno D10', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 11, name: 'Turno D11', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 12, name: 'Turno D12', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 13, name: 'Turno D13', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 14, name: 'Turno D14', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 15, name: 'Turno D15', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 16, name: 'Turno D16', hours_ini: '09:00:00', hours_end: '12:00:00'},
            //    {id: 17, name: 'Turno D17', hours_ini: '09:00:00', hours_end: '12:00:00'}
            //];
            //
            //$res.data = $response;
            //
            //$listener.OnSuccess($res);
        },
        GetTypeShiftById: function(id) {
            var $name = null;
            switch (id) {
                case 1:
                    $name = 'Desayuno';
                    break;
                case 2:
                    $name = 'Brunch';
                    break;
                case 3:
                    $name = 'Almuerzo';
                    break;
                case 4:
                    $name = 'Cena';
                    break;

            }
            return {
                id: id,
                name: $name
            };
        },
        ScheduleShift: function(id, date, $listener) {
            $http.post(ApiUrlMesas + '/calendar', {
                res_turn_id: id,
                date: date
            }).then($listener.OnSuccess, $listener.OnError);
            //$listener.OnSuccess({data: {statuscode: 200}, status: 200});
        },

        DeleteShift: function(id, date, $listener) {
            $http.delete(ApiUrlMesas + '/calendar/' + id, {
                params: {
                    date: date
                }
            }).
            then($listener.OnSuccess, $listener.OnError);
        },

        ChangeSchedule: function(turn_id, shift_id, date, $listener) {
            $http.put(ApiUrlMesas + '/calendar/change', {
                turn_id: turn_id,
                shift_id: shift_id,
                date: date
            }).then($listener.OnSuccess, $listener.OnError);
        },
        GetZones: function(date, date_end, reload) {
            zones = HttpFactory.get(ApiUrlMesas + "/calendar/" + date + "/zones?" + date_end, {}, zones, reload);
            return zones;
        },
    };
});
angular.module('configuration.app', ['configuration.controller', 'configuration.service'])
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.configuration', {
                url: '/configuration-reservation',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/configuration/view/index.html',
                        controller: 'ConfigurationCtrl',
                        controllerAs: 'vm',
                        cache: false
                    }
                }
            })
            .state('mesas.configuration.basic', {
                url: '/configuration-reservation-basic',
                templateUrl: '/js/app/tables/configuration/view/configuration-basic.html',
                resolve: {
                    $title: function() {
                        return 'Configuración basica';
                    }
                }
            })
            .state('mesas.configuration.form', {
                url: '/configuration-reservation-form',
                templateUrl: '/js/app/tables/configuration/view/configuration-form.html',
                resolve: {
                    $title: function() {
                        return 'Configuración campos formulario';
                    }
                }
            })
            .state('mesas.configuration.reserve', {
                url: '/configuration-reservation-code',
                templateUrl: '/js/app/tables/configuration/view/configuration-code.html',
                resolve: {
                    $title: function() {
                        return 'Configuración código';
                    }
                }
            })
            .state('mesas.configuration.user', {
                url: 'configuration-reservation-user',
                templateUrl: '/js/app/tables/configuration/view/configuration-user.html',
                resolve: {
                    $title: function() {
                        return 'Configuración usuario';
                    }
                }
            });
    });
angular.module('configuration.controller', ['ngAnimate', 'ui.bootstrap'])
    .controller('ConfigurationCtrl', ['$timeout', 'ConfigurationService', 'MenuConfigFactory', 'CustomTagGuestService', function($timeout, ConfigurationService, MenuConfigFactory, CustomTagGuestService) {
        var vm = this;
        vm.code = "";

        vm.cantUserList = ConfigurationService.initDataFakeList(100, "persona");
        vm.cantTableList = ConfigurationService.initDataFakeList(20, "mesa");
        vm.cantTableListPie = ConfigurationService.initDataFakeList(1000, "persona");
        vm.timeList = ConfigurationService.initDataFakeHour();

        //BASIC SECTION
        //Carga de configuracion inicial
        var configurationGet = function() {
            vm.loadingConfiguration = true;
            ConfigurationService.getConfig().then(function success(response) {
                vm.configuration = response;
                if (vm.configuration.res_code_status == 1) {
                    getCod();
                }
                if (vm.configuration.res_privilege_status == 1) {
                    getUser();
                }
                vm.loadingConfiguration = false;
            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning");
                vm.loadingConfiguration = false;
            });
        };

        //Carga de percentages para configuracion inicial
        var percentageGet = function() {
            ConfigurationService.getPercentages().then(function success(response) {
                vm.percentageList = response;
            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning");
            });
        };
        //Actualiza la configuration
        vm.configurationUpdate = function(id, configuration) {
            vm.flagSaveConfiguration = true;
            ConfigurationService.updateConfig(id, configuration).then(function success(response) {
                vm.configuration = response;
                messageAlert("Actualizo", "Se actualizo correctamente", "success");
                vm.flagSaveConfiguration = false;
            }, function error(response) {
                // console.log(response);
                messageErrorApi(response.data, "Error", "warning");
                vm.flagSaveConfiguration = false;
                alert = response.data;
            });
        };

        //CODE SECTION
        //Carga de codigos inicial
        var getCod = function() {
            vm.loadingCode = true;
            ConfigurationService.getCode().then(function success(response) {
                vm.codList = response;
                vm.loadingCode = false;
            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning");
                vm.loadingCode = false;
            });
        };

        //Actualiza el estado de codigo general
        vm.updateCodeStatus = function(res_code_status) {
            vm.loadingCode = true;
            ConfigurationService.updateCodeStatus(res_code_status).then(function success(response) {
                vm.configuration = response;
                if (vm.configuration.res_code_status == 1) {
                    getCod();
                }
                vm.loadingCode = false;
            }, function error(response) {
                if (res_code_status == 1) {
                    vm.configuration.res_code_status = 0;
                } else {
                    vm.configuration.res_code_status = 1;
                }
                messageErrorApi(response.data, "Error", "warning");
                vm.loadingCode = false;
            });
        };

        //Agregar un codigo de reservacion
        vm.setCode = function(ms_microsite_id, code) {
            vm.loadingsetCode = true;
            ConfigurationService.createCode(ms_microsite_id, code).then(function success(response) {
                data = response;
                data.classNewCode = "info";
                vm.code = "";
                vm.codList.unshift(data);
                vm.loadingsetCode = false;
            }, function error(response) {
                vm.loadingsetCode = false;
                messageAlert("Warning", "No se registro el código porque ya existe", "warning");
            });
        };

        //Eliminar un codigo de reservacion
        vm.deleteCode = function(code) {
            var index = CustomTagGuestService.findWithAttr(vm.codList, "code", code);
            vm.codList[index].delete = true;
            ConfigurationService.deleteCode(code).then(function success(response) {
                var index = CustomTagGuestService.findWithAttr(vm.codList, "code", code);
                vm.codList.splice(index, 1);
            }, function error(response) {
                messageAlert("Warning", "Ocurrio un error no se pudo eliminar", "warning");
                vm.codList[index].delete = false;
            });
        };


        //USER SECTION
        //Carga de usuario inicial
        var getUser = function() {
            vm.loadingGetUser = true;
            ConfigurationService.getAllPrivilegeUser().then(function success(response) {
                console.log(response);
                vm.userList = response;
                vm.loadingGetUser = false;
            }, function error(response) {
                vm.loadingGetUser = false;
                messageErrorApi(response.data, "Error", "warning");
            });
        };

        //Actualizar el estado de usuario general
        vm.updatePrivilegeStatus = function(res_privilege_status) {
            vm.loadingPrivilege = true;
            ConfigurationService.updatePrivilegeStatus(res_privilege_status).then(function success(response) {
                vm.configuration = response;
                if (vm.configuration.res_privilege_status == 1) {
                    getUser();
                }
                vm.loadingPrivilege = false;
            }, function error(response) {
                alert = response.data.data;
                vm.loadingPrivilege = false;
            });
        };

        //Eliminar un usuario
        vm.deletePrivilegeUser = function(id) {
            var index = CustomTagGuestService.findWithAttr(vm.userList, "id", id);
            vm.userList[index].delete = true;
            ConfigurationService.deletePrivilegeUser(id).then(function success(response) {
                var index = CustomTagGuestService.findWithAttr(vm.userList, "id", id);
                vm.userList.splice(index, 1);
            }, function error(response) {
                messageAlert("Warning", "Ocurrio un error no se pudo eliminar", "warning");
                vm.userList[index].delete = false;
            });
        };

        vm.createPrivilegeUser = function(id) {
            if (id !== null) {
                vm.loadingCreatePrivilegeUser = true;
                ConfigurationService.storePrivilegeUser(id).then(function success(response) {
                    data = response;
                    console.log(data);
                    vm.userList.unshift(data);
                    vm.search = null;
                    vm.userId = null;
                    vm.loadingCreatePrivilegeUser = false;
                }, function error(response) {
                    vm.loadingCreatePrivilegeUser = false;
                    messageAlert("Warning", "No se registro el privilegio del usuario porque ya existe", "warning");
                });
            } else {
                vm.search = null;
                messageAlert("Warning", "No se registro el privilegio del usuario porque el usuario no existe", "warning");
            }

        };

        var auxiliar;

        // var clickClose = function() {
        // 	angular.element($window).bind('click', function(e) {
        // 		var container = $("#custom-popup-wrapper");
        // 		if (container.has(e.target).length === 0) {
        // 			$scope.$apply(function() {
        // 				vm.noResult = false;
        // 			});
        // 		}
        // 	});
        // };

        vm.searchUser = function(search) {
            vm.loadingSearchUser = true;
            if (vm.searchOld != search) vm.userId = null;
            // if (auxiliar) $timeout.cancel(auxiliar);
            if (search === "") {
                vm.listUserAll = [];
                return;
            }
            var busqueda = function() {
                return ConfigurationService.getAllUser(search).then(function success(response) {
                    vm.listUserAll = response;
                    console.log(vm.listUserAll);
                    vm.loadingSearchUser = false;
                    // console.log(vm.listUserAll);
                    return response.map(function(item) {
                        // console.log(item);
                        return item;
                    }, function error(response) {

                    });
                });
            };
            // auxiliar = $timeout(busqueda, 500);
            return busqueda();
        };

        vm.initSearch = function(user) {
            vm.search = user.firstname + ' ' + user.lastname;
            vm.searchOld = vm.search;
            vm.userId = user.id;
            vm.listUserAll = [];
        };

        //Carga Inicial
        var init = function() {
            MenuConfigFactory.menuActive(4);
            configurationGet();
            percentageGet();
        };

        vm.test = function() {
            vm.noResults = false;
        };

        init();

    }]);
angular.module('configuration.service', [])
    .service('ConfigurationDataService', function($http, ApiUrlMesas) {
        return {
            getConfiguration: function() {
                return $http.get(ApiUrlMesas + "/configuration/reservations");
            },
            updateConfiguration: function(idMicrosite, configuration) {
                return $http.put(ApiUrlMesas + "/configuration/reservations/" + idMicrosite, {}, {
                    params: {
                        time_tolerance: configuration.time_tolerance,
                        time_restriction: configuration.time_restriction,
                        max_people: configuration.max_people,
                        max_people_standing: configuration.max_people_standing,
                        max_table: configuration.max_table,
                        res_code_status: configuration.res_code_status,
                        res_privilege_status: configuration.res_privilege_status,
                        messenger_status: configuration.messenger_status,
                        user_add: configuration.user_add,
                        user_upd: configuration.user_upd,
                        reserve_portal: configuration.reserve_portal,
                        res_percentage_id: configuration.res_percentage_id,
                        name_people_1: configuration.name_people_1,
                        name_people_2: configuration.name_people_2,
                        name_people_3: configuration.name_people_3,
                        status_people_1: configuration.status_people_1,
                        status_people_2: configuration.status_people_2,
                        status_people_3: configuration.status_people_3
                    }
                });
            },
            getListPercentage: function() {
                return $http.get(ApiUrlMesas + "/configuration/percentages");
            },
            getConfigurationCode: function() {
                return $http.get(ApiUrlMesas + "/configuration/codes");
            },
            storeConfigurationCode: function(idMicrosite, code) {
                return $http.post(ApiUrlMesas + "/configuration/codes", {}, {
                    params: {
                        code: code,
                        ms_microsite_id: idMicrosite,
                    }
                });
            },
            updateConfigurationCode: function(idCod, configuration) {
                return $http.put(ApiUrlMesas + "/configuration/codes/" + idCod, {}, {
                    params: {
                        code: configuration.code,
                        ms_microsite_id: idMicrosite,
                    }
                });
            },
            deleteConfigurationCode: function(idCod) {
                return $http.delete(ApiUrlMesas + "/configuration/codes/" + idCod);
            },
            updateCodeStatus: function(res_code_status) {
                return $http.patch(ApiUrlMesas + "/configuration/reservations", {}, {
                    params: {
                        res_code_status: res_code_status
                    }
                });
            },
            updatePrivilegeStatus: function(res_privilege_status) {
                return $http.patch(ApiUrlMesas + "/configuration/reservations", {}, {
                    params: {
                        res_privilege_status: res_privilege_status
                    }
                });
            },
        };

    })
    .service('ConfigurationDataUser', function($http, ApiUrlMesas) {
        return {
            getAllUser: function(search) {
                return $http.get(ApiUrlMesas + "/configuration/users/privileges/", {
                    params: {
                        search: search
                    }
                });
            },
            getAllPrivilegeUser: function() {
                return $http.get(ApiUrlMesas + "/configuration/users");
            },
            storePrivilegeUSer: function(idUser) {
                return $http.post(ApiUrlMesas + "/configuration/users", {}, {
                    params: {
                        user_id: idUser
                    }
                });
            },
            deletePrivilegeUSer: function(idUser) {
                return $http.delete(ApiUrlMesas + "/configuration/users/" + idUser);
            }
        };
    })
    .service('ConfigurationService', function($q, ConfigurationDataService, ConfigurationDataUser) {
        return {
            getConfig: function() {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.getConfiguration().success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            updateConfig: function(idMicrosite, configuration) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.updateConfiguration(idMicrosite, configuration).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getPercentages: function() {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.getListPercentage().success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getCode: function() {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.getConfigurationCode().success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            createCode: function(idMicrosite, code) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.storeConfigurationCode(idMicrosite, code).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            updateCode: function(idCod, configuration) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.updateConfigurationCode(idCod, configuration).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            deleteCode: function(idCod) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.deleteConfigurationCode(idCod).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            updateCodeStatus: function(res_code_status) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.updateCodeStatus(res_code_status).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            updatePrivilegeStatus: function(res_privilege_status) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataService.updatePrivilegeStatus(res_privilege_status).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getAllUser: function(search) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataUser.getAllUser(search).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;
            },
            getAllPrivilegeUser: function() {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataUser.getAllPrivilegeUser().success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;

            },
            storePrivilegeUser: function(idUser) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataUser.storePrivilegeUSer(idUser).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;

            },
            deletePrivilegeUser: function(idUser) {
                var defered = $q.defer();
                var promise = defered.promise;
                ConfigurationDataUser.deletePrivilegeUSer(idUser).success(function(data) {
                    data = data.data;
                    defered.resolve(data);
                }).error(function(data, status, headers) {
                    var response = jsonErrorData(data, status, headers);
                    defered.reject(response);
                });
                return promise;

            },
            initDataFakeList: function(cant, prefijo) {
                //Max cant de usuarios 1 -> 1000
                var list = [];
                for (var i = 0; i <= cant; i++) {
                    if (i != 1) {
                        list[i] = {
                            id: i,
                            option: i + " " + prefijo + "s"
                        };
                    } else {
                        list[i] = {
                            id: i,
                            option: i + " " + prefijo
                        };
                    }
                }
                return list;
            },
            initDataFakeHour: function() {
                var tolerancia = 0;
                var hora = 0;
                var timeList = [];
                for (var i = 0; i <= 36; i++) {
                    if (i == 0) {
                        timeList[i] = {
                            id: i,
                            option: "ILIMITADO"
                        };
                    } else if (i < 12) {
                        timeList[i] = {
                            id: i * 5,
                            option: tolerancia + " minutos"
                        };
                    } else {
                        resto = i % 12;
                        if (resto == 0) {
                            multiplo = true;
                        } else {
                            multiplo = false;
                        }
                        if (multiplo) {
                            hora++;
                            timeList[i] = {
                                id: i * 5,
                                option: hora + " horas"
                            };
                            tolerancia = 0;
                        } else {
                            timeList[i] = {
                                id: i * 5,
                                option: hora + " horas " + tolerancia + " minutos"
                            };
                        }
                    }
                    tolerancia = tolerancia + 5;
                }

                return timeList;
            }

        };
    });
angular.module('customtag.app', ['customtag.controller', 'customtag.service'])
	.config(function($stateProvider, $urlRouterProvider) {
		$stateProvider
			.state('mesas.customtag', {
				url: '/custom-tag-guest',
				views: {
					'@': {
						templateUrl: '/js/app/tables/customtag/view/index.html',
						controller: 'CustomTagCtrl',
						controllerAs: 'vm',
						cache: false
					}
				}
			});
	});
angular.module('customtag.controller', [])
	.controller('CustomTagCtrl', function(CustomTagGuestService, CustomTagReservationService) {
		var vm = this;
		vm.nameG = "";
		vm.nameR = "";
		vm.reservationTagList = ['test'];
		vm.guestTagList = ['test'];
		vm.message = {
			tagsGuest: "No existen Tags de invitados",
			tagsReservation: "No existen Tags de reservación"
		};

		vm.guestTagAll = function() {
			vm.initCT = true;
			CustomTagGuestService.getAllTag().then(function success(response) {
				vm.guestTagList = response;
				vm.initCT = false;
			}, function error(response) {
				messageErrorApi(response, "Error", "warning");
				vm.initCT = false;
			});
		};

		vm.guestCreateTag = function(name) {
			vm.loadingCreateCustomTag = true;
			CustomTagGuestService.createTag(name).then(function success(response) {
				data = response;
				if (data != null) {
					vm.nameG = "";
					vm.guestTagList.unshift(data);
					messageAlert("Correcto", "Se registro el tag para invitados correstamente", "success");
				} else {
					messageErrorApi(response, "Este tag para invitados ya se encuentra regitrado", "warning");
				}
				vm.loadingCreateCustomTag = false;
			}, function error(response) {
				messageErrorApi(response, "Error", "warning");
				vm.loadingCreateCustomTag = false;
			});
		};

		vm.guestDeleteTag = function(id) {
			var index = CustomTagGuestService.findWithAttr(vm.guestTagList, "id", id);
			vm.guestTagList[index].delete = true;
			CustomTagGuestService.deleteTag(id).then(function success(response) {
				var index = CustomTagGuestService.findWithAttr(vm.guestTagList, "id", id);
				vm.guestTagList.splice(index, 1);
			}, function(response) {
				messageErrorApi(response, "Error", "warning");
			});
		};

		vm.reservationTagAll = function() {
			vm.initRT = true;
			CustomTagReservationService.getAllTag().then(function(response) {
				vm.reservationTagList = response;
				vm.initRT = false;
			}, function(response) {
				messageErrorApi(response, "Error", "warning");
				vm.initRT = false;
			});
		};

		vm.reservationCreateTag = function(name) {
			vm.loadingCreateReservationTag = true;
			CustomTagReservationService.createTag(name).then(function(response) {
				data = response;
				if (data != null) {
					vm.nameR = "";
					vm.reservationTagList.unshift(data);
					messageAlert("Correcto", "Se registro tag de reservación correstamente", "success");
				} else {
					messageErrorApi(response, "Este tag de reservacion ya se encuentra regitrado", "warning");
				}
				vm.loadingCreateReservationTag = false;
			}, function(response) {
				messageErrorApi(response, "Error", "warning");
				vm.loadingCreateReservationTag = false;
			});
		};

		vm.reservationDeleteTag = function(id) {
			var index = CustomTagGuestService.findWithAttr(vm.reservationTagList, "id", id);
			vm.reservationTagList[index].delete = true;
			CustomTagReservationService.deleteTag(id).then(function(response) {
				var index = CustomTagGuestService.findWithAttr(vm.reservationTagList, "id", id);
				vm.reservationTagList.splice(index, 1);
			}, function(response) {
				messageErrorApi(response, "Error", "warning");
			});
		};

		vm.guestTagAll();
		vm.reservationTagAll();
	});
angular.module('customtag.service', [])
	.service('CustomTagGuestDataService', function($http, ApiUrlMesas) {
		return {
			getListTagGuestCustom: function() {
				return $http.get(ApiUrlMesas + "/guest-tags");
			},
			createTagGuestCustom: function(name) {
				return $http.post(ApiUrlMesas + "/guest-tags", {}, {
					params: {
						name: name
					}
				});
			},
			deleteTagGuestCustom: function(idTag) {
				return $http.delete(ApiUrlMesas + "/guest-tags/" + idTag);
			},
		};
	})
	.service('CustomTagReservationDataService', function($http, ApiUrlMesas) {
		return {
			getListTagReservationCustom: function() {
				return $http.get(ApiUrlMesas + "/reservation/tag");
			},
			createTagReservationCustom: function(name) {
				return $http.post(ApiUrlMesas + "/reservation/tag", {}, {
					params: {
						name: name
					}
				});
			},
			deleteTagReservationCustom: function(idTag) {
				return $http.delete(ApiUrlMesas + "/reservation/tag/" + idTag);
			},
		};
	})
	.service('CustomTagGuestService', function($q, CustomTagGuestDataService) {
		return {
			getAllTag: function() {
				var defered = $q.defer();
				CustomTagGuestDataService.getListTagGuestCustom().success(function(data) {
					data = data.data;
					defered.resolve(data);
				}).error(function(data, status, headers) {
					var response = jsonErrorData(data, status, headers);
					defered.reject(response);
				});
				return defered.promise;
			},
			createTag: function(name) {
				var defered = $q.defer();
				CustomTagGuestDataService.createTagGuestCustom(name).success(function(data) {
					data = data.data;
					defered.resolve(data);
				}).error(function(data, status, headers) {
					var response = jsonErrorData(data, status, headers);
					defered.reject(response);
				});

				return defered.promise;
			},
			deleteTag: function(idTag) {
				var defered = $q.defer();
				var promise = defered.promise;
				CustomTagGuestDataService.deleteTagGuestCustom(idTag).success(function(data) {
					data = data.data;
					defered.resolve(data);
				}).error(function(data, status, headers) {
					var response = jsonErrorData(data, status, headers);
					defered.reject(response);
				});
				return promise;
			},

			findWithAttr: function(array, attr, value) {
				for (var i = 0; i < array.length; i += 1) {
					if (array[i][attr] === value) {
						return i;
					}
				}
				return -1;
			},

		};
	}).service('CustomTagReservationService', function($q, CustomTagReservationDataService) {
		return {
			getAllTag: function() {
				var defered = $q.defer();
				var promise = defered.promise;
				CustomTagReservationDataService.getListTagReservationCustom().success(function(data) {
					data = data.data;
					defered.resolve(data);
				}).error(function(data, status, headers) {
					var response = jsonErrorData(data, status, headers);
					defered.reject(response);
				});
				return promise;
			},
			createTag: function(name) {
				var defered = $q.defer();
				var promise = defered.promise;
				CustomTagReservationDataService.createTagReservationCustom(name).success(function(data) {
					data = data.data;
					defered.resolve(data);
				}).error(function(data, status, headers) {
					var response = jsonErrorData(data, status, headers);
					defered.reject(response);
				});
				return promise;

			},
			deleteTag: function(id) {
				var defered = $q.defer();
				var promise = defered.promise;
				CustomTagReservationDataService.deleteTagReservationCustom(id).success(function(data) {
					data = data.data;
					defered.resolve(data);
				}).error(function(data, status, headers) {
					var response = jsonErrorData(data, status, headers);
					console.log(response);
					defered.reject(response);
				});
				return promise;
			},

		};
	});
angular.module('floor.app', ['floor.controller', 'floor.service', 'floor.directive', 'floor.filter', 'server.service', 'floor.notify.controller', 'global.service'])
    .constant("screenSizeFloor", {
        minSize: 400,
        header: 185,
        menu: 400
    })
    .config(function($stateProvider, $urlRouterProvider, $httpProvider) {
        $stateProvider.state('mesas.floor', {
            url: '/floor',
            views: {
                '@': {
                    templateUrl: '/js/app/tables/floor/view/parent.html',
                    controller: 'FloorMainCtrl',
                    controllerAs: 'vm',
                    cache: true,
                },
                'index@mesas.floor': {
                    templateUrl: '/js/app/tables/floor/view/index.html',
                    controller: 'FloorCtrl',
                    controllerAs: 'vm'
                },
                'principal@mesas.floor': {
                    templateUrl: '/js/app/tables/floor/view/principal.html'
                },
                'tabReservaciones@mesas.floor': {
                    templateUrl: '/js/app/tables/floor/view/tabReservaciones.html'
                },
            },
        }).state('mesas.floor.reservation', {
            url: '/reservation',
            views: {
                "": {
                    templateUrl: '/js/app/tables/floor/view/reservation.html',
                    controller: 'reservationController',
                    controllerAs: 'rm'
                }
            }
        }).state('mesas.floor.walkin', {
            url: '/walkin',
            templateUrl: '/js/app/tables/floor/view/waitlist.html',
            controller: 'WaitListCtrl',
            controllerAs: 'wm',
        }).state('mesas.floor.server', {
            url: '/server',
            templateUrl: '/js/app/tables/floor/view/server.html',
            controller: 'serverCtrl',
            controllerAs: 'sm',
        });
    });
angular.module('floor.controller', []);
angular.module('floor.directive', [])
    .directive('ngDetailTable', function() {

        function makeSelectTable(scope, element, attr) {
            var table = $(element);

            element.droppable({
                //accept: ".listado-column",
                drop: function(event, ui) {
                    // console.log(ui.draggable[0].dataset.quantity);
                    clearBG();
                    var quantity = parseInt(ui.draggable[0].dataset.quantity) || 0;
                    scope.$apply(function() {
                        scope.num = {
                            num_men: quantity,
                            num_women: 0,
                            num_children: 0,
                            total: quantity
                        };
                    });
                    scope.onDroppedFn();
                },
                over: function(evt, ui) {
                    var originalTable = $(ui.helper).parent().context.parentNode;
                    if (originalTable != table[0]) {
                        table.addClass("dropTable");
                    }

                },
                out: function(evt, ui) {
                    clearBG();
                }
            });

            function clearBG() {
                table.removeClass("dropTable");
            }
        }

        return {
            link: makeSelectTable,
            scope: {
                num: "=",
                onDroppedFn: '&'
            }
        };
    })
    .directive('ngTable', function() {

        function tableSelected(scope, element, attr) {

            var left = attr.x;
            var top = attr.y;

            element.css({
                position: 'absolute',
                cursor: 'pointer',
                top: top + 'px',
                left: left + 'px',
                border: '2px solid ' + attr.color,
                none: 'none',
            });


            element.on('click', function(event) {

                event.preventDefault();
                scope.onClickFn();

            });
        }

        return {
            link: tableSelected,
            scope: {
                onClickFn: '&'
            }
        };
    })
    .directive('ngDragNumPeople', function() {

        function makeDraggable(scope, element, attr) {

            element.draggable({
                helper: "clone",
                drag: function(event, ui) {
                    // console.log(ui.position.left);
                },
                start: function(event, ui) {
                    angular.element('.bg-window-floor').addClass('drag-dispel');
                    scope.tableFilterFn();
                },
                stop: function(event, ui) {
                    angular.element('.bg-window-floor').removeClass('drag-dispel');
                    scope.tableFilterClearFn();
                }
            });
        }

        return {
            scope: {
                tableFilterFn: "&",
                tableFilterClearFn: "&"
            },
            link: makeDraggable,
        };
    })
    .directive('ngDragUpComing', function() {

        function makeDraggable(scope, element, attr) {

            element.draggable({
                helper: "clone",
                cursorAt: {
                    left: 200,
                    top: 31
                },
                drag: function(event, ui) {
                    angular.element(".not_selector").draggable("disable");
                    //console.log('x: ' + ui.offset.left + ', ' + 'y: ' + ui.offset.top);
                },
                start: function(event, ui) {
                    angular.element('.bg-window-floor').addClass('drag-dispel');
                    scope.onStartFn();
                },
                stop: function(event, ui) {
                    angular.element('.bg-window-floor').removeClass('drag-dispel');
                    scope.onStopFn();
                }
            });
        }

        return {
            link: makeDraggable,
            scope: {
                onStopFn: '&',
                onStartFn: '&'
            }
        };
    })
    .directive('ngDropTabZones', function() {
        function makeDroppable(scope, element, attr) {
            element.droppable({
                accept: ".listado-column",
                over: function(event, ui) {
                    scope.$apply(function() {
                        scope.onDroppeddFn();
                    });
                },
            });
        }
        return {
            link: makeDroppable,
            scope: {
                onDroppeddFn: '&'
            }
        };
    })
    .directive('ngDragMoveReservation', function() {

        function makeDraggable(scope, element, attr) {
            element.draggable({
                helper: "clone",
                appendTo: '#lienzo',
                cursorAt: {
                    left: 10,
                    top: 10
                },
                start: function(event, ui) {
                    $(ui.helper).css({
                        "z-index": 2,
                        "margin-left": "10px",
                        "margin-top": "10px"
                    });
                    angular.element('.bg-window-floor').addClass('drag-dispel');
                    scope.onStartFn();
                },
                stop: function(event, ui) {
                    angular.element('.bg-window-floor').removeClass('drag-dispel');
                    scope.onEndFn();
                }
            });
        }

        return {
            link: makeDraggable,
            scope: {
                onStartFn: '&',
                onEndFn: '&'
            }
        };
    });
angular.module('floor.filter', [])
    .filter("statusReservation", function() {
        return function(valor) {
            if (valor !== null) {
                var name_status = "";
                switch (valor) {
                    case 1:
                        name_status = "not-confirmed";
                        break;
                    case 2:
                        name_status = "confirmed";
                        break;
                    case 3:
                        name_status = "left-message";
                        break;
                    case 4:
                        name_status = "seated";
                        break;
                    case 5:
                        name_status = "wrong-number";
                        break;
                    case 6:
                        name_status = "partially-arrived";
                        break;
                    case 7:
                        name_status = "all-arrived";
                        break;
                    case 8:
                        name_status = "paged";
                        break;
                    case 9:
                        name_status = "running-late";
                        break;
                    case 10:
                        name_status = "finished";
                        break;
                    case 11:
                        name_status = "canceled-guest";
                        break;
                    case 12:
                        name_status = "canceled-restaurant";
                        break;
                    case 13:
                        name_status = "no-show";
                        break;
                    case 14:
                        name_status = "no-answer";
                        break;
                    case 15:
                        name_status = "partially-seated";
                        break;
                    case 16:
                        name_status = "entree";
                        break;
                    case 17:
                        name_status = "dessert";
                        break;
                    case 18:
                        name_status = "table-cleared";
                        break;
                    case 19:
                        name_status = "appetizer";
                        break;
                    case 20:
                        name_status = "check-dropped";
                        break;
                    case 21:
                        name_status = "check-paid";
                        break;
                    default:
                        name_status = "";
                        break;
                }
                return name_status;
            }
        };
    })
    .filter("statusCondicion", function() {
        return function(items) {
            var salida = [];
            angular.forEach(items, function(item) {
                if (item.res_reservation_status_id !== null && item.tables.length !== 0) {
                    var status = item.res_reservation_status_id;
                    switch (status) {
                        case 1:
                        case 2:
                        case 3:
                            salida.push(item);
                            break;
                    }

                }
            });
            return salida;
        };
    })
    .filter("waitlistCondicion", function() {
        return function(items) {
            var salida = [];
            angular.forEach(items, function(item) {
                if (item.wait_list == 1 && item.tables.length === 0) {
                    var status = item.res_reservation_status_id;
                    switch (status) {
                        case 1:
                        case 2:
                        case 3:
                        case 6:
                        case 7:
                            salida.push(item);
                            break;
                    }

                }
            });
            return salida;
        };
    })
    .filter("waitlist", function() {
        return function(items) {
            var salida = items.filter(function(item) {
                return item.wait_list === 0 || (item.wait_list == 1 && item.res_reservation_status_id == 4) || item.res_block_id;
            });

            return salida;
        };
    })
    .filter("statusSeated", function() {
        return function(items) {
            var salida = [];
            angular.forEach(items, function(item) {
                if (item.res_reservation_status_id !== null && item.tables.length !== 0) {
                    var status = item.res_reservation_status_id;
                    switch (status) {
                        case 4:
                            salida.push(item);
                            break;
                    }

                }
            });
            return salida;
        };
    })
    .filter("statusAll", function() {
        return function(items) {
            var salida = [];
            angular.forEach(items, function(item) {
                if (item.res_reservation_status_id !== null && item.tables.length !== 0) {
                    salida.push(item);
                }
            });
            return salida;
        };
    })
    .filter('gender', function() {
        return function(items, categorias) {
            var salida = [];

            if (!categorias.length) {
                return items;
            }

            var filterPeople1 = false;
            var filterPeople2 = false;
            var filterPeople3 = false;

            angular.forEach(categorias, function(categoria) {
                var idcategoria = categoria.id;
                if (idcategoria === 2) {
                    filterPeople1 = true;
                }
                if (idcategoria === 3) {
                    filterPeople2 = true;
                }
                if (idcategoria === 4) {
                    filterPeople3 = true;
                }
            });

            angular.forEach(items, function(item) {
                var filter = (filterPeople1 && item.num_people_1 > 0) || (filterPeople2 && item.num_people_2 > 0) || (filterPeople3 && item.num_people_3 > 0);
                if (filter) {
                    salida.push(item);
                }
            });

            return salida;
        };
    })
    .filter('typeRes', function() {
        return function(items, categorias) {
            var salida = [];

            if (categorias.length === 0) {
                return items;
            }

            var filterWeb = false;
            var filterTelefono = false;
            var filterPortal = false;
            var filterRP = false;

            angular.forEach(categorias, function(categoria) {
                var idcategoria = categoria.id;
                if (idcategoria === 1) {
                    filterWeb = true;
                }
                if (idcategoria === 2) {
                    filterTelefono = true;
                }
                if (idcategoria === 3) {
                    filterPortal = true;
                }
                if (idcategoria === 4) {
                    filterRP = true;
                }
            });

            angular.forEach(items, function(item) {
                var filter = (filterWeb && item.res_source_type_id == 1) || (filterTelefono && item.res_source_type_id == 2) || (filterPortal && item.res_source_type_id == 3) || (filterRP && item.res_source_type_id == 4);
                if (filter) {
                    salida.push(item);
                }
            });

            return salida;
        };
    })
    .filter('typeTurn', function() {
        return function(items, categorias) {
            var salida = [];

            if (categorias.length === 0) {
                return items;
            }

            salida = items.filter(function(item) {
                return categorias.some(function(category) {
                    return category.turn.id == item.res_turn_id;
                });
            });

            return salida;
        };
    })
    .filter("statusTurnos", function(TypeFilterDataFactory, $filter) {
        return function(valor) {
            if (valor !== null) {
                var name_status = "";
                var listadoTurns = TypeFilterDataFactory.getTypeTurnItems();
                angular.forEach(listadoTurns, function(turn) {
                    if (turn.id == valor) {
                        name_status = $filter('uppercase')(turn.name);
                    }
                });
                return name_status;
            }
        };
    })
    .filter("statusReservas", function(TypeFilterDataFactory, $filter) {
        return function(valor) {
            if (valor !== null) {
                var name_status = "";
                var listadoReservations = TypeFilterDataFactory.getSourceTypesItems();
                angular.forEach(listadoReservations, function(reserva) {
                    if (reserva.id == valor) {
                        name_status = $filter('uppercase')(reserva.name);
                    }
                });
                return name_status;
            }
        };
    })
    .filter("statusEstados", function(TypeFilterDataFactory, $filter) {
        return function(valor, opcion) {

            if (valor !== null) {
                var name_status = "";
                var color = "";
                var listadoStatus = TypeFilterDataFactory.getStatusTypesItems();
                angular.forEach(listadoStatus, function(status) {
                    if (status.id == valor) {
                        name_status = $filter('uppercase')(status.name);
                        color = status.color;
                    }
                });
                if (opcion == "name") {
                    return name_status;
                } else if (opcion == "color") {
                    return color;
                }
            }
        };
    }).filter('customStatus', function() {
        return function(list, arrayFilter, element) {
            if (arrayFilter.length === 0) {
                var salida = list.filter(function(item) {
                    var waitlist = !(item.wait_list == 1 && (item.res_reservation_status_id != 4 || item.res_reservation_status_id != 5)); // Si es waitlist, solo se muestra si esta sentado
                    return waitlist;
                });
                return salida;
                //return list;
            }

            var salida = list.filter(function(item) {
                if (item.start_time) return false; // Es un blockeo - se excluye
                var status = arrayFilter.indexOf(item[element]) != -1; // Si su  estado(valor dinamico) se encuentra entre los filtros
                var waitlist = item.wait_list === 0 || (item.wait_list == 1 && item.res_reservation_status_id == 4); // Si es waitlist, solo se muestra si esta sentado
                return status && waitlist;
            });
            return salida;
        };
    })
    .filter("blocks", function() {
        return function(list) {
            var salida = list.reduce(function(array, item) {
                // Si es una reservacion - devuelve la reservacion

                //Si es un bloqueo - Analiza si ya existe un bloqueo similar (api devuelve un bloqueo por mesa, no bloqueo con sus mesas)
                if (item.start_time) {
                    // Pregunta si ya existe el bloqueo
                    var exists = array.some(function(itemX) {
                        return itemX.id == item.id && itemX.start_time;
                    });

                    // Si no existe agrego el bloqueo a la lista a retornar
                    if (!exists) {
                        array.push(item);
                    }
                } else { //  Es una reservacion - se retorna
                    array.push(item);
                }

                return array;
            }, []);

            return salida;
        };
    });
angular.module("floor.notify.controller", [])

.controller('FloorMainCtrl', function($scope, ServerNotification) {

    var serverSocket = ServerNotification.getConnection();

    serverSocket.on("b-mesas-floor-notes", function(data) {
        $scope.$broadcast("floorNotesReload", data);
    });

    serverSocket.on("b-mesas-floor-res", function(data) {
        $scope.$broadcast("NotifyFloorTableReservationReload", data);
    });

    serverSocket.on("b-mesas-config-update", function(data) {
        $scope.$broadcast("NotifyFloorConfigUpdateReload", data.user_msg);
    });

    serverSocket.on("b-mesas-floor-server", function(data) {
        $scope.$broadcast("NotifyFloorTableServerReload", data);
    });

    serverSocket.on("b-mesas-floor-upd-block", function(data) {
        $scope.$broadcast("NotifyFloorBlock", data);
    });

});
angular.module('floor.service', [])
    .factory('FloorDataFactory', function($http, HttpFactory, ApiUrlMesas, ApiUrlRoot) {
        var reservations, tables, sourceTypes;
        return {
            getDataFloor: function(date) {
                var params = (date == undefined) ? '' : '?date=' + date;
                return $http.get(ApiUrlMesas + "/web-app/floor" + params, null);
            },
            getBloqueos: function(reload) {
                tables = HttpFactory.get(ApiUrlMesas + "/blocks", null, tables, reload);
                return tables;
            },
            getSourceTypes: function(reload) {
                sourceTypes = HttpFactory.get(ApiUrlRoot + "/reservation/source-types", null, sourceTypes, reload);
                return sourceTypes;
            },
            sendMessage: function(reservacion_id, data) {
                return $http.post(ApiUrlMesas + "/reservations/" + reservacion_id + "/send-email", data);
            },
        };
    })
    //Data para filtro de reservas Turnos, Reservas y visitas
    .factory('TypeFilterDataFactory', function() {
        var typeColection = [];
        var sourceColection = [];
        var statusColection = [];
        var filtrosTurno = [];
        var filtrosVisita = [];
        var filtrosReserva = [];
        return {
            setTypeTurnItems: function(typeItem) {
                var vTurn = [];
                var itemTodos = {
                    id: 0,
                    name: "Todos",
                    status: 1,
                    checked: true,
                    turn: [{
                        hours_ini: "00:00:00",
                        hours_end: "00:00:00"
                    }]
                };
                angular.forEach(typeItem, function(value) {
                    vTurn.push({
                        id: value.id,
                        name: value.name,
                        status: value.status,
                        checked: false,
                        turn: value.turn
                    });
                });
                vTurn.unshift(itemTodos);
                typeColection = vTurn;
            },
            getTypeTurnItems: function(FloorFactory) {
                return typeColection;
            },
            setSourceTypesItems: function(sourceItem) {
                var vSource = [];
                var itemTodos = {
                    id: 0,
                    name: "Todos",
                    status: 1,
                    checked: true,
                    turn: [{
                        hours_ini: "00:00:00",
                        hours_end: "00:00:00"
                    }]
                };
                angular.forEach(sourceItem, function(value) {
                    vSource.push({
                        id: value.id,
                        name: value.name,
                        description: value.description,
                        checked: false
                    });
                });
                vSource.unshift(itemTodos);
                sourceColection = vSource;
            },
            getSourceTypesItems: function() {
                return sourceColection;
            },
            setStatusTypesItems: function(statusItem) {
                statusColection = statusItem;
            },
            getStatusTypesItems: function() {
                return statusColection;
            },
            setOpcionesFilterTurnos: function(typeItem) {
                if (typeItem.id === 0) {
                    filtrosTurno.push(typeItem);
                } else {
                    angular.forEach(filtrosTurno, function(value, key) {
                        if (value.id === 0) {
                            filtrosTurno.splice(key, 1);
                        }
                    });
                    filtrosTurno.push(typeItem);
                }
            },
            getOpcionesFilterTurnos: function() {
                return filtrosTurno;
            },
            delOpcionesFilterTurnos: function(typeItem) {
                angular.forEach(filtrosTurno, function(value, key) {
                    if (value.id == typeItem.id) {
                        filtrosTurno.splice(key, 1);
                    }
                });
            },
            setOpcionesFilterVisitas: function(genderItem) {
                if (genderItem.idcategoria == 1) {
                    filtrosVisita.push(genderItem);
                } else {
                    angular.forEach(filtrosVisita, function(value, key) {
                        if (value.idcategoria == 1) {
                            filtrosVisita.splice(key, 1);
                        }
                    });
                    filtrosVisita.push(genderItem);
                }
            },
            getOpcionesFilterVisitas: function() {
                return filtrosVisita;
            },
            delOpcionesFilterVisitas: function(genderItem) {
                angular.forEach(filtrosVisita, function(value, key) {
                    if (value.idcategoria == genderItem.idcategoria) {
                        filtrosVisita.splice(key, 1);
                    }
                });
            },
            setOpcionesFilterReservas: function(reservaItem) {
                if (reservaItem.id === 0) {
                    filtrosReserva.push(reservaItem);
                } else {
                    angular.forEach(filtrosReserva, function(value, key) {
                        if (value.id === 0) {
                            filtrosReserva.splice(key, 1);
                        }
                    });
                    filtrosReserva.push(reservaItem);
                }
            },
            getOpcionesFilterReservas: function() {
                return filtrosReserva;
            },
            delOpcionesFilterReservas: function(reservaItem) {
                angular.forEach(filtrosReserva, function(value, key) {
                    if (value.id == reservaItem.id) {
                        filtrosReserva.splice(key, 1);
                    }
                });
            }
        };
    })
    .factory('NoteFactoryData', function($http, HttpFactory, ApiUrlMesas) {

        return {
            create: function(data) {
                return $http.post(ApiUrlMesas + '/turns/notes', data);
            },
            getAll: function(params) {
                return $http.get(ApiUrlMesas + '/turns/notes?' + params);
            }
        };
    })
    .factory('FloorFactory', function($q, $interval, reservationService, TableFactory, FloorDataFactory, ServerFactory, CalendarService, NoteFactoryData, TypeFilterDataFactory, BlockFactory, $table) {
        var flag = {
            editServer: false
        };
        var serverColection = [];
        var zonesTotal = [];
        var navegaTabZone = 0;
        var reservasAndBlocks = [];

        var turns_notes;
        return {
            getDataFloor: function(date) {
                var defered = $q.defer();
                FloorDataFactory.getDataFloor(date).then(
                    function success(response) {
                        response = response.data.data;
                        defered.resolve(response);
                    },
                    function error(response) {
                        response = response.data;
                        defered.reject(response);
                    }
                );
                return defered.promise;
            },
            getZones: function(date, reload) {
                var defered = $q.defer();
                reservationService.getZones(date, reload)
                    .then(
                        function success(response) {
                            response = response.data.data;
                            defered.resolve(response);

                        },
                        function error(response) {
                            response = response.data;
                            defered.reject(response);
                        }
                    );
                return defered.promise;
            },
            getBlocks: function() {
                var defered = $q.defer();
                var self = this;
                reservationService.getBlocks(null, true)
                    .then(function success(response) {
                        response = response.data.data;
                        /*angular.forEach(response, function(block) {
                            self.addEventBlocks(block);
                        });*/
                        defered.resolve(response);
                        //blocks = response.data.data;
                        //console.log("loadBlock " + angular.toJson(blocks, true));
                    }, function error(response) {
                        response = response.data;
                        defered.reject(response);
                    });
                //$table.setBorderColorForReservation(vm.zones, blocks);
                return defered.promise;
            },
            addEventBlocks: function(table) {

                angular.forEach(table.blocks, function(block) {
                    var event = {};
                    event.fire = function() {
                        var time = moment();
                        try {

                            var blockStartTime = moment(block.start_time, "HH:mm:ss");
                            var blockEndTime = moment(block.end_time, "HH:mm:ss");

                            if (time.isBetween(blockStartTime, blockEndTime)) {
                                //console.log('Se ha bloqueado', block);
                                table.block = true;
                            } else {
                                if (time.isAfter(blockEndTime)) {
                                    $interval.cancel(event.eventInterval);
                                    table.block = false;
                                    if (event.eventInterval) console.log("Evento cancelado, hora actual es mayor a su fin, ID: ", block);
                                }
                            }

                        } catch (e) {
                            console.log("Event error: ", e);
                        }
                    };
                    event.eventInterval = $interval(event.fire, 6000);

                    table.events.push(event);
                });
            },
            getServers: function(reload) {
                var defered = $q.defer();
                reservationService.getServers(reload)
                    .then(function success(response) {
                        response = response.data.data;
                        defered.resolve(response);
                    }, function error(response) {
                        response = response.data;
                        deferred.reject(response);
                    });

                return defered.promise;
            },
            asingBlockTables: function(blocks, zones) {
                var self = this;
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.blocks = self.searchBlockTables(blocks, table);
                        self.addEventBlocks(table);
                    });
                });
                //console.log('AsigBlock', angular.toJson(zones, true));
            },
            searchBlockTables: function(blocks, table) {
                var tableBlocks = [];
                angular.forEach(blocks, function(block) {
                    if (block.res_table_id == table.id) {
                        tableBlocks.push({
                            start_time: block.start_time,
                            end_time: block.end_time,
                            start_date: block.start_date
                        });
                    }
                });
                return tableBlocks;
            },
            parseDataBlock: function(block) {
                var blockTables = [];
                angular.forEach(block.tables, function(table) {
                    blockTables.push({
                        res_table_id: table.id,
                        start_time: block.start_time,
                        end_time: block.end_time,
                        start_date: block.start_date
                    });

                });
                return blockTables;
            },
            getIndiceZone: function(idZone) {
                var me = this;
                var zone_indice;
                var zonas = me.getDataZonesTables();
                //console.log('llegas: ', zonas);

                angular.forEach(zonas, function(zone, key_zone) {
                    var indice = key_zone + 1;
                    if (zone.id == idZone) {
                        zone_indice = indice;
                        return;
                    }

                });
                return zone_indice;
            },
            getReservations: function(reload) {
                var me = this;
                var defered = $q.defer();
                reservationService.getReservations(reload).then(function(response) {
                    response = response.data.data;
                    var objReservation = [];

                    angular.forEach(response, function(reserva) {
                        var reservaData = me.parseDataReservation(reserva);
                        objReservation.push(reservaData);
                    });
                    /*console.log(angular.toJson(objReservation, true));*/
                    defered.resolve(objReservation);
                }, function error(response) {
                    response = response.data;
                    defered.reject(response);
                });
                return defered.promise;
            },
            rowTableReservation: function(idTable) {
                var me = this;
                var defered = $q.defer();
                me.getReservations().then(function success(reservations) {
                    var vTables = [];
                    angular.forEach(reservations, function(reservation) {
                        var tables = reservation.tables;
                        // console.log(reservation);
                        angular.forEach(tables, function(table) {
                            if (table.id === idTable) {
                                vTables.push(reservation);
                            }
                        });
                    });
                    defered.resolve(vTables);
                }, function error(data) {
                    return data;
                });
                return defered.promise;
            },
            setBorderColorForReservation: function(zones, blocks) {
                var hour = moment();

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.server.reservation = null;
                        /*table.class.name = null;*/
                    });
                });

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(blocks, function(block) {
                            if (table.id == block.res_table_id) {
                                var start_block = moment(block.start_time, "HH:mm:ss");
                                var end_block = moment(block.end_time, "HH:mm:ss");
                                if (hour.isBetween(start_block, end_block, null, "()") || block.res_reservation_status_id >= 14) {
                                    if (block.res_server_id) {
                                        table.server.setReservation(block.res_server.color);
                                    }
                                    table.class.setStatusClass(block.res_reservation_status_id);

                                    if (block.res_reservation_id === null) {
                                        table.block = true;
                                        table.blockStatic = true;
                                    }
                                } else {
                                    if (block.res_reservation_id === null) {
                                        table.block = false;
                                        table.blockStatic = false;
                                    }
                                }
                            }
                        });
                    });
                });
            },
            setColorTable: function(zones, servers) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(servers, function(server) {
                            angular.forEach(server.tables, function(serverTable) {
                                if (table.id == serverTable.id) {
                                    table.server.setDefault(server.color);
                                }
                            });
                        });
                    });
                });
            },
            getReservationTables: function(zones, blocks, reservation_id) {
                var reservationTables = "";
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(blocks, function(block) {
                            if (table.id == block.res_table_id) {
                                if (block.res_reservation_id == reservation_id) {
                                    reservationTables += table.name + ", ";
                                }
                            }
                        });
                    });
                });

                return reservationTables.substring(0, reservationTables.length - 2);
            },
            clearSelected: function(zones) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.selected = false;
                    });
                });
            },
            getZoneIndexForTable: function(zones, serverTables) {
                if (serverTables.length === 0) {
                    return 0;
                }
                var index = null;
                angular.forEach(zones, function(zone, zone_index) {
                    if (index === null) {
                        angular.forEach(zone.tables, function(table) {
                            if (index === null) {
                                angular.forEach(serverTables, function(serverTable) {
                                    if (index === null) {
                                        if (table.id == serverTable.id) {
                                            index = zone_index;
                                        }
                                    }
                                });
                            }
                        });
                    }
                });

                return index;
            },
            tablesSelected: function(zones, serverTables) {
                if (serverTables.length === 0) {
                    return;
                }
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(serverTables, function(serverTable) {
                            if (table.id == serverTable.id) {
                                table.selected = true;
                            }
                        });
                    });
                });
            },
            tableFilter: function(zones, blocks, cant) {
                // Manejo estatico de tiempo de reserva por cantidad  de invitados
                //var start_time = moment().add(-moment().minutes() % 15, "minutes").second(0);

                var start_time = moment().add(-moment().minutes() % 15, "minutes").second(0).millisecond(0);

                var end_time = start_time.clone().add((60 + 15 * cant), "minutes");

                angular.forEach(blocks, function(block) {
                    var start_block = moment(block.start_time, "HH:mm:ss");
                    var end_block = moment(block.end_time, "HH:mm:ss");
                    angular.forEach(zones, function(zone) {
                        angular.forEach(zone.tables, function(table) {
                            if (table.id == block.res_table_id && block.res_reservation_status_id < 14) {

                                var start_block = moment(block.start_time, "HH:mm:ss");
                                var end_block = moment(block.end_time, "HH:mm:ss");

                                /*if ((start_time.isBetween(start_block, end_block, null, "()")) ||
                                    (end_time.isBetween(start_block, end_block, null, "()")) ||
                                    (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {
                                */
                                if ((start_time.isBetween(start_block, end_block, null, "()")) ||
                                    (end_time.isBetween(start_block, end_block, null, "()")) ||
                                    (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {

                                    if (block.res_reservation_id !== null) {
                                        table.occupied = true;
                                        table.suggested = false;
                                    } else {
                                        table.block = true;
                                        table.suggested = false;
                                    }
                                } else {
                                    if (block.res_reservation_id !== null) {
                                        table.occupied = false;
                                    } else {
                                        table.block = false;
                                    }
                                }
                            }
                        });
                    });
                });

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        if (cant >= table.minCover && cant <= table.maxCover && !table.class.name) {
                            if (!table.occupied && !table.block) {
                                table.suggested = true;
                            }
                        }
                    });
                });
            },
            tableFilterClear: function(zones) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.occupied = false;
                        if (!table.blockStatic) table.block = false;
                        table.suggested = false;
                    });
                });
            },
            makeTimeSeated: function(zones, blocks, reservations) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.timeSeated = null;
                    });
                });
                angular.forEach(reservations, function(reservation) {
                    angular.forEach(blocks, function(block) {
                        if (reservation.id == block.res_reservation_id) {
                            angular.forEach(zones, function(zone) {
                                angular.forEach(zone.tables, function(table) {
                                    if (table.id == block.res_table_id) {
                                        console.log(table.id, block.res_table_id);
                                        if (reservation.datetime_input && reservation.datetime_output) {
                                            console.log("1");
                                        } else if (reservation.datetime_input) {
                                            var now = moment();
                                            var input = moment(reservation.datetime_input);
                                            table.timeSeated = moment.utc(now.diff(input)).format("HH:mm");
                                            console.log("2");
                                        }
                                    }
                                });
                            });
                        }
                    });
                });
            },
            isEditServer: function(value) {
                if (value || value === false) {
                    flag.editServer = value;
                }
                return flag.editServer;
            },
            setNavegationTabZone: function(value) {
                navegaTabZone = value;
            },
            getNavegationTabZone: function() {
                return navegaTabZone;
            },
            setDataZonesTables: function(zones) {
                zonesTotal = zones;
            },
            getDataZonesTables: function() {
                return zonesTotal;
            },
            listTableServes: function() {
                var defered = $q.defer();
                ServerFactory.getAllTablesFromServer().success(function(data) {
                    var vTables = [];
                    angular.forEach(data.data, function(server) {
                        var tables = server.tables;
                        angular.forEach(tables, function(table) {
                            var dataTable = {
                                server_id: server.id,
                                color: server.color,
                                table_id: table.id
                            };
                            vTables.push(dataTable);
                        });
                    });

                    defered.resolve(vTables);
                }).error(function(data, status, headers) {
                    defered.reject(data);
                });
                return defered.promise;
            },
            //Todas las zonas con sus mesas y mas informacion //No se esta utilizando --verificar
            /*
            listZonesReservas: function() {
                var me = this;
                var defered = $q.defer();
                var fecha_actual = getFechaActual();
                reservationService.getZones(fecha_actual).success(function(data) {
                    console.log("zonas");
                    console.log(data.data);
                    return data;
                }).error(function(data) {
                    defered.reject(data);
                }).then(function(zonesData) {
                    me.listBloqueos().then(function success(response) {
                        console.log("blocks");
                        console.log(response);
                        return response;
                    }, function error(response) {
                        return response;
                    }).then(function success(blocks) {

                        me.listTableServes().then(function success(server) {
                            console.log("servers");
                            console.log(server);
                            return server;
                        }, function error(server) {
                            return server;
                        }).then(function success(servers) {

                            var vZones = [];
                            angular.forEach(zonesData.data.data, function(zone) {
                                console.log("------------------------------------------");
                                var tables = zone.tables;
                                var vTables = [];
                                angular.forEach(tables, function(table) {
                                    var position = table.config_position.split(",");
                                    var dataTable = {
                                        zone_id: zone.id,
                                        name_zona: zone.name,
                                        table_id: table.id,
                                        name: table.name,
                                        minCover: table.min_cover,
                                        maxCover: table.max_cover,
                                        left: position[0],
                                        top: position[1],
                                        shape: TableFactory.getLabelShape(table.config_forme),
                                        size: TableFactory.getLabelSize(table.config_size),
                                        rotate: table.config_rotation,
                                        price: table.price,
                                    };
                                    angular.forEach(blocks, function(block) {
                                        //console.log(blocks);
                                        if (block.table_id === table.id) {
                                            console.log("block", table, block);
                                            dataTable.res_reservation_status_id = block.res_reservation_status_id;
                                            dataTable.reservation_id = block.reservation_id;
                                        }
                                    });
                                    angular.forEach(servers, function(server) {
                                        //console.log(blocks);
                                        if (server.table_id === table.id) {
                                            console.log("server", table, server);
                                            dataTable.server_id = server.server_id;
                                            dataTable.color = server.color;
                                        }
                                    });
                                    vTables.push(dataTable);
                                });
                                var dataZone = {
                                    zone_id: zone.id,
                                    name: zone.name,
                                    table: vTables,
                                };
                                vZones.push(dataZone);
                            });

                            defered.resolve(vZones);

                        }, function error(server) {
                            defered.reject(server);
                        });

                    }, function error(response) {
                        defered.reject(response);
                    });

                });
                return defered.promise;
            },*/
            listTurnosActivos: function(date, reload) {
                var defered = $q.defer();
                var self = this;

                reload = (reload === undefined) ? false : reload;

                if (turns_notes && reload === false) {
                    defered.resolve(turns_notes);
                    return defered.promise;
                }

                CalendarService.GetShiftByDate(date).then(
                    function success(response) {
                        var typeTurnsData = response.data.data;
                        var turns = [];

                        NoteFactoryData.getAll(date).then(
                            function success(response) {
                                response = response.data.data;
                                response = self.listNotesTypeTurn(response, typeTurnsData);
                                turns_notes = response;
                                defered.resolve(response);
                            },
                            function error(response) {
                                defered.reject(response);
                            });
                    },
                    function error(response) {
                        defered.reject(response);
                    }
                );

                return defered.promise;
            },
            listNotesTypeTurn: function(notes, turns) {
                angular.forEach(turns, function(turn, key) {
                    angular.forEach(notes, function(note, key) {
                        if (note.res_type_turn_id == turn.id) {
                            turn.notes = note;
                        }
                    });
                });
                return turns;
            },
            createNotes: function(data) {
                var defered = $q.defer();

                NoteFactoryData.create(data).then(
                    function success(response) {
                        defered.resolve(response.data);
                    },
                    function error(response) {
                        defered.reject(response.data);
                    }
                );
                return defered.promise;
            },
            setServicioReservaciones: function(data) {
                reservasAndBlocks = data;
            },
            getServicioReservaciones: function() {
                var me = this;
                var defered = $q.defer();
                if (reservasAndBlocks.length === 0) {

                    me.getReservations().then(function(data) {
                        reservasAndBlocks = data;
                        //console.log(reservasAndBlocks);
                        defered.resolve(reservasAndBlocks);
                        //return reservasAndBlocks;
                    });

                } else {
                    defered.resolve(reservasAndBlocks);
                    //return reservasAndBlocks;
                }
                return defered.promise;
            },
            addServicioReservaciones: function(item) {
                // console.log("addServicioReservaciones1 " + angular.toJson(reservasAndBlocks, true));
                //console.log('Array actual', angular.toJson(reservasAndBlocks, true));
                //If existe en el array reservasAndBlocks diferente de 0
                if (reservasAndBlocks.length !== 0) {
                    var encontrado = false;
                    angular.forEach(reservasAndBlocks, function(reserva, index) {
                        if (item.reservation_id == reserva.reservation_id) {
                            reservasAndBlocks.splice(index, 1);
                            reservasAndBlocks.push(item);
                            //reservasAndBlocks[index] = item;
                            encontrado = true;
                            return;
                        }
                    });
                    if (encontrado === false) {
                        reservasAndBlocks.push(item);
                    }
                } else {
                    reservasAndBlocks.push(item);
                }
                // console.log("addServicioReservaciones " + angular.toJson(reservasAndBlocks, true));
            },
            parseDataReservation: function(reserva) {
                var me = this;
                var reservationData = {
                    reservation_id: reserva.id,
                    res_type_turn_id: reserva.res_type_turn_id,
                    res_source_type_id: reserva.res_source_type_id,
                    res_guest_id: reserva.res_guest_id,
                    res_reservation_status_id: reserva.res_reservation_status_id,
                    wait_list: reserva.wait_list,
                    zone_indice: '',
                    start_date: reserva.date_reservation,
                    start_time: reserva.hours_reservation,
                    end_time: plusHour(reserva.hours_reservation, reserva.hours_duration),
                    num_people: reserva.num_guest,
                    num_people_1: reserva.num_people_1 ? reserva.num_people_1 : 0,
                    num_people_2: reserva.num_people_2 ? reserva.num_people_2 : 0,
                    num_people_3: reserva.num_people_3 ? reserva.num_people_3 : 0,
                    tables: reserva.tables,
                    source: reserva.source,
                    status: reserva.status,
                    tags: reserva.tags,
                    type_turn: reserva.type_turn,
                    first_name: reserva.guest ? reserva.guest.first_name : "Reservacion sin nombre",
                    last_name: reserva.guest ? reserva.guest.last_name : "",
                    guest: reserva.guest,
                    note: reserva.note
                };

                if (reserva.wait_list === 0) {
                    reservationData.zone_indice = reserva.tables ? me.getIndiceZone(reserva.tables[0].res_zone_id) : "";
                } else {
                    reservationData.quote = reserva.quote;
                }

                return reservationData;
            },
            getBlocksForReservation: function() {
                var defered = $q.defer();
                var me = this;
                FloorDataFactory.getBloqueos().then(function success(response) {
                    response = response.data.data;
                    var blockTables = [];
                    var dato;
                    angular.forEach(response, function(block) {
                        blockTables.push({
                            block_id: block.id,
                            start_time: block.start_time,
                            end_time: block.end_time,
                            start_date: block.start_date,
                            zone_indice: block.tables ? me.getIndiceZone(block.tables[0].res_zone_id) : "",
                            tables: block.tables,
                            events: [],
                            block: false,
                        });
                    });
                    defered.resolve(blockTables);
                }, function error(response) {
                    response = response.data;
                    defered.reject(response);
                });

                return defered.promise;
            },
            mergeBlockToReservation: function(blocks) {

                if (reservasAndBlocks.length !== 0) {
                    var encontrado = false;
                    angular.forEach(reservasAndBlocks, function(reserva, index) {
                        angular.forEach(blocks, function(item) {
                            if (item.block_id == reserva.block_id) {
                                reservasAndBlocks.splice(index, 1);
                                reservasAndBlocks.push(item);
                                //reservasAndBlocks[index] = item;
                                encontrado = true;
                                return;
                            }
                        });
                    });
                    if (encontrado === false) {
                        angular.forEach(blocks, function(item) {
                            reservasAndBlocks.push(item);
                        });
                    }
                } else {
                    angular.forEach(blocks, function(item) {
                        reservasAndBlocks.push(item);
                    });
                }

                /*angular.forEach(blocks, function(item) {
                    reservasAndBlocks.push(item);
                });*/
            },
            parseDataBloqueos: function(block) {
                var me = this;
                var blockData = {
                    block_id: block.id,
                    start_time: block.start_time,
                    end_time: block.end_time,
                    start_date: block.start_date,
                    zone_indice: block.tables ? me.getIndiceZone(block.tables[0].res_zone_id) : "",
                    tables: block.tables,
                    events: [],
                    block: false,
                };
                return blockData;
            },
            addServicioReservacionesAndBloqueos: function(item) {
                //console.log('Array actual', angular.toJson(reservasAndBlocks, true));
                //If existe en el array reservasAndBlocks diferente de 0
                if (reservasAndBlocks.length !== 0) {
                    var encontrado = false;
                    angular.forEach(reservasAndBlocks, function(reserva, index) {
                        if (item.block_id == reserva.block_id) {
                            reservasAndBlocks.splice(index, 1);
                            reservasAndBlocks.push(item);
                            //reservasAndBlocks[index] = item;
                            encontrado = true;
                            return;
                        }
                    });
                    if (encontrado === false) {
                        reservasAndBlocks.push(item);
                    }
                } else {
                    reservasAndBlocks.push(item);
                }
            },
            getConfiguracionPeople: function(item) {
                var defered = $q.defer();

                reservationService.getConfigurationRes().then(function success(response) {
                        response = response.data.data;
                        defered.resolve(response);
                    },
                    function error(response) {
                        defered.reject(response.data);
                    }
                );
                return defered.promise;
            },
        };
    })
    //Calculo numero de personas en modal
    .factory('OperationFactory', function() {
        return {
            setNumPerson: function(numperson, tipo, value) {
                if (tipo == 'men') {
                    numperson.men = value;
                }
                if (tipo == 'women') {
                    numperson.women = value;
                }
                if (tipo == 'children') {
                    numperson.children = value;
                }
            },
            getTotalPerson: function(numperson) {
                var total = parseInt(numperson.men) + parseInt(numperson.women) + parseInt(numperson.children);
                return total;
            }
        };
    })
    .factory('ServerDataFactory', function($q, ServerFactory) {
        var tableColection = [];
        var serverColection = [];
        var colorColection = [];
        var interfazServer = {
            getTableServerItems: function() {
                return tableColection;
            },
            setTableServerItems: function(tableItem) {
                tableColection.push({
                    id: tableItem.id,
                    name: tableItem.name
                });
            },
            setTableServerItemsEdit: function(tableItem) {
                tableColection = tableItem;
            },
            delTableServerItem: function(tableItem) {
                angular.forEach(tableColection, function(value, key) {
                    if (value.id == tableItem.id) {
                        tableColection.splice(key, 1);
                    }
                });
            },
            delTableServerItemIndex: function(index) {
                tableColection.splice(index, 1);
            },
            cleanTableServerItems: function() {
                tableColection = [];
            },
            getServerItems: function() {
                return serverColection;
            },
            setServerItems: function(serverItem) {
                serverColection.length = 0;
                serverColection = serverItem;
            },
            addServerItems: function(serverItem) {
                serverColection.push(serverItem);
            },
            delServerItem: function(serverItem) {
                angular.forEach(serverColection, function(value, key) {
                    if (value.id == serverItem.id) {
                        serverColection.splice(key, 1);
                    }
                });
            },
            updateServerItems: function(serverItem) {
                angular.forEach(serverColection, function(value, key) {
                    if (value.id == serverItem.id) {
                        value.name = serverItem.name;
                        value.color = serverItem.color;
                        value.tables = serverItem.tables;
                    }
                });
            },
            getColorItems: function() {
                return colorColection;
            },
            setColorItems: function(colorItem) {
                colorColection.push(colorItem);
            },
            listadoServers: function() {
                var defered = $q.defer();
                ServerFactory.getAllTablesFromServer().success(function(data) {
                    defered.resolve(data.data);
                }).error(function(data, status, headers) {
                    defered.reject(data);
                });
                return defered.promise;
            }
        };
        return interfazServer;
    });
angular.module('server.service', [])
    .factory('ServerFactory', function($http, HttpFactory, ApiUrlMesas, $q) {
        var servers;
        return {
            getAllTablesFromServer: function(reload) {
                servers = HttpFactory.get(ApiUrlMesas + "/servers", null, servers, reload);
                return servers;
            },
            addServer: function(data) {
                return $http({
                    url: ApiUrlMesas + "/servers",
                    method: "POST",
                    data: data
                });
            },
            updateServer: function(data, id_server) {
                return $http({
                    url: ApiUrlMesas + "/servers/" + id_server,
                    method: "PUT",
                    data: data
                });
            },
            deleteServer: function(id_server) {
                return $http({
                    url: ApiUrlMesas + "/servers/" + id_server,
                    method: "DELETE"
                });
            },
        };
    })
    .factory('ColorFactory', function() {
        return {
            getColor: function() {
                return [{
                    hex: "#9F7421"
                }, {
                    hex: "#82d1d3"
                }, {
                    hex: "#7c004c"
                }, {
                    hex: "#e176ce"
                }, {
                    hex: "#7e3c91"
                }, {
                    hex: "#b30011"
                }, {
                    hex: "#1e9084"
                }, {
                    hex: "#ffffe8"
                }, {
                    hex: "#eead00"
                }, {
                    hex: "#ff6138"
                }, {
                    hex: "#007fff"
                }, {
                    hex: "#ffc4b5"
                }, {
                    hex: "#a9d4ff"
                }, {
                    hex: "#30c6bd"
                }, {
                    hex: "#5fefe7"
                }, {
                    hex: "#ffc26b"
                }, {
                    hex: "#00aeef"
                }, {
                    hex: "#cdc3ff"
                }, {
                    hex: "#9be4ff"
                }, {
                    hex: "#aa0d71"
                }, {
                    hex: "#e891d7"
                }, {
                    hex: "#fc00ff"
                }, {
                    hex: "#901eac"
                }, {
                    hex: "#c41200"
                }, {
                    hex: "#ffffff"
                }, {
                    hex: "#2c3e50"
                }, {
                    hex: "#ab7714"
                }, {
                    hex: "#755e33"
                }, {
                    hex: "#83ff5a"
                }, {
                    hex: "#2085d8"
                }];
            },
        };
    });
angular.module('grid.app', ['grid.controller', 'grid.service', 'grid.directive'])
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.grid', {
                url: '/grid',
                views: {
                    "@": {
                        controller: 'GridCtrl',
                        controllerAs: 'vm',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Grid';
                    }
                }
            })
            .state('mesas.grid.index', {
                url: '/:date/:shift',
                views: {
                    "@": {
                        templateUrl: '/js/app/tables/grid/view/parent.html',
                        controller: 'GridNotificationCtrl'
                    },
                    'index@mesas.grid.index': {
                        templateUrl: '/js/app/tables/grid/view/index.html',
                        controller: 'GridMainCtrl',
                        controllerAs: 'vm'
                    },
                }
            });

    });
angular.module('grid.controller', [])
    .controller('GridCtrl', function($scope, $state, gridDataFactory, gridFactory) {
        var vm = this;
        vm.turns = []; //Listado de turnos activos segun fecha
        vm.fecha_actual = moment().format('YYYY-MM-DD');

        var getTurnsActives = function() {
            gridDataFactory.getTurnsActives(vm.fecha_actual, true).then(
                function success(response) {
                    vm.turns = gridFactory.parseShiftsActives(response);
                    var turnSelected = detectedTurnNow(vm.turns);

                    $state.go("mesas.grid.index", {
                        date: vm.fecha_actual,
                        shift: turnSelected.name,
                    });
                },
                function error(response) {
                    console.error("getTurnsActives", angular.toJson(response, true));
                }
            );
        };

        //Detecta el turno en el que se encuentra actualmente
        var detectedTurnNow = function(turns) {
            var turnSelected = {};
            var timeNow = moment().format("HH:mm:ss");
            var dateNow = moment().format("YYYY-MM-DD");

            angular.forEach(turns, function(turn, key) {

                var nextDay = getHourNextDay(turn.turn.hours_ini, turn.turn.hours_end);
                var dateNowEnd = (nextDay === 1) ? moment(dateNow).add('days', 1).format('YYYY-MM-DD') : dateNow;

                if (moment(dateNow + " " + timeNow).isSameOrAfter(dateNow + " " + turn.turn.hours_ini) && moment(dateNow + " " + timeNow).isSameOrBefore(dateNowEnd + " " + turn.turn.hours_end)) {
                    turnSelected = turn;
                }
            });

            return turnSelected;
        };

        var init = function() {
            getTurnsActives();
        };

        init();
    })
    .controller('GridMainCtrl', function($scope, $stateParams, $location, $state, $uibModal, $document, $compile, $timeout, gridDataFactory, gridFactory, FloorFactory, reservationService) {

        var vm = this;

        var openModalReserva = null;
        var timeoutNotes;

        //para la directiva currentTime Linea de tiempo 
        vm.currentTime = {
            text: '',
            left: ''
        };

        //Datos para renderizar grid de creacion de reserva
        vm.reservationCreate = {
            hourText: '',
            hourIni: '',
            hourEnd: '',
            index: null,
            timeTotal: [],
            table: null
        };

        vm.tempData = {
            hourIni: '',
            index: null
        };

        //End Datos para renderizar grid de creacion de reserva

        vm.tablesAvailability = [];
        vm.turns = []; //Listado de turnos activos segun fecha
        vm.fecha_actual = moment().format('YYYY-MM-DD');
        vm.fecha_selected = {
            date: moment(vm.fecha_actual),
            text: ''
        };

        //Calendario, footer grid
        vm.btnCalendarShift = {
            turns: [],
            turn_selected: {},
            date_text: '',
            coversReserva: 0
        };

        //Informacion general para el grid (reservaciones,bloqueos,disponibilidad,config,etc)
        vm.gridData = {};
        //Listado de horas segun turno (se actualiza cuando cambias el turno)
        vm.timesShift = [];
        //Listado de disponibilidad segun mesa(contendra reservas,bloqueos,bloqueos de turnos,etc)
        vm.tablesAvailabilityFinal = [];

        //Drag de la reservacion
        vm.reservaDrag = {
            position: {},
            table: '',
            table_update: '',
            newTime: '',
            reserva: {}
        };

        //Drag del bloqueo
        vm.blockDrag = {
            position: {},
            block: {},
            newTime: '',
            table: '',
            table_update: '',
            duration: ''
        };

        //Notas del turno
        vm.turnsNotes = [];
        vm.notesData = {
            texto: '',
            res_type_turn_id: ''
        };

        vm.notesBox = false;
        vm.notesBoxValida = false;

        //Width Lienzo Body para manejo del scroll
        vm.gridLienzo = {
            width: ''
        };

        var init = function() {
            initCalendarSelectedShift();
            getDataGrid();
        };

        vm.onDragEndReservation = function() {
            vm.reservaDrag.newTime = getTimeByPosicionGrid(vm.reservaDrag.position.left);

            if (vm.reservaDrag.table !== "") {
                var dataReservation = constructDataUpdate(vm.reservaDrag, "reserva");
                updateReservationGrid(dataReservation);
                console.log("onDragEndReservation", angular.toJson(dataReservation, true));
            }
        };

        vm.onDragEndBlock = function() {
            vm.blockDrag.newTime = getTimeByPosicionGrid(vm.blockDrag.position.left);
            var dataBlock = constructDataUpdate(vm.blockDrag, "block");
            updateBlockGrid(dataBlock);
        };

        vm.selectTimeReservationCreate = function(type, hour, index, posIni, table) {

            if (type == "init") {
                vm.reservationCreate.table = table;
                vm.reservationCreate.hourIni = hour;
                vm.reservationCreate.hourText = moment("2016-01-01 " + hour).format("H:mm A");
                vm.reservationCreate.index = index;
                vm.tempData.hourIni = hour;
                vm.tempData.index = index;

                angular.element(".cell-item" + index).css("transform", "translateX(" + posIni + "px)");
                angular.element(".cell-item" + index).css("display", "block");

                calculateQuarterHour(posIni);
            }

            if (type == "move" && index === vm.reservationCreate.index) {

                if ((vm.tempData.hourIni !== hour)) {
                    console.log("move", hour, posIni);
                    vm.tempData.hourIni = hour;
                    vm.tempData.hourEnd = hour;
                    vm.tempData.index = index;
                    calculateQuarterHour(posIni);
                }
            }
            //EVALUANDO ESTE CODIGO (POSIBLEMENTE BORRAR)
            /*   if (type === "end") {
                   vm.reservationCreate.hourEnd = hour;
                   calculateQuarterHour(posIni);

                   vm.reservationCreate.hourIni = '';
                   vm.reservationCreate.index = null;
               }*/
        };

        //Grid de reservacion (creacion) incremantar tamaño
        vm.moveQuarterHour = function(value) {
            if (vm.tempData.hourIni !== value.hour && vm.tempData.index === value.index) {
                vm.reservationCreate.hourEnd = vm.tempData.hourEnd;
                calculateQuarterHour(value.posIni);
            }
        };
        //Grid de reservacion (creacion) finalizar tamaño
        vm.moveQuarterUp = function(table) {
            var timeTotal = vm.reservationCreate.timeTotal.length;
            vm.reservationCreate.hourEnd = vm.reservationCreate.timeTotal[timeTotal - 1].hour;
            vm.reservationCreate.table = table;
            //openModalCreateReserva(table);
        };

        vm.selectedDate = function() {
            vm.fecha_selected.text = moment(vm.fecha_selected.date).format('YYYY-MM-DD');
            _setUrlReload(vm.btnCalendarShift.turn_selected.name);
        };

        vm.selectedShift = function(shift) {
            vm.btnCalendarShift.turn_selected = shift;
            _setUrlReload(vm.btnCalendarShift.turn_selected.name);
        };

        vm.prevDateCalendarShift = function() {
            var validaJson = angular.toJson(vm.gridData);
            if (validaJson.indexOf("shifts") !== -1) {
                var date = moment(vm.fecha_selected.text).subtract(1, 'days').format('YYYY-MM-DD');
                vm.fecha_selected.text = date;
                _setUrlReload(null);
            }
        };

        vm.nextDateCalendarShift = function() {
            var validaJson = angular.toJson(vm.gridData);
            if (validaJson.indexOf("shifts") !== -1) {
                var date = moment(vm.fecha_selected.text).add(1, 'days').format('YYYY-MM-DD');
                vm.fecha_selected.text = date;
                _setUrlReload(null);
            }
        };

        vm.closeModal = function() {
            angular.element(".cell-item" + vm.reservationCreate.index).css("display", "none");
            openModalReserva = null;
            vm.reservationCreate.index = null;
            vm.reservationCreate.hourIni = "";
            vm.reservationCreate.hourEnd = "";
            vm.reservationCreate.timeTotal = [];
            vm.reservationCreate.table = null;
        };
        //Lista de reservaciones en conflicto
        vm.conflictPopup = function(conflictIni, reserva, reservations) {
            if (conflictIni === undefined || conflictIni === false) {
                openModalConflictReserva(reserva, reservations);
            } else {
                vm.redirectReservation(reserva);
            }
        };

        vm.redirectReservation = function(reserva) {
            if (vm.reservaDrag.table === '') {
                $state.go("mesas.grid-reservation-edit", {
                    date: vm.fecha_selected.text,
                    id: reserva.id
                });
            }
        };

        vm.redirectBlock = function(block) {
            if (vm.blockDrag.table === '') {
                $state.go("mesas.grid.block.edit", {
                    date: vm.fecha_selected.text,
                    block_id: block.id
                });
            }
        };

        //Tiempo transcurrido en reservaciones sentadas con la directiva currentTime
        vm.updateCurrentTime = function() {
            angular.forEach(vm.tablesAvailabilityFinal, function(tables, key) {
                angular.forEach(tables.reservations, function(reservation, key) {
                    reservation = gridFactory.currentTimeReservaSit(reservation, vm.btnCalendarShift.turn_selected.turn);
                });
            });
        };

        vm.saveNotes = function(turn) {

            if (timeoutNotes) $timeout.cancel(timeoutNotes);

            vm.notesData.id = turn.notes.id;
            vm.notesData.res_type_turn_id = turn.id;
            vm.notesData.texto = turn.notes.texto;
            vm.notesData.date_add = turn.notes.date_add;

            timeoutNotes = $timeout(function() {
                reservationService.blackList.key(vm.notesData);
                FloorFactory.createNotes(vm.notesData).then(
                    function success(response) {
                        vm.notesSave = true;
                    },
                    function error(response) {
                        message.apiError(response);
                    }
                );
            }, 1000);
        };

        vm.readNotes = function(notification) {
            vm.notesBoxValida = true;
            vm.notesNotification = false;
        };

        vm.listenNotes = function(notification) {
            vm.notesBoxValida = false;
            vm.notesNotification = false;
        };

        var updateReservationGrid = function(data) {
            gridDataFactory.updateReservation(data, data.reservation.id).then(
                function success(response) {
                    vm.reservaDrag.table_update = "";
                    vm.reservaDrag.table = "";
                },
                function error(response) {
                    console.error("updateReservationGrid", response);
                }
            );
        };

        var updateBlockGrid = function(data) {
            gridDataFactory.updateBlock(data, data.block.id).then(
                function success(response) {
                    vm.blockDrag.table_update = "";
                    vm.blockDrag.table = "";
                },
                function error(response) {
                    console.error("updateBlockGrid", response);
                }
            );
        };

        var constructDataUpdate = function(params, option) {
            var data = {
                tables_add: [],
                tables_deleted: []
            };

            var tables = null;

            if (option === "reserva") {
                data.reservation = {
                    id: params.reserva.id,
                    hours_reservation: params.newTime
                };
                tables = params.reserva.tables;
            } else {
                var blockDurations = vm.blockDrag.block.durations.split(":");

                data.block = {
                    id: params.block.id,
                    start_time: params.newTime,
                    end_time: moment(vm.blockDrag.block.start_date + " " + vm.blockDrag.newTime).add("hours", blockDurations[0]).add("minutes", blockDurations[1]).format("HH:mm:ss")
                };
                tables = params.block.tables;
            }

            if (params.table !== params.table_update) {
                var existsTable = gridFactory.existsDataInArray(params.table_update, tables);
                if (existsTable === false) {
                    data.tables_add.push(params.table_update);
                }
                data.tables_deleted.push(params.table);
            }

            return data;
        };
        //Obtiene la hora segun la posicion en el grid
        var getTimeByPosicionGrid = function(positionGrid) {
            var time = "";

            angular.forEach(vm.tablesAvailabilityFinal[0].availability, function(availability, key) {
                if (positionGrid === availability.position_grid) {
                    time = availability.time;
                }
            });

            return time;
        };

        var openModalConflictReserva = function(reservaSelected, reservations) {
            $uibModal.open({
                templateUrl: 'ModalConflictReservation.html',
                controller: 'ModalGridReservationConflictCtrl',
                controllerAs: 'vm',
                keyboard: false,
                size: '',
                resolve: {
                    ctrlMain: function() {
                        return vm;
                    },
                    reservaSelected: function() {
                        return reservaSelected;
                    },
                    reservations: function() {
                        return reservations;
                    }
                }
            }).result.catch(function() {

            });
        };

        var openModalCreateReserva = function(table) {
            openModalReserva = $uibModal.open({
                templateUrl: 'ModalCreateGridReservation.html',
                controller: 'ModalGridReservationCtrl',
                controllerAs: 'br',
                keyboard: false,
                size: '',
                resolve: {
                    date: function() {
                        return vm.fecha_selected.text;
                    },
                    table: function() {
                        return table;
                    },
                    hourReservation: function() {
                        return vm.reservationCreate;
                    },
                    ctrlMain: function() {
                        return vm;
                    }
                }
            }).result.catch(function() {
                vm.closeModal();
            });
        };

        var getDataGrid = function() {
            var params = {
                date: vm.fecha_selected.text
            };
            gridDataFactory.getGrid(params).then(
                function success(response) {
                    vm.gridData = response.data.data;
                    vm.tablesAvailability = vm.gridData.availabilityTables;

                    vm.turns = gridFactory.parseShiftsActives(vm.gridData.shifts);
                    vm.turnsNotes = vm.gridData.shifts;
                    vm.btnCalendarShift.turns = gridFactory.parseShiftsActives(vm.gridData.shifts);

                    if (vm.gridData.turns.length > 0) {
                        setSelectedShift($stateParams.shift);
                    }

                    constructCurrentTime();
                },
                function error(response) {
                    console.error("getDataGrid", angular.toJson(response.data, true));
                }
            );
        };

        //Habilita la directiva currentTime , si existe turno para el dia
        var constructCurrentTime = function() {
            var validate = angular.toJson(vm.btnCalendarShift.turn_selected);

            if (validate.indexOf('turn') !== -1) {

                var directiveCurrentime = '<current-time left-time="vm.currentTime.left" turn="vm.btnCalendarShift.turn_selected" update-time="vm.updateCurrentTime()">' +
                    '</current-time>';

                var content = $compile(directiveCurrentime)($scope);

                angular.element(".grid-inner-container").append(content);
            }
        };

        //Construye el grid
        var constructTablesAvailability = function() {
            var availabilityTables = [];
            angular.forEach(vm.tablesAvailability, function(table, key) {
                var availability = gridFactory.constructAvailability(table.availability, vm.btnCalendarShift.turn_selected);
                var reservations = gridFactory.getReservationsByTable(table, vm.gridData.reservations, availability, key, vm.btnCalendarShift.turn_selected.turn);
                var blocks = gridFactory.getBlocksByTable(table, vm.gridData.blocks, availability, key);

                availabilityTables.push({
                    id: table.id,
                    name: table.name,
                    min_cover: table.min_cover,
                    max_cover: table.max_cover,
                    availability: availability,
                    reservations: reservations,
                    blocks: blocks
                });
            });

            vm.tablesAvailabilityFinal = availabilityTables;
            vm.btnCalendarShift.coversReserva = gridFactory.totalCoversReservations(vm.tablesAvailabilityFinal);
            vm.gridLienzo.width = (vm.tablesAvailabilityFinal[0].availability.length * 62) + 2;
        };

        var initCalendarSelectedShift = function() {
            var date = ($stateParams.date === undefined) ? vm.fecha_actual : $stateParams.date;
            vm.fecha_selected.text = date;
            vm.fecha_selected.date = moment(date);
        };
        //Actualiza el grid al seleccionar un turno
        var setSelectedShift = function(shiftName) {
            var turnSelected = gridFactory.setActiveShiftSelected(shiftName, vm.btnCalendarShift.turns);
            if (turnSelected === null) {
                vm.btnCalendarShift.turns[0].active = true;
                _setUrlReload(null);
            } else {
                vm.btnCalendarShift.turn_selected = turnSelected;
            }
            vm.timesShift = gridFactory.getRangoHoursShift(vm.btnCalendarShift.turn_selected);
            constructTablesAvailability();
        };

        var _setUrlReload = function(shiftName) {
            if (vm.gridData.turns.length > 0) {
                shiftName = (shiftName === null) ? vm.btnCalendarShift.turns[0].name : shiftName;
            } else {
                shiftName = $stateParams.shift;
            }
            $state.go("mesas.grid.index", {
                date: vm.fecha_selected.text,
                shift: shiftName
            }, {
                reload: true
            });
        };

        //Calcula la posicion donde se ubica la reserva en el grid y el total de tiempo
        var calculateQuarterHour = function(posIni) {
            console.log("calculateQuarterHour", posIni);
            posIni = parseInt(posIni);
            /*var total = (posIni === 0) ? 0 : posIni / 62;
            total = (total === 0) ? 1 : total;*/
            var indexPos = getPosIni(posIni);
            if (indexPos === -1) {
                vm.reservationCreate.timeTotal.push({
                    posIni: posIni, //posicion en la columna de la matriz del grid
                    hour: vm.tempData.hourIni,
                    index: vm.tempData.index //posicion en la fila de la matriz del grid
                });
            } else {
                vm.reservationCreate.timeTotal.splice(indexPos + 1, 1);
            }
        };

        //Comprueba que la reservacion ya ocupa la casilla en la columna -> posIni
        var getPosIni = function(posIni) {
            var total = vm.reservationCreate.timeTotal.length;
            var index = -1;

            for (var i = 0; i < total; i++) {
                if (vm.reservationCreate.timeTotal[i].posIni === posIni) {
                    return i;
                }
            }
            return index;
        };

        $scope.$on("NotifyNewReservation", function(evt, data) {

            $scope.$apply(function() {
                var reservation = (data.action === "create") ? data.data : data.data[0];

                if (reservation.date_reservation === vm.fecha_selected.text) {
                    gridFactory.addReservationTableGrid(vm.tablesAvailabilityFinal, reservation, data.action, vm.btnCalendarShift.turn_selected);
                    vm.btnCalendarShift.coversReserva = gridFactory.totalCoversReservations(vm.tablesAvailabilityFinal);
                }
            });
        });

        $scope.$on("NotifyNewBlock", function(evt, data) {
            $scope.$apply(function() {
                var block = data.data[0];

                if (block.start_date === vm.fecha_selected.text) {
                    gridFactory.addBlockTableGrid(vm.tablesAvailabilityFinal, block, data.action);
                }

            });
        });

        $scope.$on("floorNotesReload", function(evt, note) {
            if (!reservationService.blackList.contains(note.key)) {
                angular.forEach(vm.turnsNotes, function(typeTurn) {
                    if (typeTurn.turn) {
                        if (note.data.res_type_turn_id == typeTurn.turn.res_type_turn_id) {
                            typeTurn.notes = typeTurn.notes ? typeTurn.notes : {};
                            typeTurn.notes.texto = note.data.texto;
                        }
                    }
                });

                if (!vm.notesBoxValida) {
                    vm.notesNotification = true;
                }

                $scope.$apply();
            }
        });

        //Para disparar el popup de reservacion ->creación
        $document.on('mouseup', function() {
            if (vm.reservationCreate.hourIni !== '' && openModalReserva === null) {
                vm.reservationCreate.hourEnd = (vm.reservationCreate.hourEnd === '') ? vm.tempData.hourEnd : vm.reservationCreate.hourEnd;
                console.log("onDragEndReservation", angular.toJson(vm.reservationCreate.timeTotal, true));
                openModalCreateReserva(vm.reservationCreate.table);
            }
        });

        init();
    })
    .controller("ModalGridReservationCtrl", function($rootScope, $state, $uibModalInstance, $q, reservationService,
        reservationHelper, $timeout, ctrlMain, table, hourReservation, date, FloorFactory, global, $table) {

        var vm = this;
        var auxiliar;

        vm.reservation = {};
        vm.reservation.status_id = 1;
        vm.reservation.tables = [];
        vm.addGuest = true;
        vm.buttonText = 'Agregar a lista de espera';
        vm.title = "Nueva entrada";
        vm.covers = [];
        vm.guestList = [];
        vm.waitingResponse = false;

        var tables, blocks;

        var listGuest = function() {
            var covers = [];
            for (var i = table.min_cover; i <= table.max_cover; i++) {
                var text = (i == 1) ? "Invitado" : "Invitados";
                covers.push({
                    id: i,
                    name: i + " " + text
                });
            }
            vm.covers = covers;
            vm.reservation.covers = vm.covers[0].id;
        };

        var parseInfoReservation = function() {
            date = date ? moment(date).format("YYYY-MM-DD") : moment().format("YYYY-MM-DD");
            vm.info = {
                date: moment(date).format("dddd, MM/DD"),
                dateFinal: date,
                time: hourReservation.hourIni,
                tableName: table.name
            };
            addTableReservation(table);
            // hourReservation.hourIni = moment(date + " " + hourReservation.hourIni).add("minutes", 15).format("HH:mm:ss");
            hourReservation.hourEnd = moment(date + " " + hourReservation.hourEnd).add("minutes", 15).format("HH:mm:ss");
            vm.reservation.duration = calculateDuration(hourReservation.hourIni, hourReservation.hourEnd);
        };

        var addTableReservation = function(table) {
            vm.reservation.tables.push(table.id);
        };

        var prepareDataSave = function() {
            vm.reservation.date = vm.info.dateFinal;
            vm.reservation.hour = vm.info.time;

            if (!vm.reservation.guest_id) {
                if (vm.newGuest) {
                    delete vm.reservation.guest_id;
                    vm.reservation.guest = vm.newGuest;
                }
            } else {
                delete vm.reservation.guest;
            }

            vm.reservation.guest = vm.newGuest;
        };

        var init = function() {
            parseInfoReservation();
            listGuest();
        };

        vm.save = function() {
            prepareDataSave();

            vm.waitingResponse = true;
            reservationService.blackList.key(vm.reservation);
            reservationService.save(vm.reservation).then(
                function success(response) {
                    vm.waitingResponse = false;
                    message.success(response.data.msg);
                    $uibModalInstance.dismiss('cancel');
                },
                function error(error) {
                    vm.waitingResponse = false;
                    message.apiError(error);
                });
        };

        vm.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        //Search guest list
        vm.searchGuest = function(name) {
            if (auxiliar) $timeout.cancel(auxiliar);
            if (!name) {
                vm.guestList.length = 0;
                return;
            }
            var search = function() {
                reservationService.getGuestList(name)
                    .then(function(response) {
                        vm.guestList = response.data.data.data;
                    }).catch(function(error) {
                        message.apiError(error);
                    });
            };

            auxiliar = $timeout(search, 500);
        };

        vm.selectGuest = function(guest) {
            vm.reservation.guest_id = guest.id;
            vm.guest = guest;
            vm.addGuest = false;
        };

        vm.removeGuest = function() {
            vm.reservation.guest_id = null;
            vm.newGuest = null;
            vm.guestList = [];
            vm.addGuest = true;
        };
        //End Search

        init();
    })
    .controller("ModalGridReservationConflictCtrl", function($state, $uibModalInstance, $q, reservations, reservaSelected, ctrlMain) {
        var vm = this;

        vm.reservations = [];

        vm.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        vm.redirectReservation = function(reserva) {
            vm.cancel();
            ctrlMain.redirectReservation(reserva);
        };

        var init = function() {
            vm.reservations = getReservationsConflict(reservaSelected.styles.conflictsData, reservations);
        };

        var getReservationsConflict = function(conflictsData, reservations) {
            var reservationsConflict = [];

            angular.forEach(reservations, function(reserva, key) {
                if (conflictsData.indexOf(reserva.id) !== -1) {
                    reservationsConflict.push(reserva);
                }
            });

            return reservationsConflict;
        };

        init();
    });
angular.module('grid.directive', [])
    //Cuando pasamos el mouse sobre reservaciones con conflictos
    .directive('hoverReservationGrid', function() {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                var zIndex = 0;

                element.on('mouseover', function(event) {
                    event.preventDefault();
                    zIndex = element.attr('z-index');
                    angular.element(this).parent().parent().css('z-index', 120);
                });

                element.on('mouseout', function(event) {
                    event.preventDefault();
                    angular.element(this).parent().parent().css('z-index', zIndex);
                });
            }
        };
    })
    //Mover reservas
    .directive('dragReservaGrid', function() {
        return {
            restrict: 'A',
            scope: {
                reservaSelected: "=",
                reservation: "=",
                dragPosition: "=",
                onDragEnd: "&",
                itemSelected: "=",
                tableSelected: "=",
                conflicts: "=",
                conflictsIni: "="
            },
            link: function(scope, element, attr) {

                element.draggable({
                    grid: [62, 63],
                    cursor: "move",
                    drag: function(event, ui) {},
                    start: function(event, ui) {
                        element.css("transform", "none");
                        element.css("opacity", "0.6");
                        element.css("z-index", "1");

                        scope.$apply(function() {
                            scope.reservaSelected = scope.reservation;
                            scope.tableSelected = scope.itemSelected.id;
                        });
                    },
                    stop: function(event, ui) {
                        element.css("opacity", "1");
                        scope.$apply(function() {
                            scope.dragPosition = ui.position;
                        });
                        scope.onDragEnd();
                    }
                });

                if (scope.conflicts === false || scope.conflictsIni === true) {
                    element.draggable('enable');
                } else {
                    element.draggable('disable');
                }
            }
        };
    })
    //Evaluando funcionalidad (en deshuso)
    .directive('dropReservaGrid', function() {
        return {
            restrict: 'A',
            scope: {
                grid: "=",
            },
            link: function(scope, element, attr) {

                element.droppable({
                    drop: function(event, ui) {
                        //console.log("drop", angular.toJson(scope.grid, true));
                    }
                });
            }
        };
    })
    //Mover bloqueos
    .directive('dragBlockGrid', function() {
        return {
            restrict: 'A',
            scope: {
                block: "=",
                blockSelected: "=",
                itemSelected: "=",
                tableSelected: "=",
                endBlockDrag: "&",
                dragPosition: "="
            },
            link: function(scope, element, attr) {

                element.draggable({
                    grid: [62, 63],
                    cursor: "move",
                    drag: function(event, ui) {},
                    start: function(event, ui) {
                        element.css("transform", "none");
                        element.css("opacity", "0.6");

                        scope.$apply(function() {
                            scope.blockSelected = scope.block;
                            scope.tableSelected = scope.itemSelected.id;
                            console.log("start drag");
                        });
                    },
                    stop: function(event, ui) {
                        element.css("opacity", "1");
                        scope.$apply(function() {
                            scope.dragPosition = ui.position;
                        });
                        scope.endBlockDrag();
                    }
                });
            }
        };
    })
    //Finalizamos el drag de bloqueos o reservaciones
    .directive('dropReservaGridMaster', function() {
        return {
            restrict: 'A',
            scope: {
                grid: "=",
                table: "=",
                tableBlock: "="
            },
            link: function(scope, element, attr) {

                element.droppable({
                    drop: function(event, ui) {
                        scope.$apply(function() {
                            scope.table = scope.grid.id;
                            scope.tableBlock = scope.grid.id;
                        });
                    }
                });
            }
        };
    })
    //Evaluando directiva (sobreado , para crear reservaciones)
    .directive('resizeGridReservation', function() {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                element.resizable({
                    grid: [62, 63],
                    handles: 'e',
                    resize: function(event, ui) {
                        console.log("resize");
                    }
                });
            }
        };
    })
    //Funcionalidad linea de tiempo del grid
    .directive('currentTime', function() {
        return {
            restrict: 'E',
            scope: {
                leftTime: "=",
                time: "=",
                turn: "=",
                updateTime: "&",
                visibility: "@"
            },
            template: '<div class="grid-current-time-marker" id="grid-current-time-marker" ng-style="{left:leftTime,visibility :visibility}">' +
                '<div class="grid-current-time-label">' +
                '{{time}}</div></div>',
            link: function(scope, element, attr) {
                var minutesData = calculateMinutesIni(scope.turn);
                var hourNow = moment().format("HH:mm A");
                var dateNow = moment().format("YYYY-MM-DD");

                scope.leftTime = minutesData.leftTime + "px";
                scope.time = hourNow;

                var intervalTimeDirective = null;

                var updateTime = function() {
                    scope.$apply(function() {
                        scope.leftTime = intervalTime(scope.leftTime);
                        hourNow = moment().format("HH:mm A");
                        scope.time = hourNow;

                        if (moment(dateNow + " " + hourNow).isSameOrAfter(dateNow + " " + scope.turn.turn.hours_end)) {
                            scope.visibility = 'hidden';
                            clearInterval(intervalTimeDirective);
                        }

                        scope.updateTime();
                    });
                };

                if (moment(dateNow + " " + scope.turn.turn.hours_end).isSameOrBefore(dateNow + " " + hourNow)) {
                    scope.visibility = 'hidden';
                } else {
                    setTimeout(function() {
                        updateTime();
                        intervalTimeDirective = setInterval(function() {
                            updateTime();
                        }, 60000);
                    }, minutesData.miliseconds);
                }
            }
        };

        function calculateMinutesIni(turn) {
            var data = {};

            var hourIni = moment().format("HH:mm:ss");
            var dateNow = moment().format("YYYY-MM-DD");
            var hourEnd = turn.turn.hours_ini;
            var minutes = moment(dateNow + " " + hourEnd).format("mm");
            var hours = moment(dateNow + " " + hourEnd).format("HH");
            var duration = moment(dateNow + " " + hourIni).subtract('minutes', minutes).subtract('hours', hours).format("HH:mm:ss");

            var minutesTotal = calculateMinutesTime(dateNow + " " + duration);
            var miliseconds = (60 - moment().format("ss")) * 1000;
            var leftTime = minutesTotal * 4.1333 + (62);
            data = {
                leftTime: leftTime,
                minutes: minutesTotal,
                miliseconds: miliseconds,
                seconds: moment().format("ss")
            };

            return data;
        }

        function intervalTime(leftTime) {
            var onlyNumber = parseInt(leftTime.replace("px", ""));
            onlyNumber += 4.1333;
            leftTime = onlyNumber + "px";
            return leftTime;
        }
    })
    //Funcionalidad del scroll del grid
    .directive('scrollGridBody', function() {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                var oldScrollTop = $(element).scrollTop();
                var oldScrollLeft = $(element).scrollLeft();
                var marginLeft = null;
                var typeScroll = "";

                angular.element("body").css("overflow-y", "hidden");

                element.scroll(function() {
                    typeScroll = ($(this).scrollTop() === 0) ? "horizontal" : "vertical";

                    if (oldScrollTop == $(this).scrollTop()) {
                        typeScroll = "horizontal";
                    } else {
                        typeScroll = "vertical";
                    }

                    oldScrollTop = $(element).scrollTop();
                    oldScrollLeft = $(element).scrollLeft();

                    if (typeScroll === "horizontal") {
                        angular.element("#grid-time-label-out").css("margin-left", -$(this).scrollLeft());
                        angular.element("#grid-current-time-marker").css("margin-left", -$(this).scrollLeft());
                    } else {
                        angular.element("#grid-column-tables-inner").css("margin-top", -$(this).scrollTop());
                    }
                });
            }
        };
    });
angular.module("grid.controller")

.controller('GridNotificationCtrl', function($scope, ServerNotification) {

    var serverSocket = ServerNotification.getConnection();

    serverSocket.on("b-mesas-floor-res", function(data) {
        $scope.$broadcast("NotifyNewReservation", data);
    });

    serverSocket.on("b-mesas-floor-upd-block", function(data) {
        $scope.$broadcast("NotifyNewBlock", data);
    });

    serverSocket.on("b-mesas-floor-notes", function(data) {
        $scope.$broadcast("floorNotesReload", data);
    });


});
angular.module('grid.service', [])
    .factory('gridDataFactory', function($http, $q, TablesDataFactory, FloorFactory, ApiUrlMesas) {

        return {
            getGrid: function(params) {
                return $http.get(ApiUrlMesas + "/web-app/grid", {
                    params: params
                });
            },
            getTurnsActives: function(date, reload) {
                return FloorFactory.listTurnosActivos(date, reload);
            },
            updateReservation: function(data, idReserva) {
                return $http.post(ApiUrlMesas + "/reservations/" + idReserva + "/grid", data);
            },
            updateBlock: function(data, idBlock) {
                return $http.patch(ApiUrlMesas + "/blocks/" + idBlock + "/grid", data);
            }
        };
    })
    .factory('gridFactory', function($q) {

        return {
            //Devuelve los turnos activos
            parseShiftsActives: function(data) {
                var shifts = [];

                angular.forEach(data, function(value, key) {
                    if (value.turn !== null) {
                        shifts.push(value);
                    }
                });

                return shifts;
            },
            //Asigna la propiedad active = true al turno seleccionado (disponible por la url)
            setActiveShiftSelected: function(shiftName, shifts) {
                var shiftData = null;

                angular.forEach(shifts, function(shift, key) {
                    if (shift.name === shiftName) {
                        shift.active = true;
                        shiftData = shift;
                    }
                });

                return shiftData;
            },
            //Devuelve listado de horas con intervalos de 15 minutos para el grid (segun turno)
            getRangoHoursShift: function(shift) {
                var hours = getRangoHours(shift.turn.hours_ini, shift.turn.hours_end, true);

                angular.forEach(hours, function(hour, key) {
                    var hourArray = hour.hour24.split(":");

                    if (hourArray[1] === "00") {
                        hour.init = true;
                        hour.hour12 = moment("2015-01-01 " + hour.hour24).format("H A");
                    }

                    if (hourArray[1] === "30") {
                        hour.half = true;
                    }

                    if (hourArray[1] !== "30" && hourArray[1] !== "00") {
                        hour.quarter = true;
                    }
                });

                return hours;
            },
            //Devuelve la disponibilidad segun las reglas y el horario)
            constructAvailability: function(availabilityTables, shift) {
                var availability = [];
                var indexHourIni = getIndexHour(shift.turn.hours_ini, null);
                var nextDay = getHourNextDay(shift.turn.hours_ini, shift.turn.hours_end);
                var indexHourEnd = getIndexHour(shift.turn.hours_end, nextDay);
                var pos = 0;
                for (var i = indexHourIni; i <= indexHourEnd; i++) {
                    if (availabilityTables[i].rule_id > 0) {
                        availabilityTables[i].availability = true;
                    }
                    availabilityTables[i].position_grid = pos;
                    pos += 62;
                    availability.push(availabilityTables[i]);
                }

                return availability;
            },
            //Devuelve los bloqueos de la mesa
            getBlocksByTable: function(table, blocks, availability, indexTable) {
                var self = this;
                var blocksData = [];

                angular.forEach(blocks, function(block, key) {
                    var existsTable = self.searchTableInReservation(table, block);
                    if (existsTable === true) {
                        block = self.calculatePositionGridBlock(block, availability, indexTable);
                        block.durations = calculateDuration(block.start_time, block.end_time);
                        block.hour_text = {
                            hour_ini: moment("2015-01-01 " + block.start_time).format("H:mm A"),
                            hour_end: moment("2015-01-01 " + block.end_time).format("H:mm A"),
                        };
                        blocksData.push(block);
                    }
                });

                return blocksData;
            },
            //Devuelve las reservaciones para la mesa
            getReservationsByTable: function(table, reservations, availability, indexTable, turn) {
                var self = this;
                var reservationsData = [];

                //Agregar reservaciones a la mesa
                angular.forEach(reservations, function(reservation, key) {
                    var existsTable = self.searchTableInReservation(table, reservation);
                    var validaTurn = self.reservaInTimeValidate(reservation, turn);

                    if (existsTable === true && validaTurn) {
                        reservation = self.calculatePositionGrid(reservation, availability, indexTable);
                        reservation = self.currentTimeReservaSit(reservation, turn);

                        reservation.styles = {
                            conflicts: false,
                            conflictSit: false,
                            zIndex: 98,
                            conflictsData: []
                        };

                        reservationsData.push(reservation);
                    }
                });

                //Evaluamos los conflictos de las reservaciones de una mesa
                angular.forEach(reservationsData, function(reservation, key) {
                    self.setConflictsReservations(reservationsData, reservation, table);
                });

                return reservationsData;
            },
            //evalua el tiempo de espera en el grid (solo para reservaciones sentadas)
            currentTimeReservaSit: function(reservation, turn) {
                var timeNow = moment().format("HH:mm:ss");
                var hourEnd = reservation.total_grid[reservation.total_grid.length - 1].hour;
                var validate = moment(reservation.date_reservation + " " + hourEnd).isBefore(reservation.date_reservation + " " + timeNow);

                reservation.current_hour_extension = {
                    active: false,
                    total_time_extension: [],
                    partial_block: 0
                };

                if (validate && reservation.res_reservation_status_id === 4) {

                    reservation.current_hour_extension.active = true;

                    var timeReservation = hourEnd.split(":");
                    var timeTurn = turn.hours_end.split(":");
                    var timeDiff = moment(reservation.date_reservation + " " + timeNow).subtract("hours", timeReservation[0]).subtract("minutes", timeReservation[1]).format("HH:mm:ss");

                    var validateTurn = (moment(reservation.date_reservation + " " + timeNow).isSameOrBefore(reservation.date_reservation + " " + turn.hours_end));

                    if (validateTurn === false) {
                        timeDiff = moment(reservation.date_reservation + " " + turn.hours_end).subtract("hours", timeReservation[0]).subtract("minutes", timeReservation[1]).format("HH:mm:ss");
                    }

                    var totalMinutes = calculateMinutesTime(reservation.date_reservation + " " + timeDiff);

                    var totalCellHourExt = totalMinutes / 15;
                    totalCellHourExt = parseInt(totalCellHourExt);

                    var residuoMinutes = totalMinutes - (totalCellHourExt * 15);

                    for (var i = 1; i < totalCellHourExt; i++) {
                        reservation.current_hour_extension.total_time_extension.push({
                            item: i
                        });
                    }

                    reservation.current_hour_extension.partial_block = (residuoMinutes * 4.1333) + "px";
                }

                return reservation;
            },
            //Revisa si la reserva esta dentro del turno return => true 
            reservaInTimeValidate: function(reservation, turn) {
                var valida = false;

                var indexHourIni = getIndexHour(turn.hours_ini, 0);
                var indexHourEnd = getIndexHour(turn.hours_end, 0);

                indexHourEnd = (indexHourEnd < indexHourIni) ? indexHourEnd + 96 : indexHourEnd;

                var indexHourReservaIni = getIndexHour(reservation.hours_reservation, 0);

                var dateIni = moment(reservation.datetime_input).format("YYYY-MM-DD");
                indexHourReservaIni = (reservation.date_reservation !== dateIni) ? indexHourReservaIni + 96 : indexHourReservaIni;

                if (indexHourReservaIni >= indexHourIni && indexHourReservaIni <= indexHourEnd) {
                    valida = true;
                }
                return valida;
            },
            //Identifica y asigna los conflictos entre reservaciones para la mesa
            setConflictsReservations: function(reservations, reservation, table) {
                var self = this;
                var hours = reservation.hours_duration.split(":");
                var hour_ini = reservation.hours_reservation;
                var hour_end = moment(reservation.date_reservation + " " + hour_ini).add(hours[0], 'hours').add(hours[1], 'minutes').format("HH:mm:ss");

                var indexHourEnd = getIndexHour(hour_end, 0);
                var indexHourIni = getIndexHour(hour_ini, 0);

                var dateIni = moment(reservation.datetime_input).format("YYYY-MM-DD");
                indexHourIni = (reservation.date_reservation !== dateIni) ? indexHourIni + 96 : indexHourIni;
                indexHourEnd = (indexHourEnd < indexHourIni) ? indexHourEnd + 96 : indexHourEnd;

                var conflicts = false;
                var conflictsSit = false;
                var totalConflicts = 0;
                var reservationsConflicts = [];

                //console.log("setConflictsReservations", angular.toJson(availability, true));

                angular.forEach(reservations, function(reserva, key) {

                    if (reservation.id !== reserva.id) {
                        var rt_hours = reserva.hours_duration.split(":");
                        var rt_hour_ini = reserva.hours_reservation;
                        var rt_hour_end = moment(reserva.date_reservation + " " + rt_hour_ini).add(rt_hours[0], 'hours').add(rt_hours[1], 'minutes').format("HH:mm:ss");

                        var rt_indexHourEnd = getIndexHour(rt_hour_end, 0);
                        var rt_indexHourIni = getIndexHour(rt_hour_ini, 0);

                        var dateIni = moment(reserva.datetime_input).format("YYYY-MM-DD");
                        rt_indexHourIni = (reserva.date_reservation !== dateIni) ? rt_indexHourIni + 96 : rt_indexHourIni;
                        rt_indexHourEnd = (rt_indexHourEnd < rt_indexHourIni) ? rt_indexHourEnd + 96 : rt_indexHourEnd;

                        var validateRange = ((rt_indexHourIni >= indexHourIni) && (rt_indexHourIni < indexHourEnd));
                        var validateRange2 = ((indexHourIni >= rt_indexHourIni) && (indexHourIni < rt_indexHourEnd));

                        //Si hay interseccion entre reservaciones
                        if (validateRange || validateRange2) {
                            totalConflicts += 1;

                            reserva.hour_end = rt_hour_end;
                            reservationsConflicts.push(reserva);

                            reservation.styles.conflicts = true;
                            reserva.styles.conflicts = true;

                            //Evalua si una reserva esta contenida dentro de otra
                            var validatePopup1 = ((indexHourIni >= rt_indexHourIni) && (indexHourIni <= rt_indexHourEnd && indexHourEnd <= rt_indexHourEnd));

                            if (validatePopup1) {
                                reservation.styles.conflictIni = false;
                                reservation.styles.zIndex += 1;
                            } else {
                                reservation.styles.conflictIni = true;
                                reservation.styles.zIndex -= 1;
                            }

                            self.addReservaConflict(reserva.id, reserva);
                            self.addReservaConflict(reservation.id, reserva);
                            conflicts = true;

                            if (totalConflicts >= 2) {

                                //var evalua = self.evaluaReservationsHourEnd(reservationsConflicts, reservation.id);
                                //if (evalua === true) {
                                reservation.styles.conflictIni = false;
                                reservation.styles.zIndex = reserva.styles.zIndex + 1;
                                // }
                            }

                        } else {
                            conflictsSit = self.setConflictsReservationsInSit(reservation, reserva);
                        }
                    }
                });

                if (reservation.styles.conflicts === true && conflicts === false && (conflictsSit === false && reservation.styles.conflictSit === false)) {
                    reservation.styles.conflicts = false;
                    reservation.styles.zIndex += 1;
                    reservation.styles.conflictIni = false;
                }

                //Evaluamos si solo hay una reservacion (no hay conflictos con nada)
                if (reservations.length === 1) {
                    self.setReservationStylesDefault(reservation);
                }

                var existsConflictSit = self.evaluaConflictsSit(reservations, reservation);

                if (existsConflictSit && reservation.res_reservation_status_id === 4) {
                    reservation.styles.conflicts = true;
                    reservation.styles.conflictIni = true;
                }

                if (!(reservation.num_guest >= table.min_cover && reservation.num_guest <= table.max_cover)) {
                    reservation.styles.conflicts = true;
                    reservation.styles.conflictIni = true;
                }

                if (reservation.styles.conflictSit === true) {
                    reservation.styles.conflictIni = false;
                }

                return reservation;
            },
            //Revisa si alguna reservacion tiene un conflicto del tipo sentado
            evaluaConflictsSit: function(reservations, reservation) {
                var response = false;

                angular.forEach(reservations, function(reserva, key) {
                    if (reserva.id !== reservation.id) {
                        if (reserva.styles.conflictSit === true) {
                            response = true;
                        }
                    }
                });

                return response;
            },
            //Revisa y asigna conflictos para reservaciones sentadas
            setConflictsReservationsInSit: function(reservaEvaluate, reservation) {
                var response = false;
                var self = this;

                var validate = (moment(reservaEvaluate.date_reservation + " " + reservaEvaluate.hours_reservation).isSameOrAfter(reservation.date_reservation + " " + reservation.hours_reservation));

                if (reservation.res_reservation_status_id === 4 && validate) {

                    reservation.styles.conflicts = true;
                    reservation.styles.conflictSit = true;

                    reservaEvaluate.styles.conflicts = true;
                    reservaEvaluate.styles.conflictSit = true;

                    var validate1 = (moment(reservaEvaluate.date_reservation + " " + reservaEvaluate.hours_reservation).isBefore(reservation.date_reservation + " " + reservation.hours_reservation));

                    if (validate1 === true) {
                        reservaEvaluate.styles.conflictIni = true;

                    } else {
                        reservation.styles.conflictIni = true;
                        reservaEvaluate.styles.zIndex = reservation.styles.zIndex + 1;
                    }

                    response = true;

                    self.addReservaConflict(reservation.id, reservaEvaluate);
                    self.addReservaConflict(reservaEvaluate.id, reservaEvaluate);
                }

                return response;
            },
            //Evalua si las reservaciones estan pegadas (continua una tras otra) return =>true (EVALUANDO FUNCIONALIDAD)
            evaluaReservationsHourEnd: function(reservations, reservaId) {
                var response = true;
                var hourEnd = "";
                var hourIni = "";
                angular.forEach(reservations, function(reserva, key) {
                    if (reserva.id !== reservaId) {
                        if (hourEnd !== "") {
                            hourEnd = moment(reserva.date_reservation + " " + hourEnd).add('minutes', 15).format("HH:mm:ss");
                            hourIni = moment(reserva.date_reservation + " " + hourIni).subtract('minutes', 15).format("HH:mm:ss");

                            if ((hourEnd === reserva.hours_reservation) || (hourIni === reserva.hour_end)) {
                                response = true;
                            }
                        }
                        hourEnd = reserva.hour_end;
                        hourIni = reserva.hours_reservation;
                    }
                });
                return response;
            },
            //Agrega el id de la reserva con la que hay conflicto
            addReservaConflict: function(idReserva, reserva) {
                if (reserva.styles.conflictsData.indexOf(idReserva) === -1) {
                    reserva.styles.conflictsData.push(idReserva);
                }
            },
            //Devuelve true , si la mesa ha sido reservada
            searchTableInReservation: function(table, reservation) {
                var response = false;
                angular.forEach(reservation.tables, function(tableRes, key) {
                    if (tableRes.id === table.id) {
                        response = true;
                    }
                });

                return response;
            },
            //Devuelve el bloqueo con el campo position_grid
            calculatePositionGridBlock: function(block, availability, indexTable) {

                angular.forEach(availability, function(value, key) {
                    if (value.time == block.start_time) {
                        block.position_grid = value.position_grid;
                    }
                });

                var duration = calculateDuration(block.start_time, block.end_time);
                var total_grid = calculateMinutesTime(block.start_date + " " + duration) / 15;
                total_grid -= 1;

                block.total_grid = [];

                var posIni = block.position_grid;
                var hour = block.start_time;

                for (var i = 0; i <= total_grid; i++) {
                    block.total_grid.push({
                        posIni: posIni,
                        hour: hour,
                        index: indexTable
                    });
                    posIni += 62;
                    hour = moment(block.start_date + " " + hour).add("minutes", 15).format("HH:mm:ss");
                }

                return block;
            },
            //Devuelve la reservacion con el campo position_grid
            calculatePositionGrid: function(reservation, availability, indexTable) {

                angular.forEach(availability, function(value, key) {
                    if (value.time == reservation.hours_reservation) {
                        reservation.position_grid = value.position_grid;
                    }
                });

                var total_grid = calculateMinutesTime(reservation.date_reservation + " " + reservation.hours_duration) / 15;
                total_grid -= 1;

                reservation.total_grid = [];

                var posIni = reservation.position_grid;
                var hour = reservation.hours_reservation;

                for (var i = 0; i <= total_grid; i++) {
                    reservation.total_grid.push({
                        posIni: posIni,
                        hour: hour,
                        index: indexTable
                    });
                    posIni += 62;
                    hour = moment(reservation.date_reservation + " " + hour).add("minutes", 15).format("HH:mm:ss");
                }

                reservation.grid_width = ((total_grid + 1) * 62) + "px";

                return reservation;
            },
            //Agrega || Actualiza reservacion a la mesa : Grid
            addReservationTableGrid: function(tablesAvailabilityFinal, reservation, action, turn) {
                var self = this;

                angular.forEach(tablesAvailabilityFinal, function(tableAvailability, indexTable) {
                    angular.forEach(reservation.tables, function(table, key) {
                        self.reloadReservationsTable(tableAvailability);
                        if (tableAvailability.id === table.id) {

                            reservation = self.calculatePositionGrid(reservation, tableAvailability.availability, indexTable);
                            reservation = self.currentTimeReservaSit(reservation, turn.turn);

                            reservation = self.setReservationStylesDefault(reservation);

                            var indexReserva = self.getIndexReservationsInTableGrid(tableAvailability.reservations, reservation);

                            if (action === "create") {
                                tableAvailability.reservations.push(reservation);
                            } else if (action === "update") {
                                self.deleteReservaInTableAvailablity(tablesAvailabilityFinal, reservation);

                                var existsReserva = self.existsDataInArray(reservation.id, tableAvailability.reservations);
                                if (existsReserva === false) {
                                    tableAvailability.reservations.push(reservation);
                                } else {
                                    tableAvailability.reservations[indexReserva] = reservation;
                                }
                            }
                        }
                    });

                });

                angular.forEach(tablesAvailabilityFinal, function(tableAvailability, indexTable) {
                    angular.forEach(tableAvailability.reservations, function(reserva, key) {
                        //reserva = self.setReservationStylesDefault(reserva);
                        self.setConflictsReservations(tableAvailability.reservations, reserva, tableAvailability);
                    });
                });
            },
            //Volvemos a recorrer las reservaciones, para que se generen su directiva
            reloadReservationsTable: function(tableAvailability) {
                var reservationsTemp = angular.copy(tableAvailability.reservations);
                tableAvailability.reservations.length = 0;

                angular.forEach(reservationsTemp, function(reserva, key) {
                    tableAvailability.reservations.push(reserva);
                });

                return tableAvailability;
            },
            //Actualiza el valor styles por defecto de la reservacion
            setReservationStylesDefault: function(reservation) {
                reservation.styles = {
                    conflicts: false,
                    conflictSit: false,
                    conflictIni: false,
                    zIndex: 98,
                    conflictsData: []
                };

                return reservation;
            },
            //Evalua si el elemento existe en la coleccion , valido para,bloqueos,reservaciones
            existsDataInArray: function(id, data) {
                var exists = false;

                angular.forEach(data, function(value, key) {
                    if (id === value.id) {
                        exists = true;
                    }
                });

                return exists;
            },
            //Agrega || Actualiza bloqueo : Grid 
            addBlockTableGrid: function(tablesAvailabilityFinal, block, action) {
                var self = this;

                angular.forEach(tablesAvailabilityFinal, function(tableAvailability, indexTable) {
                    angular.forEach(block.tables, function(table, key) {
                        if (tableAvailability.id === table.id) {

                            block = self.calculatePositionGridBlock(block, tableAvailability.availability, indexTable);
                            block.durations = calculateDuration(block.start_time, block.end_time);
                            block.hour_text = {
                                hour_ini: moment("2015-01-01 " + block.start_time).format("H:mm A"),
                                hour_end: moment("2015-01-01 " + block.end_time).format("H:mm A"),
                            };

                            var indexBlock = self.getIndexBlockInTableGrid(tableAvailability.blocks, block);
                            if (action === "create") {
                                tableAvailability.blocks.push(block);
                            } else if (action == "update") {
                                self.deleteBlockInTableAvailablity(tablesAvailabilityFinal, block);

                                var existsBlock = self.existsDataInArray(block.id, tableAvailability.blocks);
                                if (existsBlock === false) {
                                    tableAvailability.blocks.push(block);
                                } else {
                                    tableAvailability.blocks[indexBlock] = block;
                                }
                            }
                        }
                    });

                });
            },
            //Elimina la reservacion (actualizacion de realtime,cuando se cambia de mesa)
            deleteReservaInTableAvailablity: function(tablesAvailabilityFinal, reserva) {
                var self = this;
                angular.forEach(tablesAvailabilityFinal, function(tableAvailability, key) {
                    angular.forEach(tableAvailability.reservations, function(reservaData, key) {
                        var existsTable = self.existsDataInArray(tableAvailability.id, reserva.tables);
                        if (reservaData.id === reserva.id && existsTable === false) {
                            tableAvailability.reservations.splice(key, 1);
                        }
                    });
                });
            },
            //Elimina el bloqueo (actualizacion de realtime,cuando se cambia de mesa)
            deleteBlockInTableAvailablity: function(tablesAvailabilityFinal, block) {
                var self = this;
                angular.forEach(tablesAvailabilityFinal, function(tableAvailability, key) {
                    angular.forEach(tableAvailability.blocks, function(blockData, key) {
                        var existsTable = self.existsDataInArray(tableAvailability.id, block.tables);
                        if (blockData.id === block.id && existsTable === false) {
                            tableAvailability.blocks.splice(key, 1);
                        }
                    });
                });
            },
            //Busca la reservacion en la lista de reservaciones, devuelve posicion (Indice)
            getIndexReservationsInTableGrid: function(tableReservations, reservation) {
                var index = null;
                angular.forEach(tableReservations, function(reserva, key) {
                    if (reserva.id === reservation.id) {
                        index = key;
                    }
                });
                return index;
            },
            //Busca el bloqueo en la lista de bloqueos, devuelve posicion (Indice)
            getIndexBlockInTableGrid: function(tableBlocks, block) {
                var index = null;
                angular.forEach(tableBlocks, function(value, key) {
                    if (value.id === block.id) {
                        index = key;
                    }
                });
                return index;
            },
            //Devuelve total de covers de todas las reservaciones del turno
            totalCoversReservations: function(tablesAvailability) {
                var totalCovers = 0;

                angular.forEach(tablesAvailability, function(tables, key) {
                    angular.forEach(tables.reservations, function(reserva, key) {
                        totalCovers += reserva.num_guest;
                    });
                });

                return totalCovers;
            },
        };
    });
angular.module('guest.app', ['guest.controller', 'guest.service', 'guest.directive'])
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.guest', {
                url: '/config/guest',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/guest/view/index.html',
                        controller: 'GuestCtrl',
                        controllerAs: 'vm'
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Lista de invitados';
                    }
                }

            })
            .state('mesas.guest.create', {
                url: '/new',
                templateUrl: '/js/app/tables/guest/view/guest-create.html',
                controller: 'GuestCreateCtrl',
                controllerAs: 'vm',
                resolve: {
                    $title: function() {
                        return 'Registrar Invitado';
                    }
                }
            })
            .state('mesas.guest.view', {
                url: '/:guest',
                templateUrl: '/js/app/tables/guest/view/guest-view.html',
                controller: 'GuestViewCtrl',
                controllerAs: 'vm',
                resolve: {
                    $title: function() {
                        return 'Perfil invitado';
                    }
                }
            })
            .state('mesas.guest.edit', {
                url: '/:guest/edit',
                templateUrl: '/js/app/tables/guest/view/guest-create.html',
                controller: 'GuestCreateCtrl',
                controllerAs: 'vm',
                resolve: {
                    $title: function() {
                        return 'Editar Invitado';
                    }
                }
            });
    });
angular.module('guest.controller', [])
    .controller('GuestCtrl', function(GuestFactory, $state) {

        var vm = this;

        vm.guestList = [];
        vm.name = "";

        vm.init = function() {
            vm.guestAll(null);
        };

        vm.configScrollBar = optionsScrollBarPLugin('y', 'light', '100%');

        vm.guestAll = function(params) {

            params = (params !== null) ? params : "";
            params = getAsUriParameters(params);

            GuestFactory.guestList(params).then(function success(response) {

                vm.guestList = response;
                vm.showGuest(vm.guestList);

            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
            });
        };

        vm.showGuest = function(guestData) {
            $state.go("mesas.guest.view", {
                'guest': guestData[0].id
            });
        };

        vm.searchGuest = function() {
            var params = {
                name: vm.name
            };
            vm.guestAll(params);
        };

        vm.init();
    })
    .controller('GuestViewCtrl', function(GuestFactory, GuestDataFactory, $stateParams) {
        var vm = this;
        var dateNow = convertFechaYYMMDD(new Date(), "es-ES", {});

        vm.guestId = $stateParams.guest;

        vm.guestData = {
            name: '',
            contact: '',
            reservations: {
                resumen: {},
                past: [],
                last: []
            }
        };

        vm.paginationReservation = {
            totalItems: 0,
            currentPage: 1,
            maxSize: 10,
            itemsPage: 1
        };

        vm.init = function() {
            vm.getGuest();

            vm.getReservations({
                page: vm.paginationReservation.currentPage,
                page_size: vm.paginationReservation.itemsPage,
                end_date: dateNow
            }, "past");

            vm.getReservations({
                start_date: dateNow
            }, "last");

            vm.getResumenReservation();
        };

        vm.getGuest = function() {
            if ($stateParams.guest !== undefined) {

                GuestDataFactory.getGuest($stateParams.guest).then(function success(response) {
                    var data = response.data.data;
                    vm.guestData.name = data.first_name + " " + data.last_name;
                    vm.guestData.contact = GuestFactory.parserContactData(data);

                }, function error(response) {
                    messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
                });
            }
        };

        vm.getReservations = function(options, type) {

            options = getAsUriParameters(options);
            angular.element("#item-reserva").addClass("hide");

            GuestFactory.reservationsList(vm.guestId, options).then(function success(response) {

                if (type == "last") {
                    vm.guestData.reservations.last = response.data;
                } else {
                    vm.guestData.reservations.past = response.data;
                    vm.paginationReservation.totalItems = response.pagination.total;
                }
                setTimeout(function() {
                    angular.element("#item-reserva").removeClass("hide");
                }, 500);

            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
            });
        };

        vm.pageReservationChanged = function(page) {
            vm.getReservations({
                page: page,
                page_size: vm.paginationReservation.itemsPage,
                end_date: dateNow
            }, "past");
        };

        vm.getResumenReservation = function() {
            GuestFactory.getResumenReservation(vm.guestId).then(function success(response) {
                vm.guestData.reservations.resumen = response;
            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
            });
        };

        vm.init();
    })
    .controller('GuestCreateCtrl', function(GuestFactory, GuestDataFactory, $compile, $scope, $state, $stateParams) {
        var vm = this;

        vm.formats = ['dd-MMMM-yyyy', 'yyyy/MM/dd', 'dd.MM.yyyy', 'shortDate'];
        vm.format = vm.formats[1];

        vm.contentTab = {
            active: "datos.html",
            tab1: 'active',
            tab2: ''
        };

        vm.guestData = {
            first_name: '',
            last_name: '',
            birthdate: '',
            gender: '',
            phones: [],
            emails: [],
            tags: [],
            custom_tags: []
        };

        vm.guestFormData = {
            gender: '',
            birthdate: ''
        };

        vm.tagsList = [];
        vm.tagsListAdd = [];

        vm.phone = "";
        vm.email = "";

        vm.genderData = null;

        vm.init = function() {
            vm.listGender();

            GuestFactory.getTags().then(
                function success(response) {
                    vm.tagsList = response.tagsList;
                    vm.tagsListAdd = response.tagsListAdd;

                    vm.listAllTagsCustom();
                    vm.loadDataGuestEdit();
                },
                function error(response) {
                    console.log("getTags error ", angular.toJson(response, true));
                });
        };

        vm.listAllTagsCustom = function() {
            GuestFactory.getTagsCustomGuest().then(
                function success(response) {
                    response = response.data;
                    angular.forEach(vm.tagsList, function(tag, key) {
                        if (tag.id == 4) {
                            tag.tags = response;
                        }
                    });
                },
                function error(response) {
                    console.error("listAllTagsCustom " + angular.toJson(response, true));
                });
        };

        vm.listGender = function() {
            vm.genderData = getGender();
            vm.guestFormData.gender = vm.genderData[0];
        };

        vm.selectTab = function(tabItem) {
            vm.contentTab = GuestFactory.getTabSelected(tabItem);
        };

        vm.validaSaveGuest = function(frmGuest) {
            if (frmGuest.$valid) {
                vm.saveGuest();
            }
        };

        vm.saveGuest = function() {
            vm.prepareCustomTagSave();

            vm.guestData.birthdate = convertFechaYYMMDD(vm.guestFormData.birthdate, "es-ES", {});
            vm.guestData.gender = vm.guestFormData.gender.id;

            var option = ($stateParams.guest !== undefined) ? "edit" : "create";

            GuestFactory.saveGuest(vm.guestData, option).then(function success(response) {
                $state.reload();
                messageAlert("Success", "Huesped registrado", "success", 0, true);
            }, function error(response) {
                messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
            });
        };

        vm.insertPhone = function() {
            vm.guestData.phones = GuestFactory.insertDataContact(vm.guestData.phones, vm.phone, 'telefono');
            vm.phone = "";
        };

        vm.deletePhone = function(index) {
            vm.guestData.phones.splice(index, 1);
        };

        vm.insertEmail = function() {
            vm.guestData.emails = GuestFactory.insertDataContact(vm.guestData.emails, vm.email, 'email');
            vm.email = "";
        };

        vm.deleteEmail = function(index) {
            vm.guestData.emails.splice(index, 1);
        };

        vm.openCalendar = function($event, opened) {
            $event.preventDefault();
            $event.stopPropagation();
            vm.opened = true;
        };

        vm.prepareCustomTagSave = function() {
            vm.guestData.custom_tags = vm.tagsListAdd[3].data;

            angular.forEach(vm.guestData.tags, function(tag, key) {
                var json = angular.toJson(tag);
                if (json.indexOf("custom_tag") > -1) {
                    if (tag.custom_tag === true) {
                        vm.guestData.tags.splice(key);
                    }
                }
            });
        };

        vm.addTag = function(tag, category, event) {
            //evitamos que se cierre el dropdown-menu 
            event.stopPropagation();

            var indexTagList = GuestFactory.getIndexTag(vm.tagsList[category], tag.id);
            var index = GuestFactory.existsTag(vm.tagsListAdd[category].data, tag.id);

            var tagsData = {
                id: tag.id,
                name: tag.name,
                res_guest_tag_category_id: tag.res_guest_tag_gategory_id
            };

            if (index === null) {
                vm.tagsListAdd[category].data.push(tagsData);
                vm.guestData.tags.push({
                    id: tagsData.id,
                    custom_tag: (category === 3) ? true : false
                });

                vm.tagsList[category].tags[indexTagList].active = true;

            } else {
                vm.tagsList[category].tags[indexTagList].active = false;

                vm.tagsListAdd[category].data.splice(index, 1);
                var indexTag = GuestFactory.existsTag(vm.guestData.tags, tag.id);
                vm.guestData.tags.splice(indexTag, 1);
            }
        };

        vm.loadDataGuestEdit = function() {
            if ($stateParams.guest !== undefined) {

                GuestFactory.getGuest($stateParams.guest).then(function success(response) {
                    vm.guestData = response.guest;
                    vm.guestFormData.birthdate = convertFechaToDate(vm.guestData.birthdate);
                    vm.guestFormData.gender = vm.guestData.gender;

                    GuestFactory.showTags(response.guest.tags, vm.tagsListAdd);
                    GuestFactory.showTags(response.guest.custom_tags, vm.tagsListAdd);
                    GuestFactory.checkActiveTags(vm.tagsList, vm.tagsListAdd);

                }, function error(response) {
                    messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
                });
            }
        };

        vm.init();
    });
angular.module('guest.directive', []);
angular.module('guest.service', [])
    .factory('GuestDataFactory', function($http, ApiUrlMesas, ApiUrlRoot) {
        return {
            getAllGuest: function(params) {
                return $http.get(ApiUrlMesas + "/guests?" + params);
            },
            getAllTags: function() {
                return $http.get(ApiUrlMesas + "/guests/tags");
            },
            getGuest: function(idGuest) {
                return $http.get(ApiUrlMesas + "/guests/" + idGuest);
            },
            create: function(vData) {
                return $http.post(ApiUrlMesas + '/guests', vData);
            },
            update: function(vData) {
                return $http.put(ApiUrlMesas + '/guests/' + vData.id, vData);
            },
            getReservations: function(idGuest, options) {
                return $http.get(ApiUrlMesas + "/guests/" + idGuest + "/reservations?" + options);
            }
        };

    })

.factory('GuestFactory', function($http, $q, GuestDataFactory, CustomTagGuestDataService) {
    return {
        guestList: function(params) {
            var guestAll = [];
            var defered = $q.defer();
            var me = this;

            GuestDataFactory.getAllGuest(params).success(function(data) {
                data = data.data.data;

                angular.forEach(data, function(value, key) {
                    value.contact = me.parserContactData(value);
                    guestAll.push(value);
                });

                defered.resolve(guestAll);

            }).error(function(data, status, headers) {
                var response = jsonErrorData(data, status, headers);
                defered.reject(response);
            });

            return defered.promise;
        },
        getTabSelected: function(tabItem) {
            var contentTab = {};
            if (tabItem == 1) {
                contentTab.active = "datos.html";
                contentTab.tab1 = "active";
                contentTab.tab2 = "";
            }

            if (tabItem == 2) {
                contentTab.active = "datos-contact.html";
                contentTab.tab1 = "";
                contentTab.tab2 = "active";
            }

            return contentTab;
        },
        insertDataContact: function(elements, element, type) {

            var jsonData = JSON.stringify(elements);

            if (element !== undefined) {
                if (jsonData.indexOf(element) == -1) {
                    var data = {
                        email: element
                    };

                    if (type == "telefono") {
                        data = {
                            number: element
                        };
                    }

                    elements.push(data);
                } else {
                    messageAlert("Alerta", "El " + type + " ya ha sido agregado", "info", 0, true);
                }
            } else {
                messageAlert("Alerta", "El " + type + " no es correcto", "info", 0, true);
            }
            return elements;
        },
        existsTag: function(tagList, tag) {
            var index = null;

            angular.forEach(tagList, function(value, key) {
                if (value.id == tag) {
                    index = key;
                }
            });

            return index;
        },
        saveGuest: function(dataGuest, option) {
            var defered = null;
            var me = this;

            if (option == "create") {
                defered = GuestDataFactory.create(dataGuest);
            } else {
                defered = GuestDataFactory.update(dataGuest);
            }

            return defered;
        },
        getGuest: function(idGuest) {
            var defered = $q.defer();

            GuestDataFactory.getGuest(idGuest).success(function(data) {
                data = data.data;

                var guestData = {
                    guest: {
                        id: data.id,
                        first_name: data.first_name,
                        last_name: data.last_name,
                        birthdate: (data.birthdate == "0000-00-00") ? "1970-01-01" : data.birthdate,
                        gender: {
                            id: data.gender
                        },
                        phones: [],
                        emails: [],
                        tags: [],
                        custom_tags: []
                    }
                };

                angular.forEach(data.phones, function(value, key) {
                    guestData.guest.phones.push({
                        id: value.id,
                        number: value.number
                    });
                });

                angular.forEach(data.emails, function(value, key) {
                    guestData.guest.emails.push({
                        id: value.id,
                        email: value.email
                    });
                });

                angular.forEach(data.tags, function(value, key) {
                    guestData.guest.tags.push({
                        id: value.id,
                        res_guest_tag_gategory_id: value.res_guest_tag_gategory_id,
                        name: value.name
                    });
                });

                angular.forEach(data.customs_tags, function(value, key) {
                    guestData.guest.custom_tags.push({
                        id: value.id,
                        name: value.name,
                        res_guest_tag_gategory_id: 4
                    });
                });

                defered.resolve(guestData);

            }).error(function(data, status, headers) {
                var response = jsonErrorData(data, status, headers);
                defered.reject(response);
            });

            return defered.promise;
        },
        showTags: function(guestTags, tagsListGuest) {

            angular.forEach(guestTags, function(value, key) {
                angular.forEach(tagsListGuest, function(data, key) {
                    if (data.id == value.res_guest_tag_gategory_id) {
                        tagsListGuest[key].data.push({
                            id: value.id,
                            name: value.name,
                            res_guest_tag_category_id: data.id
                        });
                    }
                });

            });

            return tagsListGuest;
        },
        getTags: function() {
            var defered = $q.defer();
            var tagsList = [];
            var tagsListAdd = [];

            GuestDataFactory.getAllTags().success(function(data) {
                tagsList = data.data;

                angular.forEach(tagsList, function(value, key) {
                    tagsListAdd.push({
                        id: value.id,
                        data: []
                    });
                });

                var response = {
                    tagsList: tagsList,
                    tagsListAdd: tagsListAdd
                };

                defered.resolve(response);

            }).error(function(data, status, headers) {
                defered.reject(data);
            });

            return defered.promise;
        },
        parserContactData: function(value) {
            var contact = "";

            if (value.phones.length === 0 && value.emails.length === 0) {
                contact = "sin telefono / correo";
            } else {

                if (value.phones.length > 0) {
                    contact = value.phones[0].number;
                }

                if (value.emails.length > 0) {
                    contact = value.emails[0].email;
                }
            }
            return contact;
        },
        reservationsList: function(idGuest, options) {
            var defered = $q.defer();

            GuestDataFactory.getReservations(idGuest, options).success(function(data) {
                var reservData = {
                    pagination: {
                        last_page: data.last_page,
                        next_page_url: data.next_page_url,
                        per_page: data.per_page,
                        total: data.total
                    },
                    data: []
                };

                angular.forEach(data.data, function(value, key) {
                    value.date_reservation_text = convertTextToDate("es-ES", {
                        weekday: "long",
                        month: "short",
                        day: "numeric"
                    }, value.date_reservation);
                    value.hours_reservation_text = defineTimeSytem(value.hours_reservation);

                    reservData.data.push(value);
                });

                defered.resolve(reservData);
            }).error(function(data, status, headers) {
                var response = jsonErrorData(data, status, headers);
                defered.reject(response);
            });

            return defered.promise;
        },
        getResumenReservation: function(idGuest) {
            var defered = $q.defer();

            GuestDataFactory.getReservations(idGuest, "").success(function(data) {

                var reservData = {
                    finished: 0,
                    canceled: 0
                };

                angular.forEach(data.data, function(value, key) {

                    if (value.res_reservation_status_id == 9 || value.res_reservation_status_id == 10) {
                        reservData.canceled += 1;
                    }

                    if (value.res_reservation_status_id == 12) {
                        reservData.finished += 1;
                    }

                });

                defered.resolve(reservData);
            }).error(function(data, status, headers) {
                var response = jsonErrorData(data, status, headers);
                defered.reject(response);
            });

            return defered.promise;
        },
        getTagsCustomGuest: function() {
            var defered = $q.defer();

            CustomTagGuestDataService.getListTagGuestCustom().then(
                function success(response) {
                    defered.resolve(response.data);
                },
                function error(response) {
                    defered.reject(response.data);
                });
            return defered.promise;
        },
        getIndexTag: function(tagsList, idTag) {
            //Obtiene el indice del tag, del listado general de tags
            var index = null;

            angular.forEach(tagsList.tags, function(tags, key) {
                if (tags.id == idTag) {
                    index = key;
                }
            });

            return index;
        },
        checkActiveTags: function(tagsList, tagsListAdd) {
            //Activamos los tags en la vista, solo los tags que ha agregado el guest guest
            var self = this;
            angular.forEach(tagsList, function(tags, keyTag) {

                angular.forEach(tags.tags, function(value, key) {
                    var exists = self.isExistsTagListAdd(tagsListAdd[keyTag], value.id);

                    if (exists) {
                        value.active = true;
                    }
                });
            });
        },
        isExistsTagListAdd: function(tagsListAdd, idTag) {
            //Saber si el tag esta agregado a la lista de tags del guest
            var response = false;
            angular.forEach(tagsListAdd.data, function(value, key) {
                if (value.id == idTag) {
                    response = true;
                }
            });

            return response;
        }
    };
})

;
angular.module("notification.app", []);
angular.module('reservation.app', ['reservation.controller', 'reservation.service', 'reservation.filter'])
    .constant("screenSize", {
        minSize: 400,
        header: 120,
        menu: 400
    })
    .constant("quantityGuest", 100)
    .config(function($stateProvider) {
        $stateProvider
            .state('mesas.floor.reservation.add', {
                url: '/:date/add',
                params: {
                    tables: null,
                    hour: null
                },
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })
            .state('mesas.book-reservation-add', {
                url: '/book/reservation/:date/add',
                params: {
                    tables: null,
                    hour: null
                },
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })
            .state('mesas.book-reservation-add-params', {
                url: '/book/reservation/:date/add/:hour/:guest',
                params: {
                    tables: null,
                },
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })
            .state('mesas.grid-reservation-add', {
                url: '/grid/reservation/:date/add',
                params: {
                    tables: null,
                },
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })            
            .state('mesas.floor.reservation.edit', {
                url: '/:date/edit/:id',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })
            .state('mesas.book-reservation-edit', {
                url: '/book/reservation/:date/edit/:id?date_end&turns&zones&sources&search_text&sort',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })
            .state('mesas.grid-reservation-edit', {
                url: '/grid/:date/edit/:id',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            })
            .state('mesas.guest.view.reservation-edit', {
                url: '/reservation/:date/edit/:id',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/reservation/view/index.html',
                        controller: "reservationCtrl.StoreUpdate",
                        controllerAs: 'rc',
                    }
                },
            });
    });
angular.module('reservation.controller', [])
    .controller("reservationCtrl.StoreUpdate", ["$scope", "ZoneLienzoFactory", "$window", "$stateParams", "$timeout",
        "screenHelper", "reservationService", "reservationHelper", "screenSize", "$state", "$table", "$q", "BookConfigFactory",
        function($scope, ZoneLienzoFactory, $window, $stateParams, $timeout, screenHelper, service, helper, screenSize,
            $state, $table, $q, BookConfigFactory) {
            var vm = this;

            /**
             * Zonas que se deben mostar
             * @type {Array}
             */
            vm.showZones = [];

            /**
             * Entidad de reservacion
             * @type {Object}
             */
            vm.reservation = {};
            vm.reservation.guests = {
                men: 0,
                women: 0,
                children: 0
            };

            /**
             * Entidad de configuration
             * @type {Object}
             */
            vm.configuration = {};

            /**
             * Mesas seleccionadas en el lienzo
             * @type {Object}
             */
            vm.tablesSelected = {};

            /**
             * Saber si se a seleccionado al menos un mesa
             * @type {Boolean}
             */
            vm.isTablesSelected = false;

            /**
             * Conflictos encontrados con mesas | bloqueado, reservado, muy grande
             * @type {Array}
             */
            vm.conflicts = [];

            /**
             * Zonas con sus mesas para los turnos encontrados en la fecha seleccionada
             * @type {Array}
             */
            vm.zones = [];

            /**
             * Indice de zona para la zona que se va a mostrar
             * @type {Number}
             */
            vm.zoneIndex = 0;

            /**
             * Mesa sugeria
             * @type {Object}
             */
            vm.tableSuggested = {};

            /**
             * Fecha de apoyo para input datetime
             * @type {String}
             */
            vm.date = "";

            /**
             * Tags de reservacion
             * @type {Array}
             */
            vm.tags = [];

            /**
             * Tags de reservacion seleccionados
             * @type {Object}
             */
            vm.selectTags = {};

            /**
             * Entidad para nuevo invitado
             * @type {Object}
             */
            vm.guest = {};

            /**
             * Horas filtradas por turnos
             * @type {Array}
             */
            vm.hours = [];

            ///////////////////////////////////////////////////////////////
            //  Variables internas de apoyo
            ///////////////////////////////////////////////////////////////

            /**
             * Indice maximo de zona que se puede acceder y mostrar
             * @type {Number}
             */
            var zoneIndexMax = 0;

            /**
             * Mesas bloquedas
             * @type {Array}
             */
            var blocks = [];

            /**
             * Reservaciones del dia
             * @type {Array}
             */
            var reservations = [];

            /**
             * Listado de invitados encontrados por filtro de busqueda
             * @type {Array}
             */
            vm.guestList = [];

            /**
             * Forzar recarga de datos
             * @type {Boolean}
             */
            var reload = false;

            /**
             * El estado actual es de edicion
             * @type {Boolean}
             */
            var editState = false;

            vm.editState = false;
            /**
             * Datepicker config
             */
            $scope.toggleMin = function() {
                $scope.minDate = $scope.minDate ? null : new Date();
            };
            $scope.toggleMin();

            $scope.open = function($event, opened) {
                $event.preventDefault();
                $event.stopPropagation();

                $scope[opened] = true;
            };

            $scope.format = 'dd-MM-yyyy';
            /**
             * END Datepicker config
             */


            vm.save = function() {
                ///////////////////////////////////////////////////////////////
                // parse reservation.tables ids
                ///////////////////////////////////////////////////////////////
                vm.reservation.tables = [];
                vm.reservation.tables = Object.keys(vm.tablesSelected).reduce(function(result, value) {
                    result.push(parseInt(value));
                    return result;
                }, []);

                // Se retira autoenvio de mesa sugerida, se puede reservar sin mesas.
                // if (vm.reservation.tables.length === 0) {
                //     if (vm.tableSuggested) {
                //         vm.reservation.tables.push(vm.tableSuggested.id);
                //     } else {
                //         return message.alert("Debe elegir mesas para la reservacion");
                //     }
                // }
                
                if ( (vm.configuration.status_people_1 || vm.configuration.status_people_2 || vm.configuration.status_people_3)  && 
                        (vm.reservation.status_id == 4 | vm.reservation.status_id == 5)) {
                    var suma = vm.reservation.guests.men + vm.reservation.guests.women + vm.reservation.guests.children;
                    if (suma === 0 ) {
                        return message.alert("Es obligatorio indicar cantidad de invitados por tipo", "Este campo se encuentra en la parte inferior izquierda de la pantalla.");
                    }
                } else {
                    vm.reservation.guests.men  = 0;
                    vm.reservation.guests.women = 0;
                    vm.reservation.guests.children = 0;
                }

                ///////////////////////////////////////////////////////////////
                // parse reservation.tags
                ///////////////////////////////////////////////////////////////
                vm.reservation.tags = [];
                vm.reservation.tags = Object.keys(vm.selectTags).reduce(function(result, value) {
                    result.push(parseInt(value));
                    return result;
                }, []);

                ///////////////////////////////////////////////////////////////
                //  parse guest
                ///////////////////////////////////////////////////////////////
                if (!vm.reservation.guest_id) {
                    vm.reservation.guest = vm.newGuest || {};
                    delete vm.reservation.guest_id;
                } else {
                    delete vm.reservation.guest;
                }

                ///////////////////////////////////////////////////////////////
                //  parse date
                ///////////////////////////////////////////////////////////////
                vm.reservation.date = moment(vm.date).format("YYYY-MM-DD");

                if (editState) {
                    saveEditReservation();
                } else {
                    saveNewReservation();
                }

            };


            var parseResponseErrorApi = function(errors) {

                var dataError = [];
                var arr = Object.keys(errors).map(function (key) {
                    var value = errors[key];
                    var index = key.indexOf(".");

                    if(index < 0){

                        var collectErrors = '';
                        for (var j = 0; j < value.length; j++) {
                            var coma = (j>0)?",":"";
                            collectErrors = coma + '"'+ value[j] + '"';
                        }

                        var strJson = '{"' + key + '": [' + collectErrors +']}'; 
                        
                        if(eval("(" + strJson + ")")){
                            var dataJson = JSON.parse(strJson);
                            dataError.push(dataJson);
                        }
                        
                    }else{

                        var subval =  key.substring(index +1);

                        console.log("subval: ", subval);

                    }
                     
                });

                
                var size = errors;

                console.log(dataError);
                /*for (var i = 0; i < errors.length; i++) {
                    var value = errors[i];
                    var index = value.indexOf(".");
                    console.log("parseResponseErrorApi -> value ", value);
                    if(index < 0){

                    }else{

                    }
                }*/

            };

            var initErrors = function(){
                vm.error = {
                    status_id: null,
                    covers: null,
                    date: null,
                    hour: null,
                    duration: null,
                    server_id: null,
                    note: null,
                    guest: {
                        first_name: null,
                        last_name: null,
                        email: null,
                        phone: null
                    },
                    guests: null,
                    tables: null,
                    tags: null
                };
            };

            /**
             * Save. update and cancel reservation
             */

            var saveNewReservation = function() {
                vm.waitingResponse = true;
                vm.error = {};
                service.save(vm.reservation)
                    .then(function(response) {
                        message.success(response.data.msg);
                        vm.waitingResponse = false;
                        vm.cancel();
                    }).catch(function(error) {
                        parseResponseErrorApi(error.data.data);
                        vm.error = error.data.data;

                        console.log("vm.error ", vm.error);
                        console.log("vm.error ", vm.error.guest.firstname);

                        message.apiError(error);
                        vm.waitingResponse = false;
                    });
            };

            var saveEditReservation = function() {
                vm.waitingResponse = true;
                var id = vm.reservation.id;
                service.edit(id, vm.reservation)
                    .then(function(response) {
                        message.success(response.data.msg);
                        redirect();
                    }).catch(function(error) {
                        message.apiError(error);
                        vm.waitingResponse = false;
                    });
            };

            vm.cancel = function() {
                return redirect();
            };

            var reset = function() {
                vm.tablesSelected = {};
                vm.zones.length = 0;
            };
            /**
             * END Save. update and cancel reservation
             */


            /**
             * Manejo de eventos sobre las tablas
             */
            vm.selectTableAllOrNone = function(indicator) {
                $table.selectTableAllOrNone(vm.zones[vm.zoneIndex], indicator);
                listTableSelected();
            };

            var alertConflicts = function() {
                vm.conflicts = [];
                angular.forEach(vm.tablesSelected, function(table, i) {
                    var conflict = {};

                    if (vm.reservation.covers < table.minCover) {
                        conflict.name = table.name;
                        conflict.desc = "Mesa  demasiado grande";
                        vm.conflicts.push(conflict);
                    } else if (table.block) {
                        conflict.name = table.name;
                        conflict.desc = "La mesa se encuentra bloqueada en el rango de duracion de esta reservacion";
                        vm.conflicts.push(conflict);
                    } else if (table.occupied) {
                        conflict.name = table.name;
                        conflict.desc = "La mesa ya se encuentra ocupada en el rango de duracion de esta reservacion";
                        vm.conflicts.push(conflict);
                    }
                });
            };

            vm.selectTable = function(table) {
                table.selected = !table.selected;
                listTableSelected();
            };

            var listTableSelected = function() {
                $table.listTableSelected(vm.zones, vm.tablesSelected);
                vm.isTablesSelected = Object.keys(vm.tablesSelected).length > 0;

                alertConflicts();
            };

            vm.tablesBlockValid = function() {
                $table.tablesBlockValid(vm.zones, blocks, vm.reservation, editState, $stateParams.id);
                vm.tablesSuggested(vm.reservation.covers);
            };

            vm.changeHour = function() {

                if (!vm.hour) {
                    vm.reservation.hour = null;
                } else {
                    vm.reservation.hour = vm.hour.time;
                    vm.showZones = [];
                    angular.forEach(vm.hour.zones, function(zone) {
                        vm.showZones.push(zone.id);
                    });

                    if (vm.showZones.indexOf(vm.zones[vm.zoneIndex].id) === -1) {
                        return vm.nextZone();
                    } else {
                        vm.zoneID = vm.zones[vm.zoneIndex].id;
                    }
                    vm.tablesBlockValid();
                }
            };

            vm.tablesSuggested = function(cant, a) {
                if (vm.editState) return;
                var count = Object.keys(vm.tablesSelected).length;
                if (count <= 1) {
                    vm.zones.clearSelected();
                    vm.tableSuggested = $table.tablesSuggested(vm.zones, cant, vm.zoneIndex);
                    if (vm.tableSuggested) vm.zones.tablesSelected([vm.tableSuggested]);
                }

                listTableSelected();
            };
            /**
             * END Manejo de eventos sobre las tablas
             */


            /**
             * Consulta a servicios
             */
            var listGuest = function() {
                var deferred = $q.defer();

                service.getGuest()
                    .then(function(guests) {
                        vm.covers = guests;
                        vm.reservation.covers = 2;
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            var listHours = function(turns) {
                var deferred = $q.defer();

                service.getHours(turns)
                    .then(function(data) {
                        vm.hours = data.hours;
                        vm.reservation.hour = data.default;
                        vm.hour = data.objDefault;
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            var listDurations = function() {
                var deferred = $q.defer();

                service.getDurations()
                    .then(function(durations) {
                        vm.durations = durations;
                        vm.reservation.duration = "01:30:00";
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };
            /**
             * END Consulta a servicios
             */


            /**
             * Desplazamineto entre zonas
             */
            var setMaxIndex = function() {
                zoneIndexMax = vm.zones.length - 1;
            };

            vm.nextZone = function() {
                if (zoneIndexMax >= 0) {
                    if (vm.zoneIndex + 1 > zoneIndexMax) {
                        vm.zoneIndex = 0;
                    } else {
                        vm.zoneIndex++;
                    }
                }

                if (validZoneShow()) {
                    return vm.nextZone();
                }

                vm.tablesSuggested(vm.reservation.covers);
            };

            vm.prevZone = function() {
                if (zoneIndexMax >= 0) {
                    if (vm.zoneIndex - 1 >= 0) {
                        vm.zoneIndex--;
                    } else {
                        vm.zoneIndex = zoneIndexMax;
                    }
                }

                if (validZoneShow()) {
                    return vm.prevZone();
                }

                vm.tablesSuggested(vm.reservation.covers);
            };

            var validZoneShow = function() {
                var exists = vm.showZones.indexOf(vm.zones[vm.zoneIndex].id) !== -1;
                if (exists) {
                    vm.zoneID = vm.zones[vm.zoneIndex].id;
                }
                return !exists;
            };

            angular.element($window).bind('resize', function() {
                sizeLienzo();
                $scope.$digest();
            });

            var sizeLienzo = function() {
                vm.size = screenHelper.size(screenSize);
                vm.fontSize = (14 * vm.size / screenSize.minSize + "px");
            };
            /**
             * END Desplazamineto entre zonas
             */


            /**
             * Search guest list
             */
            var auxiliar;
            vm.searchGuest = function(name) {
                vm.searchListHide = false;
                if (auxiliar) $timeout.cancel(auxiliar);
                if (name === "") {
                    vm.guestList = [];
                    return;
                }
                var search = function() {
                    service.getGuestList(name)
                        .then(function(response) {
                            vm.guestList = response.data.data.data;
                        }).catch(function(error) {
                            message.apiError(error);
                        });
                };

                auxiliar = $timeout(search, 500);
            };

            vm.selectGuest = function(guest) {
                vm.reservation.guest_id = guest.id;
                vm.guest = guest;
                vm.addGuest = false;
            };

            vm.removeGuest = function() {
                vm.reservation.guest_id = null;
                vm.newGuest = null;
                vm.guestList = [];
                vm.addGuest = false;
            };

            // vm.searchListHide = function() {
            //     vm.guestList = [];
            // };
            /**
             * END Search guest list
             */


            /**
             * Select tags
             */
            vm.addTag = function(tag) {
                tag.checked = !tag.checked;
                listTagsSelected();
            };

            var listTagsSelected = function() {
                angular.forEach(vm.tags, function(tag) {
                    if (tag.checked) {
                        vm.selectTags[tag.id] = angular.copy(tag);
                    } else {
                        delete vm.selectTags[tag.id];
                    }
                });
            };
            /**
             * END Select tags
             */


            /**
             * Edit Reservation Case
             */
            function validateEditState() {
                if (vm.editState) {
                    var reservation_id = $stateParams.id;

                    if (!reservation_id) {
                        message.error("La reservacion a editar no es valida");
                        return redirect();
                    }
                }
            }

            function loadReservation(reserve) {
                if (reserve === null) {
                    message.error("No se encontro la reservacion solicitada");
                    return redirect();
                } else {
                    parseReservationEdit(reserve);
                    getZoneIndexForTable(reserve.tables);
                }
            }

            vm.cancelReservation = function() {
                message.confirm("¿ Esta seguro de cencelar la reservacion ?", "Esta accion se puede revertir", function() {
                    vm.waitingResponse = true;
                    var id = vm.reservation.id;
                    service.cancel(id)
                        .then(function(response) {
                            message.success(response.data.msg);
                            redirect();
                        }).catch(function(error) {
                            message.apiError(error);
                            vm.waitingResponse = false;
                        });
                });
            };

            function parseReservationEdit(reservation) {
                vm.reservation = {
                    id: reservation.id,
                    guest_id: reservation.res_guest_id,
                    status_id: reservation.res_reservation_status_id,
                    date: reservation.date_reservation,
                    // hour: reservation.hours_reservation, //Ahora se maneja por filterHour - ya que la hora se maneja por objeto y escucha su cambio
                    duration: reservation.hours_duration,
                    hour: reservation.hours_reservation,
                    covers: reservation.num_guest,
                    note: reservation.note,
                    server_id: reservation.res_server_id
                };

                vm.reservation.guests = {
                    men: reservation.num_people_1,
                    women: reservation.num_people_2,
                    children: reservation.num_people_3
                };

                vm.hour = filterHour(vm.hours, reservation.hours_reservation);

                if (reservation.res_guest_id) {
                    vm.guest = reservation.guest;
                }

                paintTables(reservation.tables);
                paintTags(reservation.tags);
            }

            function paintTables(tables) {
                $table.paintTables(vm.zones, tables);
                listTableSelected();
            }

            function paintTags(tags) {
                angular.forEach(tags, function(tagInUse) {
                    angular.forEach(vm.tags, function(tag) {
                        if (tag.id == tagInUse.id) {
                            tag.checked = true;
                        }
                    });
                });

                listTagsSelected();
            }

            function getZoneIndexForTable(serverTables) {
                var index = $table.getZoneIndexForTable(vm.zones, serverTables);

                if (index !== null) {
                    vm.zoneIndex = index;
                }
            }
            /**
             * END Edit Reservation Case
             */

            var filterHour = function(hours, defaultItem) {
                var timeDefault;

                var now = moment().add((15 - (parseInt(moment().format("mm")) % 15)), "minutes").second(0).millisecond(0);
                var timeDefaultIsEstablished = false;

                var defaultHour = defaultItem ? moment(defaultItem, "HH:mm:ss") : null;

                angular.forEach(hours, function(hour) {
                    if (!timeDefaultIsEstablished) {
                        var hourTime = moment(hour.time, "HH:mm:ss");
                        if (hourTime.isSameOrAfter(now) && !timeDefaultIsEstablished) {
                            timeDefault = hour;
                            timeDefaultIsEstablished = true;
                        }

                        if (hourTime.isSame(defaultHour)) {
                            timeDefault = hour;
                            timeDefaultIsEstablished = true;
                        }
                    }
                });

                if (!timeDefault) {
                    if (hours.length > 0) {
                        timeDefault = hours[hours.length - 1];
                    }
                }

                return timeDefault;
            };

            var InitModule = function(date) {
                vm.waitingResponse = true;

                validateEditState();

                listGuest();
                service.reservationMaster(date, $stateParams.id)
                    .then(function(response) {
                        var zones = response.data.data.zones;
                        blocks = response.data.data.blockTables;
                        reservations = response.data.data.reservations;
                        vm.servers = response.data.data.servers;
                        vm.statuses = response.data.data.status;
                        vm.tags = response.data.data.tags;
                        vm.configuration = response.data.data.config;
                        var turns = response.data.data.shifts;

                        listHours(turns)
                            .then(function() {
                                if ($stateParams.hour) {
                                    vm.hour = filterHour(vm.hours, $stateParams.hour);
                                }
                            });

                        listDurations();

                        var reserveEdit = response.data.data.reservation;

                        loadTablesEdit(zones, reservations)
                            .then(function() {
                                if (vm.editState) loadReservation(reserveEdit);
                            });

                        vm.reservation.status_id = vm.statuses[0].id;
                    }).catch(function(error) {
                        message.apiError(error);
                    }).finally(function() {
                        vm.changeHour();
                        showTimeCustom();

                        vm.waitingResponse = false;
                    });
            };

            var showTimeCustom = function() {
                var tActive = $table.lastTimeEvent();
                if (tActive) vm.zones.tActive = tActive;
            };

            $scope.$watch("zones", true);

            var loadTablesEdit = function(zones, reservations) {
                var deferred = $q.defer();

                vm.zones = helper.loadTableV2(zones, [{
                    name: "reservations",
                    data: reservations
                }]);

                if ($stateParams.tables) {
                    vm.zones.tablesSelected($stateParams.tables);
                }

                if ($stateParams.guest) {
                    if (~~Number($stateParams.guest) > 0) {
                        vm.reservation.covers = parseInt($stateParams.guest);
                    }
                }

                setMaxIndex();

                deferred.resolve();

                return deferred.promise;
            };

            vm.changeDate = function() {
                var date = moment(vm.date);

                if (!date.isValid()) {
                    reset();
                    return message.error("Fecha invalida no se puede cargar las zonas");
                }

                // forzar recarga de datos: zonas|turnos|bloqueos
                reload = true;
                InitModule(date.format("YYYY-MM-DD"));
            };

            var initialDate = function() {
                var date = moment($stateParams.date, "YYYY-MM-DD", true);

                if (!date.isValid()) {
                    return message.error("Fecha invalida no se puede cargar las zonas");
                }

                vm.date = new Date(date.format("YYYY-MM-DD").replace(/-/g, '\/'));

                InitModule(date.format("YYYY-MM-DD"));
            };

            var isEditSate = function() {
                var state = $state.current.name;
                editState = state == "mesas.floor.reservation.edit" || state == "mesas.book-reservation-edit" || state == "mesas.guest.view.reservation-edit" || state == "mesas.grid-reservation-edit";
                vm.editState = editState;
            };

            var redirect = function() {
                var state = $state.current.name;

                if (state == "mesas.book-reservation-add" || state == "mesas.book-reservation-add-params" || state == "mesas.book-reservation-edit") {
                    var config = BookConfigFactory.getConfig();
                    if (config !== undefined) {
                        updateParamsBook(config);
                    }
                    $state.go("mesas.book", $stateParams);
                } else if (state == "mesas.guest.view.reservation-edit") {
                    $state.go("mesas.guest.view");
                } else if (state == "mesas.grid-reservation-edit" || state == "mesas.grid-reservation-add") {
                    historyBack();
                }  else {
                    $state.go("mesas.floor.reservation");
                }
            };

            var updateParamsBook = function(config) {
                if (config.url !== null && config.url !== "" && config.reservationView === true) {
                    $stateParams.turns = config.url.turns;
                    $stateParams.sources = config.url.sources;
                    $stateParams.zones = config.url.zones;
                    $stateParams.sort = config.url.sort;
                }
            };

            /**
             * Select guest: men woman children
             */
            vm.sumar = function(guest) {
                vm.reservation.guests[guest]++;
                totalGuests();
            };

            vm.restar = function(guest) {
                var quantity = vm.reservation.guests[guest];
                if (quantity - 1 >= 0) {
                    vm.reservation.guests[guest]--;
                    totalGuests();
                }
            };

            var totalGuests = function() {
                vm.reservation.guests.total = vm.reservation.guests.men + vm.reservation.guests.women + vm.reservation.guests.children;
            };
            /**
             * END Select guest: men woman children
             */

            (function Init() {
                isEditSate();
                sizeLienzo();
                initialDate();
            })();
        }
    ]);
angular.module("reservation.filter", [])
.filter("zoneFilter", function() {
    return function(list, filter) {
        return list.filter(function(item) {
            return filter.indexOf(item.id) !== -1;
        });
    }
});
angular.module('reservation.service', [])
    .factory("reservationService", ["$http", "HttpFactory", "ApiUrlMesas", "ApiUrlRoot", "quantityGuest", "$q",
        function(http, HttpFactory, ApiUrlMesas, ApiUrlRoot, quantityGuest, $q) {
            var zones, servers, resStatus, turns, blocks, tblocks, tags, reservations, configuration;

            /**
             * Lista negra de eventos de WS que no deben ejecutarse,
             * por que el usuario actual es quien las emitio
             * @type {object}
             */
            var blackListMethods = {};
            blackList = [];

            blackListMethods.add = function(key) {
                blackList.push(key);
            };

            blackListMethods.key = function(obj) {
                var key = Math.random().toString(36).substring(2, 7);
                this.add(key);

                if (obj) {
                    obj.key = key;
                    return obj;
                }

                return key;
            };

            blackListMethods.contains = function(key) {
                return blackList.indexOf(key) !== -1;
            };
            /**
             * END
             */

            return {
                blackList: blackListMethods,
                reservationMaster: function(date, reservation) {
                    return http.get(ApiUrlMesas + "/web-app/reservation" + (reservation ? "/" + reservation : ""), {
                        params: {
                            date: date
                        }
                    });
                },
                blockMaster: function(date, block) {
                    return http.get(ApiUrlMesas + "/web-app/block" + (block ? "/" + block : ""), {
                        params: {
                            date: date
                        }
                    });
                },
                save: function(data) {
                    return http.post(ApiUrlMesas + "/table/reservation", data);
                },
                patchReservation: function(data) {
                    return http.patch(ApiUrlMesas + "/reservations/" + data.id, data);
                },
                quickCreate: function(data) {
                    return http.post(ApiUrlMesas + "/table/reservation/quickcreate", data);
                },
                edit: function(id, data) {
                    return http.put(ApiUrlMesas + "/table/reservation/" + id, data);
                },
                quickEdit: function(id, data) {
                    return http.put(ApiUrlMesas + "/table/reservation/" + id + "/quickedit", data);
                },
                cancel: function(id, data) {
                    return http.put(ApiUrlMesas + "/table/reservation/" + id + "/cancel", data);
                },
                sit: function(id, data) {
                    return http.put(ApiUrlMesas + "/table/reservation/" + id + "/sit", data);
                },
                guestList: function(id, data) {
                    return http.put(ApiUrlMesas + "/table/reservation/" + id + "/guest-list", data);
                },
                createWaitList: function(data) {
                    return http.post(ApiUrlMesas + "/waitlist", data);
                },
                updateWaitList: function(data) {
                    return http.put(ApiUrlMesas + "/waitlist", data);
                },
                deleteWaitList: function(id, data) {
                    return http.delete(ApiUrlMesas + "/waitlist/" + id, {
                        params: data
                    });
                },
                getReservation: function(id) {
                    return http.get(ApiUrlMesas + "/table/reservation/" + id + "/edit");
                },
                getZones: function(date, reload) {
                    zones = HttpFactory.get(ApiUrlMesas + "/calendar/" + date + "/zones", null, zones, reload);
                    return zones;
                },
                getServers: function(reload) {
                    servers = HttpFactory.get(ApiUrlMesas + "/servers", null, servers, reload);
                    return servers;
                },
                getStatuses: function(reload) {
                    resStatus = HttpFactory.get(ApiUrlRoot + "/reservation/status", null, resStatus, reload);
                    return resStatus;
                },
                getTurns: function(date, reload) {
                    turns = HttpFactory.get(ApiUrlMesas + "/calendar/" + date + "/shifts", null, turns, reload);
                    return turns;
                },
                getBlocks: function(date, reload) {
                    blocks = HttpFactory.get(ApiUrlMesas + "/blocks/tables", {
                        params: {
                            date: date
                        }
                    }, blocks, reload);
                    return blocks;
                },
                getTBlocks: function(date, reload) {
                    tblocks = HttpFactory.get(ApiUrlMesas + "/blocks", {
                        params: {
                            date: date
                        }
                    }, tblocks, reload);
                    return tblocks;
                },
                getGuestList: function(name) {
                    return http.get(ApiUrlMesas + "/guests", {
                        params: {
                            name: name,
                            page_size: 8
                        }
                    });
                },
                getReservationTags: function(reload) {
                    tags = HttpFactory.get(ApiUrlMesas + "/reservation/tag", null, tags, reload);
                    return tags;
                },
                getReservations: function(reload, params) {
                    params = (params === undefined || params === null) ? "" : params;
                    reservations = HttpFactory.get(ApiUrlMesas + "/reservations?" + params, null, reservations, reload);
                    return reservations;
                },
                getReservationsSearch: function(reload, params) {
                    params = (params === undefined || params === null) ? "" : params;
                    reservations = HttpFactory.get(ApiUrlMesas + "/reservations/search?" + params, null, reservations, reload);
                    return reservations;
                },
                getConfigurationRes: function(reload) {
                    configuration = HttpFactory.get(ApiUrlMesas + "/configuration/reservations", null, configuration, reload);
                    return configuration;
                },
                getGuest: function() {
                    var deferred = $q.defer();

                    var guests = [];
                    guests.push({
                        id: 1,
                        name: "1 Invitado"
                    });
                    for (var i = 2; i < quantityGuest; i++) {
                        guests.push({
                            id: i,
                            name: (i + " Invitados")
                        });
                    }
                    deferred.resolve(guests);
                    return deferred.promise;
                },
                getDurations: function() {
                    var deferred = $q.defer();

                    var durations = [];

                    var date_ini = moment("2000-01-01 00:00:00");

                    for (var i = 1; i < 33; i++) {
                        date_ini.add(15, "minutes");
                        var duration = {};
                        duration.time = date_ini.format("HH:mm:ss");

                        if (date_ini.hour() > 0) {
                            if (date_ini.minute() === 0) {
                                duration.name = date_ini.format("H[hr]");
                            } else {
                                duration.name = date_ini.format("H[hr] mm[min]");
                            }
                        } else {
                            duration.name = date_ini.format("mm[min]");
                        }

                        durations.push(duration);
                    }

                    deferred.resolve(durations);
                    return deferred.promise;
                },
                getHours: function(turns) {
                    var deferred = $q.defer();

                    var hours = [];
                    var timeDefault = "";
                    var objDefault;
                    var data = {};

                    var minutes = parseInt(moment().format("mm"));
                    var now = moment().add(-(minutes % 15), "minutes").second(0).millisecond(0);
                    var timeDefaultIsEstablished = false;

                    var addHour = function(date_ini, item, minutes, index) {
                        var hour = {};

                        hour.turn = item.name;
                        hour.time = date_ini.format("HH:mm:ss");
                        hour.name = date_ini.format("H:mm A");
                        hour.turn_id = item.turn.id;
                        hour.zones = item.turn.zones;
                        hour.index = index;
                        hours.push(hour);

                        if (!timeDefaultIsEstablished) {
                            if (date_ini.isSameOrAfter(now)) {
                                timeDefault = hour.time;
                                objDefault = hour;
                                timeDefaultIsEstablished = true;
                            }
                        }

                        date_ini.add(minutes, "minutes");
                    };

                    angular.forEach(turns, function(item) {
                        if (item.turn !== null) {
                            var date_ini = moment(item.turn.hours_ini, "HH:mm:ss");
                            var date_end = moment(item.turn.hours_end, "HH:mm:ss");
                            var nextDay = getHourNextDay(item.turn.hours_ini, item.turn.hours_end);

                            var indexini = getIndexHour(date_ini.format("HH:mm:ss"), 0);
                            var indexend = getIndexHour(date_end.format("HH:mm:ss"), nextDay);
                            if (indexini > indexend) {
                                indexend += 96;
                            }

                            var date_end_hour = date_end.format("HH:mm:ss");
                            for (var i = indexini; i < indexend; i++) {
                                /*if (date_ini.format("HH:mm:ss") == date_end_hour) {
                                    break;
                                }*/
                                addHour(date_ini, item, 15, i);
                            }
                        }
                    });

                    data.hours = hours;

                    if (!timeDefault) {
                        if (hours.length) data.default = hours[hours.length - 1].time;
                        data.objDefault = hours[hours.length - 1];
                    } else {
                        data.default = timeDefault;
                        data.objDefault = objDefault;
                    }
                    deferred.resolve(data);
                    return deferred.promise;
                }
            };
        }
    ])
    .factory("reservationHelper", ["TableFactory", "$interval", "$q", function(TableFactory, $interval, $q) {
        var loadTable = function(zones) {
            var dataZones = [];
            dataZones.tables = [];
            dataZones.tActive = null;

            var position_text = ["", "top", "right", "bottom", "left"];
            angular.forEach(zones, function(zone, zone_index) {
                var item = {};
                var tables = [];
                angular.forEach(zone.tables, function(data) {
                    var position = data.config_position.split(",");
                    var left = (parseInt(position[0]) / 675) * 100 + "%";
                    var top = (parseInt(position[1]) / 675) * 100 + "%";
                    var size = TableFactory.getLabelSize(data.config_size) + "-relative";
                    var dataTable = {
                        zone: {
                            index: zone_index,
                            name: zone.name,
                            number: zone_index + 1
                        },
                        name: data.name,
                        minCover: data.min_cover,
                        maxCover: data.max_cover,
                        left: left,
                        top: top,
                        shape: TableFactory.getLabelShape(data.config_forme),
                        size: size,
                        rotate: data.config_rotation,
                        position_text: position_text[data.config_rotation_text],
                        id: data.id,
                        status: data.status,
                        reservations: {
                            active: null,
                            data: []
                        },
                        blocks: {
                            active: null,
                            data: []
                        },
                        blocksPermanent: {
                            active: null,
                            data: data.turns
                        },
                        time: {
                            seated: {
                                text: null,
                                color: "#33c200"
                            },
                            complete: {
                                text: null,
                                color: "#e7b300"
                            },
                            nextTime: {
                                text: null,
                                color: "#ed615b"
                            },
                            nextTimeAll: []
                        },
                        events: [],
                        suggested: false,
                        selected: false,
                        block: false,
                        occupied: false,
                        server: {
                            color: null,
                        },
                        borderColor: function() {
                            if (this.reservations.active) {
                                if (this.reservations.active.server) {
                                    return "2px solid " + this.reservations.active.server.color;
                                }
                            }
                            if (this.server) {
                                return "2px solid " + this.server.color;
                            }
                            return null;
                        }
                    };

                    if (data.status == 1) {
                        tables.push(dataTable);
                    }
                });
                item.name = zone.name;
                item.id = zone.id;
                item.tables = tables;
                dataZones.push(item);
                Array.prototype.push.apply(dataZones.tables, tables);
            });

            return dataZones;
        };

        var dataZones;
        var loadTableV2 = function(zones, add) {
            dataZones = loadTable(zones);

            /**
             * Funciones internas
             */
            // dataZones.setColorTables = setColorTables;
            dataZones.tablesSelected = tablesSelected;
            dataZones.notSelect = notSelect;
            dataZones.clearSelected = clearSelected;
            dataZones.tableFilter = tableFilter;
            dataZones.tableFilterClear = tableFilterClear;
            dataZones.getZoneForTables = getZoneForTables;
            /**
             * END
             */

            /**
             * Funciones de cambios de estado con el tiempo
             */
            allCases.blocksPermanent();
            var objectType = Object.prototype.toString.call(add);
            if (objectType == "[object Object]") {
                if (typeof allCases[add.name] == "function") {
                    allCases[add.name](add.data);
                }
            } else if (objectType == "[object Array]") {
                angular.forEach(add, function(a) {
                    if (typeof allCases[a.name] == "function") {
                        allCases[a.name](a.data);
                    }
                });
            }
            /**
             * END
             */

            return dataZones;
        };

        /**
         * Funciones de manejo interno
         */
        var tablesSelected = function(selectTables) {
            angular.forEach(this.tables, function(table) {
                angular.forEach(selectTables, function(selectTable) {
                    if (table.id == selectTable.id) {
                        table.selected = true;
                    }
                });
            });
        };
        var notSelect = function(tableObj) {
            angular.forEach(this.tables, function(table) {
                if (table.id == tableObj.id) {
                    table.selected = false;
                }
            });
        };
        var clearSelected = function() {
            angular.forEach(this.tables, function(table) {
                table.selected = false;
            });
        };
        var tableFilter = function(cant) {
            // Manejo estatico de tiempo de reserva por cantidad  de invitados
            var start_time = moment().add(-moment().minutes() % 15, "minutes").second(0).millisecond(0);
            var end_time = start_time.clone().add((60 + 15 * cant), "minutes");
            // console.log(start_time.format("HH:mm:ss"), end_time.format("HH:mm:ss"));

            angular.forEach(this.tables, function(table) {
                angular.forEach(table.blocks.data, function(block) {
                    if (block.res_reservation_status_id < 4) {
                        var start_block = moment(block.start_time, "HH:mm:ss");
                        var end_block = moment(block.end_time, "HH:mm:ss");
                        if ((start_time.isBetween(start_block, end_block, null, "()")) ||
                            (end_time.isBetween(start_block, end_block, null, "()")) ||
                            (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {
                            if (block.res_reservation_id !== null) {
                                table.occupied = true;
                                table.suggested = false;
                            } else {
                                table.block = true;
                                table.suggested = false;
                            }
                        } else {
                            if (block.res_reservation_id !== null) {
                                table.occupied = false;
                            } else {
                                table.block = false;
                            }
                        }
                    }
                });
                if (cant >= table.minCover && cant <= table.maxCover && !table.reservations.active) {
                    if (!table.occupied && !table.block) {
                        table.suggested = true;
                    }
                }
            });
        };
        var tableFilterClear = function() {
            angular.forEach(this.tables, function(table) {
                table.occupied = false;
                table.block = false;
                table.suggested = false;
            });
        };
        var getZoneForTables = function(tables) {
            var indexes = [];
            var aux = [];
            for (var i = 0; i < this.tables.length; i++) {
                for (var x = 0; x < tables.length; x++) {
                    if (this.tables[i].id == tables[x].id) {
                        if (aux.indexOf(this.tables[i].zone.name) === -1) {
                            indexes.push(this.tables[i].zone);
                            aux.push(this.tables[i].zone.name);
                        }
                    }
                }
            }

            return indexes;
        };
        /**
         * END
         */

        var allCases = {
            blocks: function(blocks) {
                try {
                    angular.forEach(dataZones.tables, function(table) {
                        angular.forEach(blocks, function(block) {
                            angular.forEach(block.tables, function(bTable) {
                                if (table.id == bTable.id) {
                                    table.blocks.data.push(block);
                                    var event = addEvent(table, block.start_time, block.end_time,
                                        function(table, block) {
                                            table.blocks.active = block;
                                        },
                                        function(table) {
                                            table.blocks.active = null;
                                        }, block);
                                    block.eventsID = block.eventsID || [];
                                    block.eventsID.push(event);
                                }
                            });
                        });

                        table.blocks.add = function(block, pref) {
                            if (Object.prototype.toString.call(block) == "[object Object]") {
                                table.blocks.data.push(block);
                                var event = addEvent(table, block.start_time, block.end_time,
                                    function(table, block) {
                                        table.blocks.active = block;
                                    },
                                    function(table) {
                                        table.blocks.active = null;
                                    }, block);
                                block.eventsID = block.eventsID || [];
                                block.eventsID.push(event);
                            }
                        };
                        table.blocks.remove = function(block) {
                            if (Object.prototype.toString.call(block) == "[object Object]") {
                                angular.forEach(table.blocks.data, function(data, i) {
                                    if (data.id == block.id) {
                                        if (data.eventsID) {
                                            angular.forEach(data.eventsID, function(event) {
                                                $interval.cancel(event.timeoutID);
                                            });
                                        }
                                        if (table.blocks.active) {
                                            if (table.blocks.active.id == data.id) {
                                                table.blocks.active = null;
                                            }
                                        }
                                        table.blocks.data.splice(i, 1);
                                    }
                                });
                            }
                        };
                    });
                } catch (e) {
                    console.log("Blocks :" + e);
                }
            },
            blocksPermanent: function() {
                angular.forEach(dataZones.tables, function(table) {
                    if (Object.prototype.toString.call(table.blocksPermanent.data) == "[object Array]") {
                        angular.forEach(table.blocksPermanent.data, function(turn) {
                            var end_time = {
                                time: turn.end_time,
                                add: {
                                    minutes: 15
                                }
                            };
                            addEvent(table, turn.start_time, end_time,
                                function(table, block) {
                                    table.blocksPermanent.active = block;
                                },
                                function(table) {
                                    table.blocksPermanent.active = null;
                                }, turn);
                        });
                    }
                });
            },
            reservations: function(reservations) {
                angular.forEach(dataZones.tables, function(table) {
                    angular.forEach(reservations, function(reservation) {
                        angular.forEach(reservation.tables, function(reserv_table) {
                            if (table.id == reserv_table.id) {
                                table.reservations.data.push(reservation);
                            }
                        });
                    });
                    table.reservations.add = function(reservation, pref) {
                        if (Object.prototype.toString.call(reservation) == "[object Object]") {
                            table.reservations.data.push(reservation);
                            table.reservations.active = null;
                            table.reservations.timeReload();
                        }
                    };
                    table.reservations.remove = function(reservation) {
                        if (Object.prototype.toString.call(reservation) == "[object Object]") {
                            angular.forEach(table.reservations.data, function(data, i) {
                                if (data.id == reservation.id) {
                                    table.reservations.data.splice(i, 1);
                                }
                            });
                        }
                        table.reservations.active = null;
                        table.reservations.timeReload();
                    };
                    table.reservations.timeReload = function() {
                        table.time.seated.text = null;
                        table.time.complete.text = null;
                        table.time.nextTime.text = null;
                        table.time.nextTimeAll.length = 0;
                        angular.forEach(table.reservations.data, function(reservation) {
                            var now = moment();
                            var reserv_start = moment(reservation.datetime_input);

                            if (reservation.datetime_input && reservation.res_reservation_status_id == 4) {
                                table.reservations.active = reservation;

                                cancelEvent(table.reservations.oldEvent1);
                                table.reservations.oldEvent1 = addRecursiveEvent(table, function(table, event) {
                                    // Seated
                                    if (table.reservations.active) {
                                        var now = moment();
                                        var sit = moment(table.reservations.active.datetime_input);
                                        table.time.seated.text = moment.utc(now.diff(sit)).format("HH:mm");
                                    } else {
                                        event.cancel = true;
                                    }
                                });

                                cancelEvent(table.reservations.oldEvent2);
                                table.reservations.oldEvent2 = addRecursiveEvent(table, function(table, event) {
                                    // Complete
                                    if (table.reservations.active) {
                                        var now = moment();
                                        var reserv_end = moment(table.reservations.active.datetime_output);

                                        var time = reserv_end.diff(now);
                                        if (time > 0) {
                                            table.time.complete.text = moment.utc(time).format("HH:mm");
                                        } else {
                                            var auxTime = now.diff(reserv_end);
                                            table.time.complete.text = "-" + moment.utc(auxTime).format("HH:mm");
                                        }
                                    } else {
                                        event.cancel = true;
                                    }
                                });
                            } else {

                                //  NextTime
                                (function() {
                                    var nextTime = reserv_start.diff(now);
                                    var auxNextTime;

                                    if (!table.time.nextTime.established) {
                                        if (nextTime > 0) {
                                            table.time.nextTime.text = moment.utc(nextTime).format("HH:mm");
                                        } else {
                                            auxNextTime = now.diff(reserv_start);
                                            table.time.nextTime.text = "-" + moment.utc(auxNextTime).format("HH:mm");
                                        }
                                        table.time.nextTime.established = true;
                                    } else if (nextTime < 0) {
                                        auxNextTime = now.diff(reserv_start);
                                        table.time.nextTime.text = "-" + moment.utc(auxNextTime).format("HH:mm");
                                    }
                                })();

                                //  NextTimeAll
                                (function() {
                                    if (table.time.nextTimeAll.length < 2) {
                                        var newTime = {};
                                        newTime.text = reserv_start.format("h:mmA");
                                        newTime.time = reserv_start;
                                        table.time.nextTimeAll.push(newTime);
                                    } else {
                                        var replaceTime = function(table, reserv_start) {
                                            var established = false;
                                            angular.forEach(table.time.nextTimeAll, function(obj) {
                                                if (!established) {
                                                    if (reserv_start.isBefore(obj.time)) {
                                                        var aux = obj.time;

                                                        obj.text = reserv_start.format("h:mmA");
                                                        obj.time = reserv_start;

                                                        established = true;

                                                        return replaceTime(table, aux);
                                                    }
                                                }
                                            });
                                        };

                                        replaceTime(table, reserv_start);
                                    }
                                })();

                            }
                        });
                    };

                    table.reservations.timeReload();

                });
            },
            servers: function(servers) {
                angular.forEach(dataZones.tables, function(table) {
                    angular.forEach(servers, function(server) {
                        angular.forEach(server.tables, function(serverTable) {
                            if (table.id == serverTable.id) {
                                table.server = server;
                            }
                        });
                    });
                });
            }
        };

        var cancelEvent = function(event) {
            if (event) {
                if (event.timeoutID) {
                    $interval.cancel(event.timeoutID);
                }
            }
        };

        var addRecursiveEvent = function(table, recursiveEvent) {
            table.events = table.events || [];
            var event = newRecursiveEvent(table, recursiveEvent);
            table.events.push(event);
            return event;
        };

        var newRecursiveEvent = function(table, recursiveEvent) {
            var event = {};
            event.recursiveEvent = recursiveEvent;
            event.cancel = false;
            event.fire = function() {
                try {
                    var deferred = $q.defer();
                    if (!event.cancel) {
                        event.recursiveEvent(table, event);
                        deferred.resolve();
                    } else {
                        $interval.cancel(event.timeoutID);
                    }

                    return deferred.promise;
                } catch (e) {
                    console.log("Event error: ", e);
                }
            };
            event.fire().then(function() {
                event.timeoutID = $interval(event.fire, 60000);
            });

            return event;
        };

        var addEvent = function(table, start_time, end_time, startCallback, endCallback, arg) {
            table.events = table.events || [];
            var event = newEvent(table, start_time, end_time, startCallback, endCallback, arg);
            table.events.push(event);
            return event;
        };

        var newEvent = function(table, start_time, end_time, startEvent, endEvent, arg) {
            var event = {};
            event.start = start_time;
            event.end = end_time;
            event.startTime = datetime(start_time);
            event.endTime = datetime(end_time);
            event.startEvent = startEvent;
            event.endEvent = endEvent;
            event.fire = function() {
                try {
                    var deferred = $q.defer();
                    var time = moment();
                    // console.log(time.format("HH:mm:ss"), event.startTime.format("HH:mm:ss"), event.endTime.format("HH:mm:ss"));
                    if (time.isBetween(event.startTime, event.endTime)) {
                        event.startEvent(table, arg);
                    } else {
                        if (time.isAfter(event.endTime)) {
                            if (event.timeoutID) {
                                event.endEvent(table, arg);
                            }
                            $interval.cancel(event.timeoutID);
                        }
                    }
                    deferred.resolve();
                    return deferred.promise;
                } catch (e) {
                    console.log("Event error: ", e);
                }
            };
            event.fire().then(function() {
                event.timeoutID = $interval(event.fire, 60000);
            });

            return event;
        };

        var datetime = function(time) {
            var datetime;
            if (Object.prototype.toString.call(time) == "[object Object]") {
                datetime = moment(time.time, "HH:mm:ss").add(time.add);
            } else {
                datetime = moment(time, "HH:mm:ss");
            }
            return datetime;
        };

        return {
            loadTable: loadTable,
            loadTableV2: loadTableV2
        };
    }])
    .factory("screenHelper", ["$window", function($window) {
        var size = function(screenSize) {

            var width = $window.innerWidth;
            var height = $window.innerHeight;
            var size;

            if (width - screenSize.menu >= height - screenSize.header) {
                height -= screenSize.header;
                if (height < screenSize.minSize) {
                    size = screenSize.minSize;
                } else {
                    size = height;
                }
            } else if (height - screenSize.header >= width - screenSize.menu) {
                width -= screenSize.menu;
                if (width < screenSize.minSize) {
                    size = screenSize.minSize;
                } else {
                    size = width;
                }
            } else {
                size = screenSize.minSize;
            }

            return size - 30;
        };

        return {
            size: size,
        };
    }])
    .factory("$table", function() {
        var lastShowTimeEvent;

        return {
            lastTimeEvent: function(action) {
                if (action == "reset") {
                    lastShowTimeEvent = null;
                } else {
                    return lastShowTimeEvent;
                }
            },
            setTimeEvent: function(action) {
                lastShowTimeEvent = action;
            },
            paintTables: function(zones, tables) {
                angular.forEach(tables, function(table_use) {
                    angular.forEach(zones, function(zone) {
                        angular.forEach(zone.tables, function(table) {
                            if (table.id == table_use.id) {
                                table.selected = true;
                            }
                        });
                    });
                });
            },
            listTableSelected: function(zones, tablesSelected) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        if (table.selected) {
                            tablesSelected[table.id] = angular.copy(table);
                        } else {
                            delete tablesSelected[table.id];
                        }
                    });
                });
            },
            tablesSuggested: function(zones, cant, index) {
                var tableSuggested = null;
                angular.forEach(zones, function(zone, i) {
                    if (index >= 0) {
                        if (i != index) {
                            return;
                        }
                    }
                    angular.forEach(zone.tables, function(table) {
                        if (cant >= table.minCover && cant <= table.maxCover) {
                            if (!table.occupied && !table.block) {
                                if (!tableSuggested) tableSuggested = angular.copy(table);
                                table.suggested = true;
                            }
                        } else {
                            table.suggested = false;
                        }
                    });
                });

                return tableSuggested;
            },
            tablesBlockValid: function(zones, blocks, reservation, editState, state_param_id) {
                // console.log("------------------------------------------------");
                var start_time = moment(reservation.hour, "HH:mm:ss");
                var auxiliar = moment(reservation.duration, "HH:mm:ss");
                var end_time = start_time.clone().add(auxiliar.hour(), "h").add(auxiliar.minute(), "m");
                // console.log(start_time.format("YYYY-MM-DD HH:mm:ss"), end_time.format("YYYY-MM-DD HH:mm:ss"));
                // console.log(blocks);
                angular.forEach(blocks, function(block) {
                    var start_block = moment(block.start_time, "HH:mm:ss");
                    var end_block = moment(block.end_time, "HH:mm:ss");
                    angular.forEach(zones, function(zone) {
                        angular.forEach(zone.tables, function(table) {
                            if (table.id == block.res_table_id) {
                                if ((start_time.isBetween(start_block, end_block, null, "()")) ||
                                    (end_time.isBetween(start_block, end_block, null, "()")) ||
                                    (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {

                                    if (block.res_reservation_id !== null) {
                                        if (!editState) {
                                            table.occupied = true;
                                            table.suggested = false;
                                        } else {
                                            if (block.res_reservation_id != state_param_id) {
                                                table.occupied = true;
                                                table.suggested = false;
                                            }
                                        }
                                    } else {
                                        table.block = true;
                                        table.suggested = false;
                                    }
                                } else {
                                    if (block.res_reservation_id !== null) {
                                        table.occupied = false;
                                    } else {
                                        table.block = false;
                                    }
                                }
                            }
                        });
                    });
                });
            },
            duration: function(cant, base, interval) {
                base = base || 60;
                interval = interval || 15;
                return moment("2000-01-01").add((base + interval * cant), "minutes").format("HH:mm:ss");
            },
            tablesSuggestedDinamyc: function(tables, blocks, cant, hour) {
                // console.log(tables, blocks, cant, hour);
                // console.log("------------------------------------------------");

                var start_time = hour ? moment(hour, "HH:mm:ss") : moment();
                var auxiliar = moment("2000-01-01").add((60 + 15 * cant), "minutes");
                var end_time = start_time.clone().add(auxiliar.hour(), "h").add(auxiliar.minute(), "m");
                // console.log(start_time.format("YYYY-MM-DD HH:mm:ss"), end_time.format("YYYY-MM-DD HH:mm:ss"));
                // console.log(blocks);
                angular.forEach(blocks, function(block) {
                    if (tableSuggested) return; // Si ya se sugirio una mesa sale del bucle
                    var start_block = moment(block.start_time, "HH:mm:ss");
                    var end_block = moment(block.end_time, "HH:mm:ss");
                    angular.forEach(tables, function(table) {
                        if (table.id == block.res_table_id) {
                            // Comprobar si el horario coincide con una reservacion o bloqueo
                            if ((start_time.isBetween(start_block, end_block, null, "()")) ||
                                (end_time.isBetween(start_block, end_block, null, "()")) ||
                                (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {

                                if (block.res_reservation_id !== null) {
                                    table.occupied = true;
                                    table.suggested = false;
                                } else {
                                    block = true;
                                    table.suggested = false;
                                }
                            } else { // Caso no coincida resetea su estado. El listado de bloqueos esta en orden de hora ascendente.
                                if (block.res_reservation_id !== null) {
                                    table.occupied = false;
                                } else {
                                    table.block = false;
                                }
                            }
                        }
                    });
                });

                var tableSuggested = null;

                angular.forEach(tables, function(table) {
                    if (tableSuggested) return;
                    if (cant >= table.minCover && cant <= table.maxCover) {
                        if (!table.occupied && !table.block) {
                            if (!tableSuggested) {
                                tableSuggested = angular.copy(table);
                            }
                        }
                    }
                });

                return tableSuggested;
            },
            selectTableAllOrNone: function(zone, indicator) {
                if (indicator == "all") {
                    angular.forEach(zone.tables, function(table) {
                        table.selected = true;
                    });
                } else if (indicator == "none") {
                    angular.forEach(zone.tables, function(table) {
                        table.selected = false;
                    });
                }
            },
            setBorderColorForReservation: function(zones, blocks) {
                var hour = moment();

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.server.reservation = null;
                        table.class.name = null;
                    });
                });

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(blocks, function(block) {
                            if (table.id == block.res_table_id) {
                                var start_block = moment(block.start_time, "HH:mm:ss");
                                var end_block = moment(block.end_time, "HH:mm:ss");
                                if (hour.isBetween(start_block, end_block, null, "()") || block.res_reservation_status_id == 4) {
                                    if (block.res_server_id) {
                                        table.server.setReservation(block.res_server.color);
                                    }
                                    table.class.setStatusClass(block.res_reservation_status_id);

                                    table.reservations.active = block;

                                    if (block.res_reservation_id === null) {
                                        table.block = true;
                                        table.blockStatic = true;
                                    }
                                } else {
                                    if (block.res_reservation_id === null) {
                                        table.block = false;
                                        table.blockStatic = false;
                                    }
                                }
                            }
                        });
                    });
                });
            },
            setColorTable: function(zones, servers) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(servers, function(server) {
                            angular.forEach(server.tables, function(serverTable) {
                                if (table.id == serverTable.id) {
                                    table.server.setDefault(server.color);
                                }
                            });
                        });
                    });
                });
            },
            getReservationTables: function(zones, blocks, reservation_id) {
                var reservationTables = "";
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(blocks, function(block) {
                            if (table.id == block.res_table_id) {
                                if (block.res_reservation_id == reservation_id) {
                                    reservationTables += table.name + ", ";
                                }
                            }
                        });
                    });
                });

                return reservationTables.substring(0, reservationTables.length - 2);
            },
            clearSelected: function(zones) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.selected = false;
                    });
                });
            },
            getZoneIndexForTable: function(zones, serverTables) {
                if (serverTables.length === 0) {
                    return 0;
                }
                var index = null;
                angular.forEach(zones, function(zone, zone_index) {
                    if (index === null) {
                        angular.forEach(zone.tables, function(table) {
                            if (index === null) {
                                angular.forEach(serverTables, function(serverTable) {
                                    if (index === null) {
                                        if (table.id == serverTable.id) {
                                            index = zone_index;
                                        }
                                    }
                                });
                            }
                        });
                    }
                });

                return index;
            },
            tablesSelected: function(zones, serverTables) {
                if (serverTables.length === 0) {
                    return;
                }
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        angular.forEach(serverTables, function(serverTable) {
                            if (table.id == serverTable.id) {
                                table.selected = true;
                            }
                        });
                    });
                });
            },
            tableFilter: function(zones, blocks, cant) {
                // Manejo estatico de tiempo de reserva por cantidad  de invitados
                var start_time = moment().add(-moment().minutes() % 15, "minutes").second(0).millisecond(0);
                var aux_duration = moment("2000-01-01").add((60 + 15 * cant), "minutes");
                var end_time = start_time.clone().add(aux_duration.hour(), "hours").add(aux_duration.minute(), "minutes");
                // console.log(start_time.format("HH:mm:ss"), end_time.format("HH:mm:ss"));
                angular.forEach(blocks, function(block) {
                    var start_block = moment(block.start_time, "HH:mm:ss");
                    var end_block = moment(block.end_time, "HH:mm:ss");
                    angular.forEach(zones, function(zone) {
                        angular.forEach(zone.tables, function(table) {
                            if (table.id == block.res_table_id && block.res_reservation_status_id < 14) {
                                if ((start_time.isBetween(start_block, end_block, null, "()")) ||
                                    (end_time.isBetween(start_block, end_block, null, "()")) ||
                                    (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {
                                    if (block.res_reservation_id !== null) {
                                        table.occupied = true;
                                        table.suggested = false;
                                    } else {
                                        table.block = true;
                                        table.suggested = false;
                                    }
                                } else {
                                    if (block.res_reservation_id !== null) {
                                        table.occupied = false;
                                    } else {
                                        table.block = false;
                                    }
                                }
                            }
                        });
                    });
                });

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        if (cant >= table.minCover && cant <= table.maxCover && !table.class.name) {
                            if (!table.occupied && !table.block) {
                                table.suggested = true;
                            }
                        }
                    });
                });
            },
            tableFilterClear: function(zones) {
                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.occupied = false;
                        if (!table.blockStatic) table.block = false;
                        table.suggested = false;
                    });
                });
            },
            makeTime: function(zones, blocks, reservations, type) {
                // console.log(zones, blocks, reservations, type);
                /**
                 * Variable de apollo para grouptime, en metodo nextTime
                 */
                var lastTime;

                lastShowTimeEvent = type;

                angular.forEach(zones, function(zone) {
                    angular.forEach(zone.tables, function(table) {
                        table.time = {};
                        table.grouptime = [];
                    });
                });

                angular.forEach(reservations, function(reservation) {
                    angular.forEach(blocks, function(block) {
                        if (reservation.id == block.res_reservation_id) {
                            angular.forEach(zones, function(zone) {
                                angular.forEach(zone.tables, function(table) {
                                    if (table.id == block.res_table_id) {
                                        var now, start;
                                        if (reservation.datetime_input && reservation.res_reservation_status_id == 4) {
                                            now = moment();

                                            if (type == "seated") {
                                                var input = moment(reservation.datetime_input);
                                                table.time.text = moment.utc(now.diff(input)).format("HH:mm");
                                            } else if (type == "complete") {
                                                var out = moment(block.end_time, "HH:mm:ss");
                                                var time = out.diff(now);
                                                if (time > 0) {
                                                    table.time.text = moment.utc(time).format("HH:mm");
                                                } else {
                                                    var auxTime = now.diff(out);
                                                    table.time.text = "-" + moment.utc(auxTime).format("HH:mm");
                                                }
                                                table.time.color = "#e7b300";
                                            }
                                        } else if (type == "nextTime") {
                                            now = moment();
                                            start = moment(block.start_time, "HH:mm:ss");
                                            // console.log(reservation.id, block.res_table_id,  start.format("HH:mm:ss"));
                                            var nextTime = start.diff(now);
                                            var auxNextTime;

                                            if (!table.time.established) {
                                                if (nextTime > 0) {
                                                    table.time.text = moment.utc(nextTime).format("HH:mm");
                                                } else {
                                                    auxNextTime = now.diff(start);
                                                    table.time.text = "-" + moment.utc(auxNextTime).format("HH:mm");
                                                }
                                                table.time.color = "#ed615b";
                                                table.time.established = true;
                                            } else if (nextTime < 0) {
                                                auxNextTime = now.diff(start);
                                                table.time.text = "-" + moment.utc(auxNextTime).format("HH:mm");
                                            }
                                        } else if (type == "nextTimeAll") {
                                            now = moment();
                                            start = moment(block.start_time, "HH:mm:ss");

                                            if (table.grouptime.length < 2) {
                                                var newTime = {};
                                                newTime.text = start.format("HH:mmA");
                                                newTime.time = start;
                                                table.grouptime.push(newTime);
                                            } else {
                                                var replaceTime = function(table, start) {
                                                    var established = false;
                                                    angular.forEach(table.grouptime, function(obj) {
                                                        if (!established) {
                                                            if (start.isBefore(obj.time)) {
                                                                var aux = obj.time;

                                                                obj.text = start.format("HH:mmA");
                                                                obj.time = start;

                                                                established = true;

                                                                return replaceTime(table, aux);
                                                            }
                                                        }

                                                    });
                                                };

                                                replaceTime(table, start);
                                            }
                                        }
                                    }
                                });
                            });
                        }
                    });
                });
            }
        };
    });
angular.module('turn.app', ['turn.controller', 'turn.service', 'turn.directive'])
    .config(function($stateProvider, $urlRouterProvider) {
        $stateProvider
            .state('mesas.turn', {
                url: '/config/turn',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/turn/view/index.html',
                        controller: 'TurnCtrl',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Lista de turnos';
                    }
                }
            })
            .state('mesas.turn.active', {
                url: '/turn-active',
                templateUrl: '/js/app/tables/turn/view/turn-active.html',
                resolve: {
                    $title: function() {
                        return 'Lista de turnos activos';
                    }
                }
            })
            .state('mesas.turn.inactive', {
                url: '/turn-inactive',
                templateUrl: '/js/app/tables/turn/view/turn-inactive.html',
                resolve: {
                    $title: function() {
                        return 'Lista de turnos inactivos';
                    }
                }
            })
            .state('mesas.turn.create', {
                url: '/new',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/turn/view/turn-create.html',
                        controller: 'TurnCreateCtrl',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Crear turno';
                    }
                }
            })
            .state('mesas.turn.edit', {
                url: '/:turn/edit',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/turn/view/turn-edit.html',
                        controller: 'TurnCreateCtrl',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Editar turno';
                    }
                }
            });
    });
angular.module('turn.controller', ['form.directive', 'localytics.directives'])
    .controller('TurnCtrl', function($scope, $stateParams, TurnFactory, MenuConfigFactory) {

        $scope.turns = {
            active: [],
            inactive: []
        };

        var init = function() {
            MenuConfigFactory.menuActive(1);
            getTurns({
                with: "zones|type_turn|calendar"
            });
        };

        var getTurns = function(options) {
            options = getAsUriParameters(options);

            TurnFactory.listTurns(options).then(
                function success(response) {
                    $scope.turns.active = response.active;
                    $scope.turns.inactive = response.inactive;
                },
                function error(response) {
                    messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
                });
        };

        $scope.deleteTurn = function(idTurn) {

            var options = {
                showCancelButton: true,
                confirmButtonText: "Si",
                cancelButtonText: "No",
            };

            message.confirmButton("Eliminar turno", "¿Estas seguro que deseas eliminar el turno ?", "info", options, function() {
                TurnFactory.deleteTurn(idTurn).then(
                    function success(response) {
                        messageAlert("Success", response.msg, "success", 2000, true);
                        getTurns({
                            with: "zones|type_turn|calendar"
                        });
                    },
                    function error(response) {
                        messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
                    }
                );
            });
        };

        init();
    })
    .controller('TurnCreateCtrl', function($scope, $stateParams, $state, $filter, $uibModal, TurnFactory, TypeTurnFactory,
        DateFactory, MenuConfigFactory, $timeout) {

        $scope.turnData = {
            id: '',
            name: '',
            hours_ini: '',
            hours_end: '',
            res_type_turn_id: '',
            status: 1,
            turn_zone: [],
            days: [],
            turn_time: []
        };

        $scope.dayHide = false;

        $scope.days = [];

        $scope.turnDataClone = {}; //para validar si ha ocurrido algun cambio en la data (editar)

        $scope.turnForm = {
            hours_ini: '',
            hours_end: '',
            type_turn: '',
            saveClick: false, // validamos que no se haga dbClik al guardar
            days: []
        };

        $scope.zonesTable = false; //validar si se oculta la lista de zonas (cuando estamos en mesas)

        $scope.typeTurns = {
            data: ''
        };

        $scope.turnsList = {};

        $scope.turnZoneAdd = {
            zones_id: [],
            zones_data: [],
            zonesTables: [], //van las tablas y sus reglas, zone_id , tables -> rules
            zonesDeleted: [] // las zonas eliminadas
        };

        $scope.zoneSelected = {
            id: '',
            name: '',
            rule: 1,
            tables: [],
            timesDefault: [],
            tablesId: [], //cuando marcamos check en la mesa se agrega
            chkRulesAll: {
                online: true,
                local: true,
                disabled: true
            }
        };

        $scope.mesasCheckAll = false;

        $scope.formDataDefault = {
            hours_ini: [],
            hours_end: [],
            listAvailability: []
        };

        //Cambia a true cuando abrimos por primera vez el modal,asi no ejecuta el mostrar todos siempre (solo una vez)
        $scope.validateModalZones = [];

        //tiempo de turno
        var dataTurnTime = {
            data_final: [],
            data_temporal: []
        };

        var init = function() {
            $scope.formDataDefault.listAvailability = TurnFactory.initAvailability();

            listHourIni();
            listHourEnd("create");

            loadDataTurnoEdit();
            getTypeTurns();
            listDays();

            angular.element("#box-tables div ").addClass("fadeOut");
            MenuConfigFactory.menuActive(1);

            if ($stateParams.turn === undefined) {
                $scope.generatedTimeTable(false, "create");
                dataTurnTime = TurnFactory.generatedTurnTimeDefault($scope.formDataDefault.listAvailability);
            }
        };

        var listDays = function() {
            $scope.days = getDaysWeek();
        };

        var checkedRulesDefault = function(rule) {
            switch (rule) {
                case 0:
                    $scope.zoneSelected.chkRulesAll.online = true;
                    $scope.zoneSelected.chkRulesAll.disabled = false;
                    $scope.zoneSelected.chkRulesAll.local = true;
                    break;
                case 1:
                    $scope.zoneSelected.chkRulesAll.online = true;
                    $scope.zoneSelected.chkRulesAll.disabled = true;
                    $scope.zoneSelected.chkRulesAll.local = false;
                    break;
                case 2:
                    $scope.zoneSelected.chkRulesAll.online = false;
                    $scope.zoneSelected.chkRulesAll.disabled = true;
                    $scope.zoneSelected.chkRulesAll.local = true;
                    break;
                case '-1':
                    $scope.zoneSelected.chkRulesAll.online = true;
                    $scope.zoneSelected.chkRulesAll.disabled = true;
                    $scope.zoneSelected.chkRulesAll.local = true;
                    break;
                default:
                    $scope.zoneSelected.chkRulesAll.online = true;
                    $scope.zoneSelected.chkRulesAll.disabled = true;
                    $scope.zoneSelected.chkRulesAll.local = false;
                    break;
            }
        };

        var listHourIni = function() {
            $scope.formDataDefault.hours_ini = TurnFactory.listHour(0, 95, $scope.formDataDefault.listAvailability);
            $scope.turnForm.hours_ini = $scope.formDataDefault.hours_ini[64];
        };

        var listHourEnd = function(option) {

            var hourIniIndex = parseInt($scope.turnForm.hours_ini.index) + 1;
            $scope.formDataDefault.hours_end = TurnFactory.listHour(hourIniIndex, 120, $scope.formDataDefault.listAvailability);

            if (option == "create") {
                $scope.turnForm.hours_end = $scope.formDataDefault.hours_end[0];
            }
        };

        var getTypeTurns = function() {
            TypeTurnFactory.getTypeTurns().success(function(data) {
                $scope.typeTurns.data = data.data;
                $scope.turnForm.type_turn = data.data[0];
            }).error(function(data, status, headers) {
                messageErrorApi(data, "Error", "warning");
            });
        };

        var saveTurn = function(option) {

            $scope.turnData = TurnFactory.constructStructureSave($scope.turnData, $scope.turnForm, $scope.turnZoneAdd);
            $scope.turnData.turn_time = dataTurnTime.data_final;

            TurnFactory.saveTurn($scope.turnData, option).then(
                function success(response) {
                    messageAlert("Success", "Turno registrado", "success");
                    $state.reload();
                },
                function error(response) {
                    $scope.turnForm.saveClick = false;
                    messageErrorApi(response, "Error", "warning");
                }
            );
        };

        var loadDataTurnoEdit = function() {
            if ($stateParams.turn !== undefined) {
                var params = "with=turn_zone.zone|turn_zone.rule|turn_zone.zone.tables|turn_zone.zone.turns|turn_time";

                TurnFactory.getTurn($stateParams.turn, params, $scope.formDataDefault.listAvailability).then(
                    function success(data) {
                        $scope.turnData = data.turnData;
                        $scope.turnForm = data.turnForm;
                        $scope.turnDataClone = data.turnDataClone;

                        $scope.turnZoneAdd.zones_id = data.zonesId;
                        $scope.turnZoneAdd.zones_data = data.dataZones;

                        //Parse data time turn 
                        dataTurnTime.data_final = $scope.turnData.turn_time;

                        TurnFactory.parseTurnTimeDefault(dataTurnTime, $scope.formDataDefault.listAvailability, $scope.turnData.turn_time);
                        $scope.generatedTimeTable(true, "edit");

                        if ($scope.turnData.days.length <= 0) {
                            $scope.dayHide = true;
                        }
                    },
                    function error(data) {
                        messageErrorApi(data, "Error", "warning");
                    }
                );
            }
        };

        $scope.activeDay = function() {
            if ($scope.dayHide === true) {
                $scope.dayHide = false;
            } else {
                $scope.dayHide = true;
            }
        };

        $scope.checkDay = function(dayId) {
            TurnFactory.checkDay($scope.turnData.days, dayId);
        };

        $scope.generatedTimeTable = function(hourEnd, option) {

            if (hourEnd === true) {
                listHourEnd(option);
            }

            $scope.turnData.hours_ini = $scope.turnForm.hours_ini.time;
            $scope.turnData.hours_end = $scope.turnForm.hours_end.time;

            $scope.zoneSelected.timesDefault = TurnFactory.listHour($scope.turnForm.hours_ini.index, $scope.turnForm.hours_end.index, $scope.formDataDefault.listAvailability);
        };

        //Valida el formulario
        $scope.validateSaveTurn = function(option, frmTurn) {

            $scope.turnForm.saveClick = true;

            if (frmTurn.$valid) {
                TurnFactory.validateTurn($scope.turnData, $scope.turnForm, $scope.turnDataClone).then(
                    function success(response) {

                        $scope.turnForm.saveClick = false;

                        if (response === true) {
                            messageAlert("Mensaje del sistema", "Ya existe este horario", "info");
                        }

                        if ($scope.turnZoneAdd.zones_id.length === 0) {
                            messageAlert("Mensaje del sistema", "Necesitas asignar minimo una zona", "info");
                        }

                        if (response === false && $scope.turnZoneAdd.zones_id.length > 0) {
                            saveTurn(option);
                        }
                    },
                    function error(response) {
                        $scope.turnForm.saveClick = false;
                        messageErrorApi(response, "Error", "warning");
                    }
                );
            } else {
                messageAlert("Mensaje del sistema", "Faltan datos", "info");
                $scope.turnForm.saveClick = false;
            }
        };

        $scope.showZones = function(option) {
            $uibModal.open({
                animation: true,
                templateUrl: 'myModalZones.html',
                size: 'lg',
                controller: 'ModalTurnZoneCtrl',
                resolve: {
                    turnZoneAdd: function() {
                        return $scope.turnZoneAdd;
                    },
                    optionForm: function() {
                        return option;
                    },
                    validateModalZones: function() {
                        return $scope.validateModalZones;
                    }
                }
            });
        };

        //Retonar al listado de zonas
        $scope.returnBoxZones = function() {
            $scope.zonesTable = false;

            TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);

            $scope.zoneSelected.tablesId.length = 0;
            $scope.zoneSelected.rule = 1;
        };

        $scope.deleteZone = function(zone, option) {
            var jsonZone = angular.toJson(zone);
            var zoneRule = (option == "edit" && jsonZone.indexOf("rule") != -1) ? zone.rule.id : "";

            TurnFactory.deleteZone($scope.turnZoneAdd, zone.id, zoneRule, option);
        };

        //Muestra las mesas de la zona
        $scope.showTables = function(zone, option) {
            $scope.zonesTable = true;

            $scope.zoneSelected.id = zone.id;
            $scope.zoneSelected.name = zone.name;

            angular.element("#box-zones .table").addClass("fadeOut");

            $timeout(function() {
                angular.element("#box-zones").css("display", "none");
                angular.element("#box-tables").css("display", "block");
            }, 1000);

            if (option == "edit") {
                $scope.zoneSelected.rule = zone.rule.id;
            }

            TurnFactory.getTurnZoneTables(zone.id, $stateParams.turn, option, $scope.turnZoneAdd, $scope.turnForm, $scope.zoneSelected, $scope.formDataDefault.listAvailability).then(
                function success(response) {

                    $scope.zoneSelected.tables = response;

                    var tableRuleId = TurnFactory.getTurnRuleId($scope.turnZoneAdd.zonesTables, zone.id);
                    var oneRule = TurnFactory.ruleExitsOne($scope.zoneSelected.tables, tableRuleId, $scope.turnForm);

                    tableRuleId = (oneRule == 1) ? tableRuleId : '-1';
                    checkedRulesDefault(tableRuleId);

                    TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);

                },
                function error(response) {
                    messageErrorApi(response, "Error", "warning");
                }
            );
        };
        //Selecciona todas las mesas de la zona (seleccionada)
        $scope.selectedAllTables = function() {
            TurnFactory.checkAllTableZone($scope.zoneSelected.tablesId, $scope.zoneSelected.tables, $scope.mesasCheckAll);
        };

        //Abre la ventana de disponibilidad de o 1 o varias mesas
        $scope.editTableAvailability = function() {
            $uibModal.open({
                animation: true,
                templateUrl: 'myModalTableTime.html',
                size: 'lg',
                controller: 'ModalTableTimeCtrl',
                resolve: {
                    timesDefault: function() {
                        return $scope.zoneSelected.timesDefault;
                    },
                    tablesId: function() {
                        return $scope.zoneSelected.tablesId;
                    },
                    tablesData: function() {
                        return $scope.zoneSelected.tables;
                    },
                    turnForm: function() {
                        return $scope.turnForm;
                    },
                    listAvailability: function() {
                        return $scope.formDataDefault.listAvailability;
                    },
                    turnZoneAdd: function() {
                        return $scope.turnZoneAdd;
                    },
                    zoneSelected: function() {
                        return $scope.zoneSelected;
                    }
                }
            });
        };

        //Selecciona una mesa de la zona
        $scope.checkTableZone = function(table) {
            TurnFactory.checkTableZone($scope.zoneSelected.tablesId, table.id);
            TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);
        };

        //Selecciona una regla para todas las mesas
        $scope.checkRuleTableAll = function(rule) {
            $scope.zoneSelected.rule = rule;
            checkedRulesDefault(rule);

            TurnFactory.checkRuleTableAll($scope.zoneSelected.tables, rule, $scope.turnForm);
            TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);
        };
        //Abre el modal para configurar el tiempo turno
        $scope.showTimeTurns = function() {
            $uibModal.open({
                animation: true,
                templateUrl: 'myModalTurnTime.html',
                size: 'md',
                controller: 'ModalTurnTimeCtrl',
                resolve: {
                    listAvailability: function() {
                        return $scope.formDataDefault.listAvailability;
                    },
                    dataTurnTime: function() {
                        return dataTurnTime;
                    }
                }
            });
        };

        init();
    })
    .controller('ModalTurnTimeCtrl', function($scope, $uibModalInstance, listAvailability, dataTurnTime, TurnFactory) {

        $scope.turnTime = [];

        var init = function() {
            if (dataTurnTime.data_final.length > 0) {
                $scope.turnTime = dataTurnTime.data_temporal;
            } else {
                listGuestTurnTime();
            }
        };

        var listGuestTurnTime = function() {
            var turnTime = TurnFactory.generatedTurnTimeDefault(listAvailability);
            $scope.turnTime = turnTime.data_temporal;
        };

        var prepareData = function() {
            dataTurnTime.data_final.length = 0;
            dataTurnTime.data_temporal = 0;

            angular.forEach($scope.turnTime, function(value, key) {
                var data = {
                    num_guests: key + 1,
                    time: value.hourText
                };
                dataTurnTime.data_final.push(data);
            });
            dataTurnTime.data_temporal = $scope.turnTime;
        };

        $scope.defineHours = function(option, index, indexHour) {
            indexHour = (option == "next") ? indexHour + 1 : indexHour - 1;
            indexHour = (indexHour < 1) ? 1 : indexHour;

            $scope.turnTime[index].indexHour = indexHour;
            $scope.turnTime[index].hourText = listAvailability[indexHour].time_original;
        };

        $scope.defineConfigDefault = function() {
            $scope.turnTime.length = 0;
            listGuestTurnTime();
        };

        $scope.saveTurnTime = function() {
            prepareData();
            $uibModalInstance.close();
        };

        $scope.closeModal = function() {
            $uibModalInstance.dismiss('cancel');
        };

        init();
    })
    .controller('ModalTableTimeCtrl', function($scope, $uibModalInstance, timesDefault, tablesId,
        tablesData, turnForm, listAvailability, turnZoneAdd, zoneSelected, TurnFactory) {
        $scope.timesTables = [];

        $scope.rules = {};
        $scope.rules.online = [];
        $scope.rules.disabled = [];
        $scope.rules.local = [];
        $scope.rules.value = 1;
        $scope.rules.dataTemp = [];
        $scope.rulesAll = {
            online: false,
            disabled: false,
            local: false
        };

        var tableItem = [];

        var init = function() {
            listTime();
            showRulesTable();
        };

        var listTime = function() {
            $scope.timesTables = timesDefault;
        };

        var getRuleZone = function(option) {
            var zone = TurnFactory.searchZoneByZoneAdd(turnZoneAdd.zonesTables, zoneSelected.id);
            var oneRule = TurnFactory.ruleExitsOne(zoneSelected.tables, zone.res_turn_rule_id, turnForm);

            if (oneRule == 1 || option == 2) {
                switch (zone.res_turn_rule_id) {
                    case 0:
                        $scope.rulesAll.disabled = true;

                        updateCheckRuleAll($scope.rules.local, false);
                        updateCheckRuleAll($scope.rules.disabled, true);
                        updateCheckRuleAll($scope.rules.online, false);

                        break;
                    case 1:
                        $scope.rulesAll.local = true;

                        updateCheckRuleAll($scope.rules.local, true);
                        updateCheckRuleAll($scope.rules.disabled, false);
                        updateCheckRuleAll($scope.rules.online, false);

                        break;
                    case 2:
                        $scope.rulesAll.online = true;

                        updateCheckRuleAll($scope.rules.local, false);
                        updateCheckRuleAll($scope.rules.disabled, false);
                        updateCheckRuleAll($scope.rules.online, true);

                        break;
                    default:
                        $scope.rulesAll.local = true;

                        updateCheckRuleAll($scope.rules.local, true);
                        updateCheckRuleAll($scope.rules.disabled, false);
                        updateCheckRuleAll($scope.rules.online, false);

                        break;
                }
            }
        };

        var setModalRulesTables = function(table, turnForm, ruleId) {
            for (var i = turnForm.hours_ini.index; i <= turnForm.hours_end.index; i++) {
                ruleId = table[0].availability[i].rule_id;

                if (ruleId !== null) {
                    ruleId = ruleId;
                }

                switch (ruleId) {
                    case 0:
                        $scope.rules.disabled[i] = true;
                        break;
                    case 1:
                        $scope.rules.local[i] = true;
                        break;
                    case 2:
                        $scope.rules.online[i] = true;
                        break;
                    default:
                        $scope.rules.local[i] = true;
                        break;
                }
            }
        };

        var showRulesTable = function() {
            var zoneRuleId = zoneSelected.rule;
            $scope.rules.value = zoneRuleId;

            if (tablesId.length == 1) {
                tableItem.push(TurnFactory.getTableZoneTime(tablesData, tablesId[0]));
                setModalRulesTables(tableItem, turnForm, null);
            } else {
                angular.forEach(tablesId, function(value, key) {
                    tableItem.push(TurnFactory.getTableZoneTime(tablesData, value));
                });
            }
            getRuleZone(zoneRuleId);
        };

        var updateTableRules = function(rulesTable) {
            angular.forEach(tablesData, function(value, key) {
                angular.forEach(rulesTable, function(table, key) {
                    if (table.id == value.id) {
                        value = table;
                    }
                });
            });

            tablesData = TurnFactory.setAvailabilityText(tablesData, turnForm, listAvailability);
            //var zoneData = TurnFactory.searchZoneByZoneAdd(turnZoneAdd.zonesTables, zoneSelected.id);

            if (tablesId.length == tablesData.length) {
                angular.forEach(turnZoneAdd.zonesTables, function(zone, key) {
                    if (zone.zone_id == zoneSelected.id) {
                        zone.res_turn_rule_id = $scope.rules.value;
                    }
                });
            }
        };

        var updateCheckRuleAll = function(rule, value) {
            var hoursIni = turnForm.hours_ini.index;
            var hoursEnd = turnForm.hours_end.index;

            for (var i = hoursIni; i <= hoursEnd; i++) {
                rule[i] = value;
            }
        };

        $scope.checkRuleAll = function(option) {
            switch (option) {
                case 1:
                    updateCheckRuleAll($scope.rules.local, true);
                    updateCheckRuleAll($scope.rules.disabled, false);
                    updateCheckRuleAll($scope.rules.online, false);

                    $scope.rules.value = 1;
                    break;
                case 0:
                    updateCheckRuleAll($scope.rules.local, false);
                    updateCheckRuleAll($scope.rules.disabled, true);
                    updateCheckRuleAll($scope.rules.online, false);

                    $scope.rules.value = 0;
                    break;
                case 2:
                    updateCheckRuleAll($scope.rules.local, false);
                    updateCheckRuleAll($scope.rules.disabled, false);
                    updateCheckRuleAll($scope.rules.online, true);

                    $scope.rules.value = 2;
                    break;
            }

            angular.forEach($scope.timesTables, function(value, key) {
                TurnFactory.checkRuleTable(value.index, $scope.rules.value, tableItem, $scope.rules.dataTemp);
            });
        };

        $scope.checkRule = function(timeIndex, value) {
            TurnFactory.checkRuleTable(timeIndex, value, tableItem, $scope.rules.dataTemp);
        };

        $scope.saveRules = function() {
            var rulesTable = TurnFactory.saveRuleTable(tableItem, $scope.rules.dataTemp);
            updateTableRules(rulesTable);
            $uibModalInstance.close();
        };

        $scope.closeModal = function() {
            $uibModalInstance.dismiss('cancel');
        };

        init();
    })
    .controller('ModalTurnZoneCtrl', function($scope, $uibModalInstance, TurnFactory, turnZoneAdd, optionForm, validateModalZones) {

        $scope.zonesList = [];
        $scope.chkAllZones = false;

        var init = function() {
            listZones();
        };

        var listZones = function() {
            TurnFactory.listZones().then(
                function succes(response) {
                    var vZones = [];

                    angular.forEach(response, function(value, key) {
                        value.checked = false;

                        if (turnZoneAdd.zones_id.indexOf(value.id) != -1) {
                            value.checked = true;
                        }

                        vZones.push(value);
                    });

                    $scope.zonesList = vZones;

                    if (optionForm == "create") {
                        if (validateModalZones.length === 0) {
                            $scope.assignZoneAll();
                            $scope.chkAllZones = true;
                            validateModalZones.push(1);
                        }
                    }

                    if ($scope.zonesList.length == turnZoneAdd.zones_id.length) {
                        $scope.chkAllZones = true;
                    }
                },
                function error(response) {
                    messageErrorApi(response, "Error", "warning");
                }
            );
        };

        var clearTurnZones = function() {
            turnZoneAdd.zones_id.length = 0;
            turnZoneAdd.zones_data.length = 0;
        };

        $scope.assignZoneAll = function() {
            if ($scope.chkAllZones) {
                clearTurnZones();
            }
            angular.forEach($scope.zonesList, function(zone, key) {
                $scope.assignZone(zone);
            });
        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        $scope.assignZone = function(zone) {
            var index = turnZoneAdd.zones_id.indexOf(zone.id);

            if (index == -1) {
                turnZoneAdd.zones_id.push(zone.id);
                turnZoneAdd.zones_data.push(zone);
                zone.checked = true;
            } else {
                turnZoneAdd.zones_id.splice(index, 1);
                turnZoneAdd.zones_data.splice(index, 1);
                zone.checked = false;
            }

            if (optionForm == "edit") {
                angular.forEach(turnZoneAdd.zonesDeleted, function(value, key) {
                    if (value.res_zone_id == zone.id) {
                        turnZoneAdd.zonesDeleted.splice(key, 1);
                    }
                });
            }
            if ($scope.zonesList.length != turnZoneAdd.zones_id.length) {
                $scope.chkAllZones = false;
            } else {
                $scope.chkAllZones = true;
            }
        };

        init();
    });
angular.module('turn.directive', []);
angular.module('turn.service', [])
    .factory('TurnDataFactory', function($http, ApiUrlMesas, ApiUrlRoot) {
        return {
            getTurns: function(vOptions) {
                return $http.get(ApiUrlMesas + "/turns?" + vOptions);
            },
            getTurn: function(vTurn, vOptions) {
                return $http.get(ApiUrlMesas + "/turns/" + vTurn + "?" + vOptions);
            },
            deleteTurn: function(vId) {
                return $http.delete(ApiUrlMesas + "/turns/" + vId);
            },
            createTurn: function(vData) {
                return $http.post(ApiUrlMesas + "/turns", vData);
            },
            updateTurn: function(vData) {
                return $http.put(ApiUrlMesas + "/turns/" + vData.id, vData);
            },
            getTurnsAvailables: function(vDate) {
                return $http.get(ApiUrlMesas + "/turns/" + vDate + "/availables");
            },
            searchTurn: function(vData) {
                return $http.get(ApiUrlMesas + "/turns/search?" + vData);
            },
            getTurnZoneTables: function(vZone, vTurn) {
                return $http.get(ApiUrlMesas + "/turns/" + vTurn + "/zones/" + vZone + "/tables");
            }
        };
    })
    .factory('TypeTurnFactory', function($http, ApiUrlMesas, ApiUrlRoot) {

        return {
            getTypeTurns: function() {
                return $http.get(ApiUrlRoot + "/type-turns");
            },
            getDaysTypeTurn: function(vTypeTurn) {
                return $http.get(ApiUrlMesas + "/type-turn/" + vTypeTurn + "/days");
            }

        };
    })
    .factory('DateFactory', function($http, $filter) {

        return {
            timeFormat: function(time) {
                return $filter('date')(time, 'HH:mm:ss');
            }
        };
    })
    .factory('TurnFactory', function(TurnDataFactory, DateFactory, ZoneFactory, $q) {

        return {
            //Listado de turnos
            listTurns: function(options) {
                var defered = $q.defer();

                TurnDataFactory.getTurns(options).success(function(data) {
                    var turnsData = {
                        active: [],
                        inactive: []
                    };

                    angular.forEach(data.data, function(turns) {
                        var vZones = [];

                        angular.forEach(turns.zones, function(zones) {
                            vZones.push(zones.name);
                        });

                        turns.zones = vZones.join(", ");

                        if (turns.calendar.length > 0) {
                            turnsData.active.push(turns);
                        } else {
                            turnsData.inactive.push(turns);
                        }

                    });

                    defered.resolve(turnsData);

                }).error(function(data, status, headers) {
                    var response = {
                        data: data,
                        status: status,
                        headers: headers
                    };
                    defered.reject(response);
                });

                return defered.promise;
            },
            //Elimina un turno
            deleteTurn: function(idTurn) {
                var defered = $q.defer();

                TurnDataFactory.deleteTurn(idTurn).then(
                    function success(response) {
                        defered.resolve(response.data);
                    },
                    function error(response) {
                        defered.reject(response);
                    }
                );

                return defered.promise;
            },
            //Valida turno
            validateTurn: function(turnData, turnForm, turnDataClone) {
                var valTime = {
                    hours_ini: DateFactory.timeFormat(turnForm.hours_ini),
                    hours_end: DateFactory.timeFormat(turnForm.hours_end),
                    type_turn: turnForm.type_turn.id
                };

                var defered = $q.defer();
                var vParams = getAsUriParameters(valTime);

                TurnDataFactory.searchTurn(vParams).success(function(data) {
                    if (data.data.length === 0 || (turnDataClone.hours_ini === valTime.hours_ini && turnDataClone.hours_end == valTime.hours_end)) {
                        defered.resolve(false);
                    } else {
                        defered.resolve(true);
                    }
                }).error(function(data, status, headers) {
                    defered.reject(data);
                });

                return defered.promise;
            },
            //Listado de zonas con sus turno
            listZones: function() {
                var defered = $q.defer();
                var params = "with=turns";

                ZoneFactory.getZones(params).success(function(data) {
                    var zones = [];
                    angular.forEach(data.data, function(value, key) {
                        var turnsData = [];
                        angular.forEach(value.turns, function(turns, key) {
                            turnsData.push(turns.name);
                        });

                        value.turns_asign = turnsData.join(", ");
                        zones.push(value);
                    });

                    defered.resolve(zones);

                }).error(function(data, status, headers) {
                    defered.reject(data);
                });

                return defered.promise;
            },
            //Guardar los datos del turno
            saveTurn: function(turnData, option) {
                var defered = null;

                if (option == "create") {
                    defered = TurnDataFactory.createTurn(turnData);
                } else {
                    defered = TurnDataFactory.updateTurn(turnData);
                }

                return defered;
            },
            //Construye la estructura para enviarla a la api
            constructStructureSave: function(turnData, turnForm, turnZoneAdd) {

                turnData.hours_ini = turnForm.hours_ini.time_original;
                turnData.hours_end = turnForm.hours_end.time_original;

                turnData.res_type_turn_id = turnForm.type_turn.id;

                var turnZones = [];
                var self = this;

                angular.forEach(turnZoneAdd.zones_id, function(zones, key) {
                    var turnRuleId = self.getTurnRuleId(turnZoneAdd.zonesTables, zones);

                    if (turnRuleId === null || turnRuleId === "") {
                        turnZones.push({
                            res_zone_id: zones,
                            res_turn_rule_id: 1,
                            tables: []
                        });
                    } else {
                        turnZones.push({
                            res_zone_id: zones,
                            res_turn_rule_id: turnRuleId,
                            tables: self.getTablesZoneRules(turnZoneAdd.zonesTables, zones)
                        });
                    }

                });

                angular.forEach(turnZoneAdd.zonesDeleted, function(zones, key) {
                    turnZones.push(zones);
                });

                turnData.turn_zone = turnZones;

                return turnData;
            },
            //Obtiene la regla del turno
            getTurnRuleId: function(zonesTables, zoneId) {
                var turnRuleId = null;
                angular.forEach(zonesTables, function(value, key) {
                    if (value.zone_id == zoneId) {
                        turnRuleId = value.res_turn_rule_id;
                    }
                });
                return turnRuleId;
            },
            //Obtiene las mesas de la zona que ha sido agregadas
            getTablesZoneRules: function(zonesTables, zoneId) {
                var data = {};
                angular.forEach(zonesTables, function(value, key) {
                    if (value.zone_id == zoneId) {
                        data = value.tables;
                    }
                });
                return data;
            },
            //Agrega a la lista de zonas eliminadas (para enviarlo a la api)
            deleteZone: function(turnZoneAdd, zoneId, zoneRule, option) {
                var index = turnZoneAdd.zones_id.indexOf(zoneId);

                if (index != -1) {
                    turnZoneAdd.zones_id.splice(index, 1);
                    turnZoneAdd.zones_data.splice(index, 1);
                }

                angular.forEach(turnZoneAdd.zonesTables, function(zone, key) {
                    if (zone.zone_id == zoneId) {
                        turnZoneAdd.zonesTables.splice(key, 1);
                    }
                });

                if (option == "edit") {
                    var vData = {
                        res_zone_id: zoneId,
                        res_turn_rule_id: zoneRule,
                        unlink: true,
                        tables: []
                    };

                    var validaDelete = 0;

                    angular.forEach(turnZoneAdd.zonesDeleted, function(zone, key) {
                        if (zone.zone_id == zoneId) {
                            validaDelete = 1;
                        }
                    });

                    if (validaDelete === 0) {
                        turnZoneAdd.zonesDeleted.push(vData);
                    }
                }
            },
            //Obtiene el turno
            getTurn: function(idTurn, options, listAvailability) {
                var defered = $q.defer();
                var self = this;

                TurnDataFactory.getTurn(idTurn, options).success(function(data) {
                    data = data.data;
                    var turnData = {
                        id: data.id,
                        name: data.name,
                        hours_ini: data.hours_ini,
                        hours_end: data.hours_end,
                        days: data.days,
                        turn_time: data.turn_time
                    };

                    var nextDay = getHourNextDay(data.hours_ini, data.hours_end);
                    var hour_ini = getIndexHour(data.hours_ini, 0);
                    var hour_end = getIndexHour(data.hours_end, nextDay); //esto pendiente

                    var turnForm = {
                        hours_ini: {
                            index: hour_ini,
                            time_original: data.hours_ini,
                            time: listAvailability[hour_ini].time
                        },
                        hours_end: {
                            index: hour_end,
                            time_original: data.hours_end,
                            time: listAvailability[hour_end].time
                        },
                        type_turn: {
                            id: data.res_type_turn_id,
                            label: ''
                        },
                        days: self.activeCheckDays(data.days)
                    };

                    var turnDataClone = turnData;
                    var zonesId = [];
                    var dataZones = [];

                    angular.forEach(data.turn_zone, function(zones) {
                        zonesId.push(zones.zone.id);

                        var turnsData = [];

                        angular.forEach(zones.zone.turns, function(turns, key) {
                            turnsData.push(turns.name);
                        });

                        zones.zone.turns_asign = turnsData.join(", ");
                        zones.zone.rule = zones.rule;
                        dataZones.push(zones.zone);
                    });

                    var responseData = {
                        turnData: turnData,
                        turnForm: turnForm,
                        turnDataClone: turnDataClone,
                        zonesId: zonesId,
                        dataZones: dataZones
                    };

                    defered.resolve(responseData);

                }).error(function(data, status, headers) {
                    defered.reject(data);
                });

                return defered.promise;
            },
            //Marca los dias asignados
            activeCheckDays: function(days) {
                var daysData = [];

                for (var i = 1; i <= 7; i++) {
                    var checked = (days.indexOf(i) != -1) ? true : false;
                    daysData.push({
                        id: i,
                        checked: checked
                    });
                }
                return daysData;
            },
            //Listado de mesas de la zona
            getTurnZoneTables: function(idZone, idTurn, option, turnZoneAdd, turnForm, zoneSelected, listAvailability) {
                var defered = $q.defer();
                var self = this;

                var tablesZoneExists = self.searchZoneByZoneAdd(turnZoneAdd.zonesTables, idZone);

                if (tablesZoneExists !== null) {
                    defered.resolve(tablesZoneExists.tables);
                } else {

                    self.addRulesTable(zoneSelected, turnZoneAdd);

                    if (option == "edit") {
                        TurnDataFactory.getTurnZoneTables(idZone, idTurn).success(function(data) {
                            var rulesTables = self.setAvailabilityText(data.data, turnForm, listAvailability);
                            defered.resolve(rulesTables);
                        }).error(function(data, status, headers) {
                            defered.reject(data);
                        });
                    } else {
                        ZoneFactory.getTables(idZone).success(function(data) {
                            data = self.checkRuleTableAll(data.data, 1, turnForm);
                            defered.resolve(data);
                        }).error(function(data, status, headers) {
                            defered.reject(data);
                        });
                    }
                }

                return defered.promise;
            },
            //Busca las reglas de las mesas y las añade para mostrar el texto de disponibilidad
            setAvailabilityText: function(tables, turnForm, listAvailability) {
                var self = this;

                angular.forEach(tables, function(data, key) {
                    var vData = {};
                    var rulesData = [];

                    for (var i = turnForm.hours_ini.index; i <= turnForm.hours_end.index; i++) {
                        var ruleId = self.getAvailabilityRuleId(data.availability, i);
                        var ruleIdOld = self.getAvailabilityRuleId(data.availability, i - 1);
                        var ruleIdNext = self.getAvailabilityRuleId(data.availability, i + 1);

                        if (ruleIdOld != ruleId || i == turnForm.hours_ini.index) {
                            vData.hours_ini = listAvailability[i].time;
                            vData.hours_end = vData.hours_ini;
                            vData.rule_id = ruleId;
                        } else if (ruleIdOld == ruleId) {
                            vData.hours_end = listAvailability[i].time;
                        }

                        if (ruleIdNext != ruleId || i == turnForm.hours_end.index) {
                            rulesData.push(vData);
                            vData = {};
                        }
                    }
                    data = self.setRuleTextTable(data, rulesData);
                });

                return tables;
            },
            //Asigna el texto de disponibilidad para la mesa 
            setRuleTextTable: function(table, rulesData) {
                var rulesTable = {
                    rulesDisabled: [],
                    rulesOnline: [],
                    rulesLocal: []
                };

                angular.forEach(rulesData, function(rules, key) {
                    var vData = rules.hours_ini + " - " + rules.hours_end;

                    switch (rules.rule_id) {
                        case 0:
                            rulesTable.rulesDisabled.push(vData);
                            break;
                        case 1:
                            rulesTable.rulesLocal.push(vData);
                            break;
                        case 2:
                            rulesTable.rulesOnline.push(vData);
                            break;
                    }
                });

                table.rules_disabled = rulesTable.rulesDisabled.toString();
                table.rules_local = rulesTable.rulesLocal.toString();
                table.rules_online = rulesTable.rulesOnline.toString();

                return table;
            },
            //Obtiene la regla establecida
            getAvailabilityRuleId: function(availability, index) {
                var ruleId = -1;
                ruleId = availability[index].rule_id;
                return ruleId;
            },
            //Busca la zona, entre las zonas agregadas al turno
            searchZoneByZoneAdd: function(zonesTablesAdd, idZone) {
                var tablesZone = null;

                angular.forEach(zonesTablesAdd, function(data, key) {
                    if (data.zone_id == idZone) {
                        tablesZone = data;
                    }
                });

                return tablesZone;
            },
            //Selecciona la mesa de la zona
            checkTableZone: function(tablesId, idTable) {
                var index = tablesId.indexOf(idTable);

                if (index == -1) {
                    tablesId.push(idTable);
                } else {
                    tablesId.splice(index, 1);
                }
            },
            //Selecciona todas las mesas de la zona
            checkAllTableZone: function(tablesId, tables, option) {
                if (option === true) {
                    tablesId.length = 0;
                }

                angular.forEach(tables, function(table, key) {
                    var index = tablesId.indexOf(table.id);
                    if (index == -1) {
                        tablesId.push(table.id);
                    } else {
                        tablesId.splice(index, 1);
                    }
                });
            },
            //Obtiene la mesa segun el id, busca entre un array de mesas
            getTableZoneTime: function(tables, idTable) {
                var data = "";

                angular.forEach(tables, function(table, key) {
                    if (table.id == idTable) {
                        data = table;
                    }
                });

                return data;
            },
            //Agrega la regla de forma temporal
            checkRuleTable: function(indexTime, rule, tableItem, rulesDataTemp) {

                var jsonData = angular.toJson(rulesDataTemp);

                if (rulesDataTemp.length === 0 || jsonData.indexOf(indexTime) == -1) {
                    rulesDataTemp.push({
                        rule_id: rule,
                        index_time: indexTime
                    });
                } else {
                    angular.forEach(rulesDataTemp, function(rules, key) {
                        if (rules.index_time == indexTime) {
                            rules.rule_id = rule;
                        }
                    });
                }
            },
            //Guarda la regla de la mesa
            saveRuleTable: function(tableItem, rulesDataTemp) {
                angular.forEach(tableItem, function(table, key) {
                    angular.forEach(table.availability, function(rules, key) {
                        angular.forEach(rulesDataTemp, function(rulesTemp) {
                            if (key == rulesTemp.index_time) {
                                rules.rule_id = rulesTemp.rule_id;
                            }
                        });
                    });
                });

                return tableItem;
            },
            //Genera la lista del tiempo segun hora inicio y hora final del turno
            listHour: function(hourIni, hourEnd, availabilityTime) {
                var listTime = [];

                angular.forEach(availabilityTime, function(value, key) {
                    if (value.index >= hourIni && value.index <= hourEnd) {
                        listTime.push({
                            time: value.time,
                            time_original: value.time_original,
                            index: value.index
                        });
                    }
                });

                return listTime;
            },
            //Genera un array de horas entre un intervalo de 15 minutos
            initAvailability: function() {
                var times = [];

                for (var i = 0; i < 120; i++) {
                    var time = i * 60 * 15;
                    var nextday = (i < 96) ? 0 : 1;

                    var time_original = moment.utc(time * 1000).format('HH:mm');

                    if (i >= 52 && i < 96) {
                        var a = (i - 48) * 60 * 15;
                        time = moment.utc(a * 1000).format('HH:mm') + " PM";
                    } else if (i < 52) {
                        time = moment.utc(time * 1000).format('HH:mm') + " AM";
                    } else {
                        time = moment.utc(time * 1000).format('HH:mm') + " AM";
                    }

                    times.push({
                        time: time,
                        time_original: time_original,
                        rule_id: "-1",
                        nextday: nextday,
                        index: i
                    });
                }

                return times;
            },
            //Asigna para todas las mesas la regla seleccionada
            checkRuleTableAll: function(tables, rule, turnForm) {
                var self = this;

                angular.forEach(tables, function(data) {
                    data = self.updateTextAvailabilityTable(data, rule, turnForm);
                    angular.forEach(data.availability, function(rules) {
                        rules.rule_id = rule;
                    });
                });

                return tables;
            },
            //Actualiza el texto de disponibilidad cuando elegimos una regla para todas las mesas
            updateTextAvailabilityTable: function(table, rule, turnForm) {
                table.rules_disabled = "";
                table.rules_local = "";
                table.rules_online = "";
                table.res_turn_rule_id = rule;

                switch (rule) {
                    case 0:
                        table.rules_disabled = turnForm.hours_ini.time + " - " + turnForm.hours_end.time;
                        break;
                    case 1:
                        table.rules_local = turnForm.hours_ini.time + " - " + turnForm.hours_end.time;
                        break;
                    case 2:
                        table.rules_online = turnForm.hours_ini.time + " - " + turnForm.hours_end.time;
                        break;
                }

                return table;
            },
            //Agrega la regla para la mesa(s)
            addRulesTable: function(zoneSelected, turnZoneAdd) {
                var vData = {
                    zone_id: zoneSelected.id,
                    res_turn_rule_id: zoneSelected.rule,
                    tables: []
                };

                angular.forEach(zoneSelected.tables, function(value, key) {
                    vData.tables.push(value);
                });

                if (turnZoneAdd.zonesTables.length === 0) {
                    turnZoneAdd.zonesTables.push(vData);
                } else {

                    var existeZone = 0;

                    angular.forEach(turnZoneAdd.zonesTables, function(value, key) {
                        if (value.zone_id == zoneSelected.id) {
                            turnZoneAdd.zonesTables.splice(key, 1);
                            turnZoneAdd.zonesTables.push(vData);

                            existeZone += 1;
                        }
                    });

                    if (existeZone === 0) {
                        turnZoneAdd.zonesTables.push(vData);
                    }
                }
            },
            //Verifica si existe una sola regla por defecto del turno
            ruleExitsOne: function(tables, ruleId, turnForm) {
                var rule = 1;

                angular.forEach(tables, function(table, key) {
                    for (var i = turnForm.hours_ini.index; i <= turnForm.hours_end.index; i++) {
                        if (table.availability[i].rule_id != ruleId) {
                            rule += 1;
                        }
                    }
                });

                return rule;
            },
            //Guarda el dia que se halla marcado
            checkDay: function(days, dayId) {
                var index = days.indexOf(dayId);

                if (index == -1) {
                    days.push(dayId);
                } else {
                    days.splice(index, 1);
                }
            },
            //Formatea datos del tiempo turno para su visualización 
            parseTurnTimeDefault: function(dataTurnTime, listAvailability, data) {
                var timeDefault = [];
                var self = this;

                angular.forEach(data, function(time, key) {
                    var indexHour = getIndexHour(time.time, 0);
                    timeDefault.push({
                        text: (key === 0) ? "1 Invitado" : (key + 1) + " Invitados",
                        indexHour: indexHour,
                        hourText: listAvailability[indexHour].time_original
                    });
                });

                dataTurnTime.data_temporal = timeDefault;

                return dataTurnTime;
            },
            //Genera la lista de tiempo turno
            generatedTurnTimeDefault: function(listAvailability) {
                var indexHourDefault = 5;
                var turnTime = {
                    data_final: [],
                    data_temporal: []
                };

                for (var i = 0; i <= 9; i++) {
                    turnTime.data_temporal.push({
                        text: (i === 0) ? "1 Invitado" : (i + 1) + " Invitados",
                        indexHour: indexHourDefault,
                        hourText: listAvailability[indexHourDefault].time_original
                    });

                    turnTime.data_final.push({
                        num_guests: (i + 1),
                        time: listAvailability[indexHourDefault].time_original
                    });

                    indexHourDefault += 1;
                }
                return turnTime;
            }

        };

    });
angular.module("widget.app", [])
    .config(["$stateProvider", function($stateProvider) {
        $stateProvider.state('mesas.widget', {
            url: '/widget',
            views: {
                '@': {
                    templateUrl: '/js/app/tables/widget/views/index.html',
                    controller: "widgetCtrl",
                    controllerAs: 'vm',
                }
            },
        });
    }]);
angular.module('zone.app', ['zone.controller', 'zone.service', 'zone.directive'])
    .config(function($stateProvider, $urlRouterProvider, $httpProvider) {

        $stateProvider
            .state('mesas.zone', {
                url: '/config/zone',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/zone/view/index.html',
                        controller: 'ZoneCtrl',
                    }

                },
                resolve: {
                    $title: function() {
                        return 'Lista de zonas';
                    }
                }
            })
            .state('mesas.zone.active', {
                url: '/zone-active',
                templateUrl: '/js/app/tables/zone/view/zone-active.html',
                resolve: {
                    $title: function() {
                        return 'Lista de zonas activas';
                    }
                }
            })
            .state('mesas.zone.inactive', {
                url: '/zone-inactive',
                templateUrl: '/js/app/tables/zone/view/zone-inactive.html',
                resolve: {
                    $title: function() {
                        return 'Lista de zonas inactivas';
                    }
                }
            })
            .state('mesas.zone.create', {
                url: '/new',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/zone/view/zone-create.html',
                        controller: 'ZoneCreateCtrl',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Crear zona';
                    }
                }
            })
            .state('mesas.zone.edit', {
                url: '/:id',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/zone/view/zone-edit.html',
                        controller: 'ZoneCreateCtrl',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Editar zona';
                    }
                }
            })
            .state('mesas.zone.clone', {
                url: '/:id/clone',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/zone/view/zone-clone.html',
                        controller: 'ZoneCreateCtrl',
                    }
                },
                resolve: {
                    $title: function() {
                        return 'Clonar zona';
                    }
                }
            });

    });
angular.module('zone.controller', ['ngDraggable'])
    .controller('ZoneCtrl', function($scope, ZoneFactory, MenuConfigFactory, TurnDataFactory, $uibModal) {

        $scope.zonesActive = {};
        $scope.zonesInactive = {};

        $scope.idZoneDelete = 0;
        $scope.indexRow = 0;

        $scope.zones = {
            numTablesActive: 0,
            numTablesInactive: 0,
            minCoversActive: 0,
            maxCoversActive: 0,
            minCoversInactive: 0,
            maxCoversInactive: 0
        };

        var init = function() {
            $scope.getZones(false);
            MenuConfigFactory.menuActive(0);
        };

        var getTurns = function(zones) {
            var options = getAsUriParameters({
                with: "zones|type_turn|calendar"
            });

            TurnDataFactory.getTurns(options).then(
                function success(response) {
                    response = response.data.data;
                    zonesData(zones, response);
                },
                function error(response) {
                    console.error("getTurns error " + angular.toJson(response, true));
                }
            );
        };

        var zonesData = function(zones, turns) {

            var zonesActive = [];
            var zonesInactive = [];

            angular.forEach(zones, function(zone) {
                var isActiveZone = false;

                angular.forEach(zone.turns, function(turnZone, key) {

                    var isActive = activeZoneTurn(turns, turnZone.id);

                    if (isActive) {
                        isActiveZone = isActive;
                        return;
                    }
                });

                if (isActiveZone) {

                    $scope.zones.numTablesActive += zone.tables_count;
                    $scope.zones.minCoversActive += zone.min_covers;
                    $scope.zones.maxCoversActive += zone.max_covers;

                    zonesActive.push(zone);

                } else {

                    $scope.zones.numTablesInactive += zone.tables_count;
                    $scope.zones.minCoversInactive += zone.min_covers;
                    $scope.zones.maxCoversInactive += zone.max_covers;

                    zonesInactive.push(zone);
                }
            });

            $scope.zonesActive = zonesActive;
            $scope.zonesInactive = zonesInactive;
        };

        var activeZoneTurn = function(turns, turnId) {
            var active = false;
            angular.forEach(turns, function(turn, key) {
                if (turn.id == turnId && turn.calendar.length > 0) {
                    active = true;
                }
            });
            return active;
        };
        var getTablesCount = function(zones) {
            var vTables = 0;
            var vMinCovers = 0;
            var vMaxCovers = 0;

            angular.forEach(zones.tables, function(tables) {
                if (tables.status == 1) {
                    vTables += 1;
                    vMinCovers += tables.min_cover;
                    vMaxCovers += tables.max_cover;
                }
            });

            zones.tables_count = vTables;
            zones.min_covers = vMinCovers;
            zones.max_covers = vMaxCovers;

            return zones;
        };

        $scope.getZones = function(reload) {

            ZoneFactory.getZones("with=turns", reload).then(
                function success(data) {
                    data = data.data.data;
                    var zonesData = [];

                    angular.forEach(data, function(zones) {

                        var zonesTables = getTablesCount(zones);

                        zonesData.push(zonesTables);
                    });
                    return zonesData;
                }
            ).then(function(zones) {
                getTurns(zones);
            });
        };

        $scope.deleteZoneConfirm = function(idZone) {
            var options = {
                showCancelButton: true,
                confirmButtonText: "Si",
                cancelButtonText: "No",
            };

            message.confirmButton("Eliminar zona", "¿Estas seguro que deseas eliminar la zona ?", "info", options, function() {
                ZoneFactory.deleteZone(idZone).success(function(response) {

                    messageAlert("Operación exitosa", "Zona eliminada", "success");
                    $scope.getZones(true);

                }).error(function(data, status, headers) {
                    messageErrorApi(data, "Error", "warning");
                });
            });

        };

        init();
    })
    .controller('ZoneCreateCtrl', function($scope, $state, $stateParams, $document, ZoneFactory, ZoneLienzoFactory, TableFactory,
        $uibModal, IdMicroSitio, MenuConfigFactory) {

        $scope.sizeTableList = {
            data: [{
                id: "1",
                label: "small"
            }, {
                id: "2",
                label: "medium"
            }, {
                id: "3",
                label: "large"
            }],
            selectedOption: {
                id: "1",
                label: "small"
            }
        };

        $scope.coversList = {
            dataMin: [],
            selectedMin: '',
            dataMax: [],
            selectedMax: ''
        };

        $scope.headerZone = {
            tables: 0,
            minCovers: 0,
            maxCovers: 0
        };

        $scope.itemTables = [];
        $scope.itemTablesDeleted = [];

        $scope.boxTables = {
            items: true,
            item: false
        };

        $scope.typeDrag = "";

        $scope.indexTable = null;
        $scope.selectedTable = false; //validar al hacer click en el lienzo

        $scope.typeForm = "create"; // or edit
        $scope.saveClick = false; //valida click en guardar - no doble click

        var init = function() {
            detectedForm();
            listCovers("min");
            listCovers("max");
            MenuConfigFactory.menuActive(0);
        };

        $scope.onDragComplete = function(data, evt, type) {
            $scope.typeDrag = type;
            selectTableTypeDrag(data, type);
        };

        $scope.onDropComplete = function(data, evt) {

            var position = ZoneLienzoFactory.positionTable(evt);

            data.top = position.y;
            data.left = position.x;
            data.rotate_text = "top";
            data.name = $scope.itemTables.length + 1;

            selectTableTypeDrop(data);

            $scope.typeDrag = "";
        };

        $scope.onLienzo = function() {
            if ($scope.indexTable !== null && $scope.selectedTable === false) {
                $scope.activarTablesItems();
            }
            $scope.selectedTable = false;
        };

        $scope.rotateTextTable = function(option) {
            ZoneLienzoFactory.changeRotationText(option, $scope.itemTables[$scope.indexTable], $scope.indexTable);
        };

        $scope.changeShapeTable = function(shape) {

            $scope.itemTables[$scope.indexTable].shape = shape;
            var rotateTable = $scope.itemTables[$scope.indexTable].rotate;

            if (shape == "square" && (rotateTable == 90 || rotateTable == 135)) {
                $scope.itemTables[$scope.indexTable].rotate = 0;
            }
        };

        $scope.changeSizeTable = function() {
            $scope.itemTables[$scope.indexTable].size = $scope.sizeTableList.selectedOption.label;
        };

        $scope.editNameTable = function() {
            var texto = angular.element("#name-table").val();
            ZoneLienzoFactory.changeNameTable($scope.itemTables[$scope.indexTable], $scope.itemTables, texto);
        };

        $scope.tableCapacity = function(option) {

            if (option == "min") {
                $scope.itemTables[$scope.indexTable].minCover = $scope.coversList.selectedMin.id;
            } else {
                $scope.itemTables[$scope.indexTable].maxCover = $scope.coversList.selectedMax.id;
            }

            if ($scope.coversList.selectedMax.id < $scope.coversList.selectedMin.id) {

                $scope.itemTables[$scope.indexTable].minCover = $scope.coversList.selectedMax.id;
                $scope.itemTables[$scope.indexTable].maxCover = $scope.coversList.selectedMax.id;

                getDataTableSelected($scope.indexTable);
            }

            updateHeaderZone();
        };

        $scope.rotateShapeTable = function() {
            var rotateTable = $scope.itemTables[$scope.indexTable].rotate;
            var shapeTable = $scope.itemTables[$scope.indexTable].shape;

            if (rotateTable == "0") {
                $scope.itemTables[$scope.indexTable].rotate = "45";
            } else {
                if (rotateTable == "45" && shapeTable == "recta") {
                    $scope.itemTables[$scope.indexTable].rotate = "90";
                } else if (rotateTable == "90" && shapeTable == "recta") {
                    $scope.itemTables[$scope.indexTable].rotate = "135";
                } else {
                    $scope.itemTables[$scope.indexTable].rotate = "0";
                }
            }
        };

        $scope.draggableTable = function() {
            console.log("draggableTable prueba");
        };

        $scope.activarTableOptions = function(index, vthis) {
            $scope.selectedTable = true;
            getDataTableSelected(index);

            setTimeout(function() {
                $scope.$apply(function() {

                    if ($scope.boxTables.item === false || ($scope.boxTables.item === true && $scope.selectedTable === true && angular.element('.item-drag-table').hasClass('selected-table') === false)) {
                        $scope.boxTables.item = true;
                        $scope.boxTables.items = false;
                    } else {
                        if (angular.element('.item-drag-table').hasClass('selected-table') === false) {
                            $scope.boxTables.item = false;
                            $scope.boxTables.items = true;
                        }
                    }
                });
            }, 100);
        };

        $scope.doneTableSelected = function() {
            $scope.activarTablesItems();
        };

        $scope.activarTablesItems = function() {
            ZoneLienzoFactory.activarTablesItems($scope.boxTables);
        };

        $scope.deleteSelectTableItem = function() {

            var modalDeleteTable = $uibModal.open({
                animation: true,
                templateUrl: 'myModalDeleteTable.html',
                size: 'lg',
                controller: 'ModalTableDeteleCtrl',
                resolve: {
                    itemTables: function() {
                        return $scope.itemTables;
                    },
                    itemTablesDeleted: function() {
                        return $scope.itemTablesDeleted;
                    },
                    indexTable: function() {
                        return $scope.indexTable;
                    },
                    boxTables: function() {
                        return $scope.boxTables;
                    },
                    headerZone: function() {
                        return $scope.headerZone;
                    },
                    typeForm: function() {
                        return $scope.typeForm;
                    }

                }
            });
        };

        $scope.saveZone = function(option) {
            var dataZone = {
                name: angular.element("#zone_name").val(),
                ms_microsite_id: IdMicroSitio,
                tables: prepareDataTablesSave()
            };

            $scope.saveClick = true;

            if (option == "create") {
                ZoneFactory.createZone(dataZone).success(function(response) {
                    messageAlert("Success", "Zona creada correctamente", "success", 0, true);
                    $state.reload();
                }).error(function(data, status, headers) {
                    $scope.saveClick = false;
                    messageErrorApi(data, "Error", "warning", 0, true);
                });

            } else {
                dataZone.id = $stateParams.id;
                ZoneFactory.editZone(dataZone).success(function(response) {
                    messageAlert("Success", "Zona actualizada correctamente", "success", 0, true);
                    $state.go('mesas.zone.active');
                }).error(function(data, status, headers) {
                    $scope.saveClick = false;
                    messageErrorApi(data, "Error", "warning", 0, true);
                });
            }
        };

        var listCovers = function(option) {

            var coverList = "";

            if (option == "min") {
                coverList = $scope.coversList.dataMin;
            } else {
                coverList = $scope.coversList.dataMax;
            }

            for (var i = 1; i <= 30; i++) {
                var data = {
                    label: i + " covers",
                    id: i
                };
                coverList.push(data);
            }

            if (option == "min") {
                $scope.coversList.selectedMin = coverList[0];
            } else {
                $scope.coversList.selectedMax = coverList[0];
            }
        };

        var getDataTableSelected = function(index) {
            $scope.indexTable = index;

            angular.element("#name-table").val($scope.itemTables[index].name);
            $scope.changeShapeTable($scope.itemTables[index].shape);

            $scope.itemTables[index].top = angular.element("#tb-item" + index).css("top").replace("px", "");
            $scope.itemTables[index].left = angular.element("#tb-item" + index).css("left").replace("px", "");

            $scope.coversList.selectedMin = {
                id: $scope.itemTables[$scope.indexTable].minCover,
                label: $scope.itemTables[$scope.indexTable].minCover + " covers"
            };

            $scope.coversList.selectedMax = {
                id: $scope.itemTables[$scope.indexTable].maxCover,
                label: $scope.itemTables[$scope.indexTable].maxCover + " covers"
            };

            $scope.sizeTableList.selectedOption = {
                id: TableFactory.getIdSize($scope.itemTables[index].size),
                label: $scope.itemTables[index].size
            };
        };

        var selectTableTypeDrag = function(data) {
            var index = $scope.itemTables.indexOf(data);
            if (index > -1) {
                $scope.itemTables.splice(index, 1);
            }
        };

        var selectTableTypeDrop = function(data) {
            var index = $scope.itemTables.indexOf(data);
            if (index == -1)
                data.id = 0;
            data.status = 1;

            $scope.itemTables.push(data);
            updateHeaderZone();
        };

        var updateHeaderZone = function() {
            ZoneLienzoFactory.updateHeaderZone($scope.headerZone, $scope.itemTables);
        };

        var getDataTables = function(table) {
            var tableItem = {
                name: table.name,
                min_cover: table.minCover,
                max_cover: table.maxCover,
                config_position: table.left + "," + table.top, //x,y
                config_size: TableFactory.getIdSize(table.size),
                config_rotation: table.rotate,
                config_rotation_text: TableFactory.getIdRotationText(table.rotate_text),
                config_forme: TableFactory.getIdShape(table.shape),
                id: table.id,
                status: table.status
            };

            return tableItem;
        };

        var prepareDataTablesSave = function() {
            var tables = [];

            angular.forEach($scope.itemTables, function(table) {
                var tableItem = getDataTables(table);
                tables.push(tableItem);
            });

            if ($scope.typeForm == "edit") {
                angular.forEach($scope.itemTablesDeleted, function(table) {
                    var tableItem = getDataTables(table);
                    tables.push(tableItem);
                });
            }
            return tables;
        };

        var detectedForm = function() {
            if ($stateParams.id !== undefined) {
                $scope.typeForm = "edit";

                ZoneFactory.getZone($stateParams.id).success(function(zone) {
                    angular.element("#zone_name").val(zone.data.name);
                    loadTablesEdit(zone.data.tables);
                });
            }
        };

        var loadTablesEdit = function(tables) {
            angular.forEach(tables, function(data) {
                var position = data.config_position.split(",");
                var dataTable = {
                    name: data.name,
                    minCover: data.min_cover,
                    maxCover: data.max_cover,
                    left: position[0],
                    top: position[1],
                    shape: TableFactory.getLabelShape(data.config_forme),
                    size: TableFactory.getLabelSize(data.config_size),
                    rotate: data.config_rotation,
                    rotate_text: TableFactory.getRotationText(data.config_rotation_text),
                    id: data.id,
                    status: data.status
                };

                if (data.status == 1) {
                    $scope.itemTables.push(dataTable);
                } else {
                    $scope.itemTablesDeleted.push(dataTable);
                }
            });

            updateHeaderZone();
        };

        init();
    })
    .controller('ModalTableDeteleCtrl', function($scope, $uibModalInstance, itemTables, itemTablesDeleted, indexTable, boxTables, headerZone, typeForm, ZoneLienzoFactory) {

        $scope.ok = function() {
            //show tables items
            ZoneLienzoFactory.activarTablesItems(boxTables);
            removeTableItem();
            ZoneLienzoFactory.updateHeaderZone(headerZone, itemTables);
            $uibModalInstance.close();
        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        var removeTableItem = function() {
            //add table in tables removes
            if (typeForm == "edit") {
                itemTables[indexTable].status = 2;
                itemTablesDeleted.push(itemTables[indexTable]);
            }
            //delete item table selected
            itemTables.splice(indexTable, 1);
            angular.element('.item-drag-table').removeClass('selected-table');
        };
    });
angular.module('zone.directive', [])

.directive('ngDragTable', function() {
  var parentWidth = angular.element('.lienzo').width();
  var parentHeight = angular.element('.lienzo').height();

  function updatePositionLabel(element, ui) {
    var draggableWidth = element.context.offsetWidth;
    var draggableHeight = element.context.offsetHeight;

    var draggableRight = ui.position.left + draggableWidth;
    var draggableLeft = ui.position.left;
    var draggableTop = ui.position.top;

    var eRotate = element.attr("rotate");
    var eLabel = angular.element(element.context);
    var eTextRotate = eLabel.context.lastElementChild.classList[1];

    //Left

    if (draggableRight >= parentWidth && eRotate == "0") {
      if (eTextRotate == "right") {
        angular.element(eLabel.context.lastElementChild).removeClass("right");
        angular.element(eLabel.context.lastElementChild).addClass("left");
      }
    } else {
      if ((eTextRotate == "top" && (eRotate == "45" || eRotate == "135")) && draggableRight >= (parentWidth - draggableWidth * 0.35)) {
        angular.element(eLabel.context.lastElementChild).removeClass("top");
        angular.element(eLabel.context.lastElementChild).addClass("left");
      }
      if (eTextRotate == "right" && eRotate == "45" && draggableRight >= (parentWidth - draggableWidth * 0.35)) {
        angular.element(eLabel.context.lastElementChild).removeClass("right");
        angular.element(eLabel.context.lastElementChild).addClass("bottom");
      }
    }

    if (draggableLeft <= 0 && eRotate == "0") {
      if (eTextRotate == "left") {
        angular.element(eLabel.context.lastElementChild).removeClass("left");
        angular.element(eLabel.context.lastElementChild).addClass("right");
      }

    } else {
      if (eTextRotate == "left" && eRotate == "45" && (draggableLeft - draggableWidth * 0.35) <= 0) {
        angular.element(eLabel.context.lastElementChild).removeClass("left");
        angular.element(eLabel.context.lastElementChild).addClass("top");
      }
      if (eTextRotate == "bottom" && eRotate == "45" && (draggableLeft - draggableWidth * 0.35) <= 0) {
        angular.element(eLabel.context.lastElementChild).removeClass("bottom");
        angular.element(eLabel.context.lastElementChild).addClass("right");
      }
    }

    //Top

    if (draggableTop <= 0 && (eRotate == "0" || eRotate == "90")) {
      if (eTextRotate == "top") {
        angular.element(eLabel.context.lastElementChild).removeClass("top");
        angular.element(eLabel.context.lastElementChild).addClass("bottom");
      }
    }

    if ((draggableTop + draggableHeight) >= parentHeight && (eRotate == "0" || eRotate == "90")) {
      if (eTextRotate == "bottom") {
        angular.element(eLabel.context.lastElementChild).removeClass("bottom");
        angular.element(eLabel.context.lastElementChild).addClass("top");
      }
    }
  }

  function dragTable(scope, element, attr, ctrl) {

    element.on('click', function(event) {
      event.preventDefault();
      scope.onClickFn();

      angular.element('.item-drag-table').removeClass('selected-table');
      angular.element(this).toggleClass("selected-table");

    });

    element.draggable({
      containment: "parent",
      grid: [10, 10],
      drag: function(event, ui) {

        element.attr("top", ui.position.top);
        element.attr("left", ui.position.left);
        updatePositionLabel(element, ui);
        //element.draggable("disable");
      },
      start: function(event, ui) {
        angular.element('#lienzo').addClass('drag');
      },
      stop: function(event, ui) {
        angular.element('#lienzo').removeClass('drag');
      }
    });
  }

  return {
    link: dragTable,
    scope: {
      onClickFn: '&',
      onDragFn: '&'
    }
  };
});
angular.module('zone.service', [])
    .factory('ZoneFactory', function($http, ApiUrlMesas, HttpFactory) {
        var zones;
        return {
            getZones: function(vOptions, reload) {
                zones = HttpFactory.get(ApiUrlMesas + "/zones?" + vOptions, {}, zones, reload);
                return zones;
            },
            getZonesActivesByDate: function(vOptions, reload) {
                zones = HttpFactory.get(ApiUrlMesas + "/zones/activesByDate?" + vOptions, {}, zones, reload);
                return zones;
            },
            getZone: function(vId) {
                return $http.get(ApiUrlMesas + "/zones/" + vId);
            },
            createZone: function(vData) {
                return $http.post(ApiUrlMesas + '/zones', vData);
            },
            editZone: function(vData) {
                return $http.put(ApiUrlMesas + '/zones/' + vData.id, vData);
            },
            deleteZone: function(vId) {
                return $http.delete(ApiUrlMesas + '/zones/' + vId);
            },
            getTables: function(vId) {
                return $http.get(ApiUrlMesas + "/zones/" + vId + "/tables");
            }
        };

    })

.factory('ZoneLienzoFactory', function($document, TableFactory) {
    return {
        //Activa el tablero de mesas (seleccionar mesas)
        activarTablesItems: function(boxTables) {
            boxTables.item = false;
            boxTables.items = true;
            angular.element('.item-drag-table').removeClass('selected-table');
        },
        //Actualiza el header (total mesas,covers) cuando agregamos mesas
        updateHeaderZone: function(headerZone, itemTables) {
            headerZone.tables = itemTables.length;

            var minCovers = 0;
            var maxCovers = 0;

            angular.forEach(itemTables, function(data) {
                minCovers += parseInt(data.minCover);
                maxCovers += parseInt(data.maxCover);
            });

            headerZone.minCovers = minCovers;
            headerZone.maxCovers = maxCovers;
        },
        //Obtiene la posicion de la mesas cuando arrastramos
        positionTable: function(evt) {
            var offset = $("#lienzo").offset();

            var divPos = {
                left: evt.x - offset.left,
                top: evt.y - offset.top
            };

            var documentWidth = $document.width();
            var documentHeight = $document.height();

            var lienzoWidth = $(".lienzo").innerWidth();
            var lienzoHeight = $(".lienzo").innerHeight();

            var ContentX = (documentWidth - lienzoWidth) / 2;
            var ContentY = 145; //205
            var SizeObjectDrag = 75;

            var x = divPos.left - (SizeObjectDrag * 0.5) + (SizeObjectDrag / 2 - evt.element.centerX);
            var y = divPos.top - (SizeObjectDrag * 0.5) + (SizeObjectDrag / 2 - evt.element.centerX);

            x = x - x % 10;
            y = y - y % 10;

            var position = {
                x: x,
                y: y
            };

            return position;
        },
        //Rotacion del texto sobre la mesa
        changeRotationText: function(option, element, index) {

            var table = angular.element("#tb-item" + index);
            var rotate_actual = table[0].firstElementChild.classList[1];
            var rotate = rotate_actual || "top";

            switch (rotate_actual) {
                case 'top':
                    rotate = (option == "right") ? "right" : "left";
                    break;
                case 'left':
                    rotate = (option == "right") ? "top" : "bottom";
                    break;
                case 'bottom':
                    rotate = (option == "right") ? "left" : "right";
                    break;
                case 'right':
                    rotate = (option == "right") ? "bottom" : "top";
                    break;
            }

            angular.element(table[0].firstElementChild).removeClass(rotate_actual);
            element.rotate_text = rotate;
        },
        //Cambiar el nombre de la mesa
        changeNameTable: function(element, itemTables, texto) {
            var valida = false;
            angular.forEach(itemTables, function(value, key) {

                if (value.name == texto && value.name !== "") {
                    valida = true;
                    alertMultiple("Alerta:", "Ya existe este nombre", "danger", "fa fa-comments");
                }
            });

            if (valida === false) {
                element.name = texto;
            }
        }
    };
})

.factory('TableFactory', function() {
    return {
        getIdShape: function(label) {
            var id = "";

            switch (label) {
                case "round":
                    id = "1";
                    break;
                case "square":
                    id = "2";
                    break;
                case "recta":
                    id = "3";
                    break;
            }
            return id;
        },
        getIdSize: function(label) {
            var id = "";

            switch (label) {
                case "small":
                    id = "1";
                    break;
                case "medium":
                    id = "2";
                    break;
                case "large":
                    id = "3";
                    break;
            }

            return id;
        },
        getLabelShape: function(id) {
            var label = "";

            switch (id) {
                case 1:
                    label = "round";
                    break;
                case 2:
                    label = "square";
                    break;
                case 3:
                    label = "recta";
                    break;
            }
            return label;
        },
        getLabelSize: function(id) {
            var label = "";

            switch (id) {
                case 1:
                    label = "small";
                    break;
                case 2:
                    label = "medium";
                    break;
                case 3:
                    label = "large";
                    break;
            }

            return label;
        },
        getRotationText: function(id) {
            var label = "top";
            switch (id) {
                case 1:
                    label = "top";
                    break;
                case 2:
                    label = "right";
                    break;
                case 3:
                    label = "bottom";
                    break;
                case 4:
                    label = "left";
                    break;
            }
            return label;
        },
        getIdRotationText: function(label) {
            var id = 1;
            switch (label) {
                case 'top':
                    id = 1;
                    break;
                case 'right':
                    id = 2;
                    break;
                case 'bottom':
                    id = 3;
                    break;
                case 'left':
                    id = 4;
                    break;
            }
            return id;
        }
    };
})

;
angular.module('floor.controller')
    .controller('reservationController', function($scope, $rootScope, $uibModal, $interval, $timeout, FloorFactory, ServerDataFactory,
        TypeFilterDataFactory, FloorDataFactory, global, reservationService) {
        var rm = this;

        rm.visits = {};
        rm.typeRes = [];
        rm.filter_status = [1, 2, 3];
        rm.filter_people = [];
        rm.filter_reserva = [];
        rm.filter_type = [];
        rm.zonesNumber = [];
        rm.status = [];
        rm.servers = [];
        rm.tags = [];
        rm.schedule = {};

        var blocks = [];

        rm.res_listado = [];

        rm.fecha_actual = getFechaActual();
        var validaModal = false; //modal editar reservacion
        rm.search = {
            show: true
        };

        rm.searchReservation = function() {
            rm.search.show = !rm.search.show;
            rm.busqueda = "";
        };

        rm.categorias_people = [{
            id: 1,
            name: 'Todos',
            checked: true,
        }, {
            id: 2,
            name: 'Hombres',
            filter: "men",
            checked: false,
        }, {
            id: 3,
            name: 'Mujeres',
            filter: "woman",
            checked: false,
        }, {
            id: 4,
            name: 'Niños',
            filter: "children",
            checked: false,
        }];


        var inspectToleranceReservation = function(reservation) {
            if (rm.configuracion && reservation.status.id < 4) {
                var nowdate = moment();
                var horareservacion = moment(reservation.datetime_input);
                var diferece = horareservacion.diff(nowdate) / 60000; // DIFERENCIA EN MINUTOS

                var time_tolerance = rm.configuracion.time_tolerance;

                //console.log('reservation: ', reservation.id, ' reservation.datetime_input: ', reservation.datetime_input, ' diferece: ', diferece);

                if (diferece >= 0) {
                    reservation.class = 'success';
                } else {
                    if (-diferece < time_tolerance) {
                        reservation.class = 'warning';
                    } else {
                        reservation.class = 'danger';
                    }
                }
            }
        };

        var statistics = function(action) {
            var total = 0;
            var men = 0;
            var women = 0;
            var children = 0;
            rm.typeRes = [];


            var reservations = rm.reservations.data;
            angular.forEach(reservations, function(reservation, index) {

                reservation.class = 'success';
                inspectToleranceReservation(reservation);

                $interval(function() {
                    inspectToleranceReservation(reservation);
                }, 60000);

                men += reservation.num_people_1;
                women += reservation.num_people_2;
                children += reservation.num_people_3;
                total += reservation.num_guest;

                var source_type = reservation.res_source_type_id;
                var exist = rm.typeRes.hasOwnProperty(source_type);
                if (exist) {
                    rm.typeRes[source_type]++;
                } else {
                    rm.typeRes[source_type] = 1;
                }
            });

            rm.visits.men = men;
            rm.visits.woman = women;
            rm.visits.children = children;
            rm.visits.total_people = men + women + children;
            rm.total_visitas = rm.visits.total_people;
            visitsQuantity();

            rm.typeRes.total_reservas = rm.typeRes.reduce(function(suma, value) {
                return suma + value;
            }, 0);

            rm.total_reservas = rm.typeRes.total_reservas;

            rm.res_listado = Array.prototype.concat.call(reservations, angular.copy(rm.blocks.data));
            rm.getZone();
        };

        rm.getZone = function(reservation) {
            if (rm.lienzo.data.getZoneForTables) {
                angular.forEach(rm.res_listado, function(item) {
                    item.zone = rm.lienzo.data.getZoneForTables(item.tables);
                });
            }
        };

        var customSelect = function(categoria, event, collection, filter, index_all, callback) {
            event.stopPropagation();

            if (categoria.id === index_all) {
                filter.length = 0;
                clear_select(collection);
            } else {
                var index = filter.indexOf(categoria);
                if (index === -1) {
                    filter.push(categoria);
                    categoria.checked = true;

                    collection[0].checked = false;
                } else {
                    filter.splice(index, 1);
                    categoria.checked = false;

                    if (filter.length === 0) {
                        collection[0].checked = true;
                    }
                }
            }

            if (callback) callback();
        };

        rm.select_genders = function(categoria, event) {
            customSelect(categoria, event, rm.categorias_people, rm.filter_people, 1, visitsQuantity);
        };

        rm.select_type = function(categoria, event) {
            customSelect(categoria, event, rm.categorias_type, rm.filter_type, 0);
        };

        rm.select_reserva = function(categoria, event) {
            customSelect(categoria, event, rm.categorias_reserva, rm.filter_reserva, 0, reservaQuantity);
        };

        var clear_select = function(categories) {
            angular.forEach(categories, function(categoria) {
                categoria.checked = false;
            });

            categories[0].checked = true;
        };

        var visitsQuantity = function() {
            if (rm.categorias_people[0].checked === true) {
                rm.total_visitas = rm.visits.total_people;
            } else {
                rm.total_visitas = 0;
                angular.forEach(rm.categorias_people, function(categoria) {
                    if (categoria.id !== 1 && categoria.checked === true) {
                        rm.total_visitas += rm.visits[categoria.filter];
                    }
                });
            }
        };

        var reservaQuantity = function() {
            if (rm.categorias_reserva[0].checked === true) {
                rm.total_reservas = rm.typeRes.total_reservas;
            } else {
                rm.total_reservas = 0;
                angular.forEach(rm.categorias_reserva, function(categoria) {
                    if (categoria.id !== 0 && categoria.checked === true) {
                        rm.total_reservas += rm.typeRes[categoria.id] || 0;
                    }
                });
            }
        };

        rm.selectReservation = function(reservation) {
            $scope.$apply(function() {
                $rootScope.$broadcast("floorEventEstablish", "sit", reservation);
                $rootScope.$broadcast("floorTablesSelected", reservation.tables);
                $rootScope.$broadcast("floorZoneIndexSelected", reservation.tables);
            });
        };

        rm.clearSelected = function() {
            $scope.$apply(function() {
                $rootScope.$broadcast("floorClearSelected");
            });
        };

        rm.editReservation = function(reservation) {
            if (validaModal === true) {
                return;
            }
            var modalInstance = $uibModal.open({
                templateUrl: 'ModalEditReservation.html',
                controller: 'editReservationCtrl',
                controllerAs: 'er',
                size: '',
                resolve: {
                    content: function() {
                        return {
                            reservation: reservation,
                            tags: rm.tags,
                            status: rm.status,
                            servers: rm.servers,
                            config: rm.configuracion
                        };
                    }
                }
            });

        };

        rm.checkGuestList = function(reservation) {
            rm.disabledModal();

            var modalInstance = $uibModal.open({
                templateUrl: 'ModalCheckGuestList.html',
                controller: 'ModallCheckGuestListCtrl',
                controllerAs: 'gl',
                size: 'md',
                resolve: {
                    reservation: function() {
                        return reservation;
                    },
                    configuration: function() {
                        return rm.configuracion;
                    }
                }
            });
        };

        // rm.infoReservationShow = function() {
        //     var icon = true;
        //     console.log('sd');
        // };

        rm.mailReservationShow = function(reservation) {
            rm.disabledModal();
            var modalMailReservation = $uibModal.open({
                animation: true,
                templateUrl: 'myModalMailReservation.html',
                size: 'md',
                //keyboard: false,
                controller: 'ModalMailReservationCtrl',
                controllerAs: 'vm',
                resolve: {
                    reservation: function() {
                        return reservation;
                    }
                }
            });
        };

        rm.disabledModal = function() {
            validaModal = true;
            //console.log("disabledModal");
            $timeout(function() {
                validaModal = false;
            }, 600);
        };

        var listTypeTurns = function() {
            FloorFactory.listTurnosActivos(rm.fecha_actual).then(function success(response) {
                    //console.log(response);
                    TypeFilterDataFactory.setTypeTurnItems(response);
                    rm.categorias_type = TypeFilterDataFactory.getTypeTurnItems();
                    console.log(rm.categorias_type);
                },
                function error(error) {
                    message.apiError(error);
                }
            );
        };

        var listSourceTypes = function() {
            FloorDataFactory.getSourceTypes().then(function success(response) {
                TypeFilterDataFactory.setSourceTypesItems(response.data.data);
                rm.categorias_reserva = TypeFilterDataFactory.getSourceTypesItems();
            }, function error(error) {
                message.apiError(error);
            });
        };

        var loadConfiguration = function() {
            FloorFactory.getConfiguracionPeople().then(function(response) {
                rm.configuracion = {
                    status_people_1: response.status_people_1,
                    status_people_2: response.status_people_2,
                    status_people_3: response.status_people_3,
                };
            });
        };

        /* INICIALIZAR TODOS LOS DATOS DE FLOOR */

        // var loadDataFloor = function() {

        //     FloorFactory.getDataFloor(null).then(function(response) {
        //         rm.status = response.status;
        //         rm.servers = response.servers;
        //         rm.tags = response.tags;
        //         setConfiguration(response.config);
        //         setCategoriasReserva(response.sourceTypes);
        //         setCategoriasType(response.shifts);
        //     }).catch(function(error) {
        //         message.apiError(error);
        //     });
        // };

        // var setConfiguration = function(configuration) {
        //     rm.configuracion = configuration;
        // };
        var setCategoriasReserva = function() {
            TypeFilterDataFactory.setSourceTypesItems(rm.sourceTypes.data);
            rm.categorias_reserva = TypeFilterDataFactory.getSourceTypesItems();
        };
        var setCategoriasType = function() {
            TypeFilterDataFactory.setTypeTurnItems(rm.shifts.data);
            rm.categorias_type = TypeFilterDataFactory.getTypeTurnItems();
        };
        /* FIN INICIALIZAR TODOS LOS DATOS DE FLOOR */

        var clearState = function() {
            $rootScope.$broadcast("floorClearSelected");
            angular.element('.bg-window-floor').removeClass('drag-dispel');
            FloorFactory.isEditServer(false);
        };

        (function Init() {
            clearState();

            rm.reservations = global.reservations;
            rm.blocks = global.blocks;
            rm.lienzo = global.lienzo;

            rm.configuracion = global.config;

            /**
             * No reflejan cambio en real time, debe estar
             * referenciado aun objeto, y no a un array
             * por adaptar codigo
             */
            rm.status = global.status.data;
            rm.servers = global.servers.data;
            rm.tags = global.tags.data;
            rm.schedule = global.schedule;

            /**
             * Variables de apollo para escuchar los cambios
             */
            rm.sourceTypes = global.sourceTypes;
            rm.shifts = global.shifts;

            $scope.$watch("rm.reservations", statistics, true);
            $scope.$watch("rm.sourceTypes", setCategoriasReserva, true);
            $scope.$watch("rm.shifts", setCategoriasType, true);

            //loadConfiguration();
            //listSourceTypes();
            //listTypeTurns();
        })();
    })
    .controller("editReservationCtrl", ["$rootScope", "$state", "$uibModalInstance", "content", "reservationService", "$q", "global",
        function($rootScope, $state, $uibModalInstance, content, service, $q, global) {

            var er = this;

            /**
             * Tags de reservacion
             * @type {Array}
             */
            er.tags = [];

            /**
             * Tags de reservacion seleccionados
             * @type {Object}
             */
            er.selectTags = {};
            er.existTagsReservations = false;

            er.countKeys = function(obj) {
                return Object.keys(obj).length;
            };

            er.sumar = function(guest) {
                er.reservation.guests[guest]++;
                totalGuests();
                guest_list_valid(guest);
            };

            er.restar = function(guest) {
                var quantity = er.reservation.guests[guest];
                if (quantity - 1 >= 0) {
                    er.reservation.guests[guest]--;
                    totalGuests();
                }
                guest_list_valid(guest);
            };

            /**
             * Validacion de cantidad invitados  vs cantidad en lista de invitados 
             */
            er.guestMessage = {
                men: {
                    text: "• La  cantidad de  hombres es menor a la cantidad de hombres en la lista de invitados.",
                    active: false
                },
                women: {
                    text: "• La  cantidad de  mujeres es menor a la cantidad de mujeres en la lista de invitados.",
                    active: false
                },
                children: {
                    text: "• La  cantidad de  niños es menor a la cantidad de niños en la lista de invitados.",
                    active: false
                }
            };

            var guest_list;
            var guest_list_count = function(reservation) {
                guest_list = reservation.guest_list.reduce(function(count, item) {
                    if (item.type_person === 1) {
                        count.men++;
                    } else if (item.type_person === 2) {
                        count.women++;
                    } else if (item.type_person === 3) {
                        count.children++;
                    }
                    return count;
                }, {
                    men: 0,
                    women: 0,
                    children: 0
                });

                guest_list_valid("men");
                guest_list_valid("women");
                guest_list_valid("children");
            };

            var guest_list_valid = function(guest) {
                if (er.reservation.guests[guest] < guest_list[guest]) {
                    er.guestMessage[guest].active = true;
                } else {
                    er.guestMessage[guest].active = false;
                }
            };
            /**
             * END
             */

            var totalGuests = function() {
                er.reservation.guests.total = er.reservation.guests.men + er.reservation.guests.women + er.reservation.guests.children;
            };

            function parseData(reservation) {
                var men = 0;
                var women = 0;
                var children = 0;
                if (er.configuration.status_people_1) {
                    men = reservation.num_people_1 || 0;
                }
                if (er.configuration.status_people_2) {
                    women = reservation.num_people_2 || 0;
                }
                if (er.configuration.status_people_3) {
                    children = reservation.num_people_3 || 0;
                }
                er.reservation = {
                    id: reservation.id,
                    covers: reservation.num_guest,
                    status_id: reservation.res_reservation_status_id,
                    server_id: reservation.res_server_id,
                    note: reservation.note || null,
                    guests: {
                        men: men,
                        women: women,
                        children: children
                    },
                    date_reservation: reservation.date_reservation,
                    hours_reservation: reservation.hours_reservation
                };
                totalGuests();
            }

            function parseInfo(reservation) {
                er.info = {
                    first_name: reservation.guest ? reservation.guest.first_name : "Reservacion sin nombre.",
                    last_name: reservation.guest ? reservation.guest.last_name : "",
                    date: moment(reservation.date_reservation).format("dddd, D [de] MMMM"),
                    time: moment(reservation.hours_reservation, "HH:mm:ss").format("H:mm A"),
                    tables: getTables(reservation.tables)
                };
            }

            function getTables(tables) {
                var reservationTables = "";
                angular.forEach(tables, function(table) {
                    reservationTables += table.name + ", ";
                });

                return reservationTables.substring(0, reservationTables.length - 2);
            }

            var listGuest = function() {
                var deferred = $q.defer();
                service.getGuest()
                    .then(function(guests) {

                        er.covers = guests;
                    }).catch(function(error) {
                        message.apiError(error);
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            var listStatuses = function() {
                var deferred = $q.defer();
                service.getStatuses()
                    .then(function(response) {
                        er.statuses = response.data.data;
                    }).catch(function(error) {
                        message.apiError(error);
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            var listServers = function() {
                var deferred = $q.defer();
                service.getServers()
                    .then(function(response) {
                        er.servers = response.data.data;
                    }).catch(function(error) {
                        message.apiError(error);
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            var listReservationTags = function() {
                var deferred = $q.defer();

                service.getReservationTags()
                    .then(function(response) {
                        er.tags = response.data.data;
                    }).catch(function(error) {
                        message.apiError(error);
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            var loadConfiguration = function() {
                var deferred = $q.defer();
                service.getConfigurationRes()
                    .then(function(response) {
                        er.configuration = response.data.data;
                    }).catch(function(error) {
                        message.apiError(error);
                    }).finally(function() {
                        deferred.resolve();
                    });

                return deferred.promise;
            };

            er.reservationEditAll = function() {
                $uibModalInstance.dismiss('cancel');
                $state.go('mesas.floor.reservation.edit', {
                    id: er.reservation.id,
                    date: er.reservation.date_reservation
                });
            };

            er.cancel = function() {
                $uibModalInstance.dismiss('cancel');
            };

            er.save = function() {
                var id = er.reservation.id;

                if ( (er.configuration.status_people_1 || er.configuration.status_people_2 || er.configuration.status_people_3) &&
                    (er.reservation.status_id == 4 | er.reservation.status_id == 5)) {
                    var suma = er.reservation.guests.men + er.reservation.guests.women + er.reservation.guests.children;
                    if (suma === 0 ) {
                        return message.alert("Es obligatorio indicar cantidad de invitados por tipo", "Este campo se encuentra en la parte inferior del formulario.");
                    }
                } else {
                    er.reservation.guests.men  = 0;
                    er.reservation.guests.women = 0;
                    er.reservation.guests.children = 0;
                }

                ///////////////////////////////////////////////////////////////
                // parse reservation.tags
                ///////////////////////////////////////////////////////////////
                er.reservation.tags = [];
                er.reservation.tags = Object.keys(er.selectTags).reduce(function(result, value) {
                    result.push(parseInt(value));
                    return result;
                }, []);

                service.blackList.key(er.reservation);

                service.quickEdit(id, er.reservation)
                    .then(function(response) {
                        $rootScope.$broadcast("floorReload", response.data.data, "update");
                        message.success(response.data.msg);
                        $uibModalInstance.dismiss('cancel');
                    }).catch(function(error) {
                        message.apiError(error);
                    });
            };

            er.cancelReservation = function() {
                message.confirm("¿ Esta seguro de cencelar la reservacion ?", "Esta accion se puede revertir", function() {
                    er.waitingResponse = true;
                    var id = er.reservation.id;

                    var key = service.blackList.key();

                    service.cancel(id, {
                            key: key
                        })
                        .then(function(response) {
                            $rootScope.$broadcast("floorReload", response.data.data, "update");
                            message.success(response.data.msg);
                            $uibModalInstance.dismiss('cancel');
                            er.waitingResponse = false;
                        }).catch(function(error) {
                            message.apiError(error);
                            er.waitingResponse = false;
                        });
                });
            };

            /*function listResource() {
                return $q.all([
                    listGuest(),
                    //listStatuses(),
                    //listServers(),
                    //loadConfiguration(),
                    //listReservationTags()
                ]);
            }*/

            /**
             * Select tags
             */
            er.addTag = function(tag) {
                tag.checked = !tag.checked;
                listTagsSelected();
            };

            var listTagsSelected = function() {
                angular.forEach(er.tags, function(tag) {
                    if (tag.checked) {
                        er.selectTags[tag.id] = angular.copy(tag);
                    } else {
                        delete er.selectTags[tag.id];
                    }
                });
            };

            var paintTags = function(tags) {
                angular.forEach(tags, function(tagInUse) {
                    angular.forEach(er.tags, function(tag) {
                        if (tag.id == tagInUse.id) {
                            tag.checked = true;
                        }
                    });
                });

                listTagsSelected();
            };

            var resetTags = function() {
                er.selectTags = {};
                angular.forEach(er.tags, function(tag) {
                    tag.checked = false;
                });
            };
            /**
             * END Select tags
             */

            (function Init() {
                var date = getFechaActual();

                service.getGuest().then(function(guests) {
                    er.covers = guests;
                });
                er.statuses = global.status.data;
                er.servers = global.servers.data;
                er.tags = global.tags.data;
                er.configuration = global.config;
                resetTags();
                parseInfo(content.reservation);
                parseData(content.reservation);
                paintTags(content.reservation.tags);
                guest_list_count(content.reservation);

            })();
        }
    ])
    .controller('ModalMailReservationCtrl', function($uibModalInstance, reservation, FloorDataFactory) {
        var vm = this;

        vm.reservation = {
            date: '',
            time: '',
            email: '',
            nombre: '',
            messages: []
        };

        vm.mailData = {
            message: '',
            subject: '',
            email: ''
        };

        var init = function() {
            //console.log(angular.toJson(reservation, true));
            vm.reservation.date = reservation.date_reservation;
            vm.reservation.time = reservation.hours_reservation;
            vm.reservation.email = reservation.email;
            var first_name = reservation.guest ? reservation.guest.first_name : "Reservacion sin nombre";
            var last_name = reservation.guest ? reservation.guest.last_name : "";
            vm.reservation.nombre = first_name + " - " + last_name;
            vm.reservation.note = reservation.note;
            vm.reservation.messages = reservation.emails;
            vm.mailData.email = reservation.email;

        };

        vm.sendMail = function() {
            FloorDataFactory.sendMessage(reservation.id, vm.mailData).then(
                function success(response) {
                    response = response.data;

                    messageAlert("Success", response.msg, "success", 2000, true);
                    $uibModalInstance.dismiss('cancel');

                    console.log("sendMail " + angular.toJson(response, true));
                },
                function error(response) {
                    message.apiError(response);
                    console.error("sendMail " + angular.toJson(response, true));
                });
        };

        vm.validateSendMail = function() {
            var valida = 0;

            if (vm.mailData.message === "") {
                alertMultiple("Alerta", "Ingrese un mensaje", "info", null);
                valida = 1;
            }

            if (vm.mailData.subject === "") {
                alertMultiple("Alerta", "Ingrese un asunto", "info", null);
                valida = 1;
            }

            if (valida === 0) {
                vm.sendMail();
            } else {
                $uibModalInstance.dismiss('cancel');
            }
        };

        vm.closeModal = function() {
            $uibModalInstance.dismiss('cancel');
        };

        init();
    })
    .controller("ModallCheckGuestListCtrl", ["$uibModalInstance", "$q", "reservationService", "reservation", "configuration", function($uibModalInstance, $q, reservationService, reservation, configuration) {

        var vm = this;
        vm.guestListAdd = [];
        vm.person = {
            man: {
                quantity: 0,
                auxiliar: 0,
                min: 0
            },
            woman: {
                quantity: 0,
                auxiliar: 0,
                min: 0
            },
            children: {
                quantity: 0,
                auxiliar: 0,
                min: 0
            },
            total: 0
        };

        var person = {
            man: 1,
            woman: 2,
            children: 3
        };

        vm.changeArrived = function(item) {
            if (!item.arrived) item.type_person = null;
            vm.countPerson();
        };

        vm.addGuest = function() {
            var guest = {
                name: vm.newGuest,
                arrived: 0,
                type_person: null
            };
            vm.guestListAdd.push(guest);
            vm.newGuest = null;
        };

        vm.countPerson = function(item, key) {
            vm.person.man.quantity = 0;
            vm.person.woman.quantity = 0;
            vm.person.children.quantity = 0;
            vm.person.man.auxiliar = vm.person.man.min;
            vm.person.woman.auxiliar = vm.person.woman.min;
            vm.person.children.auxiliar = vm.person.children.min;
            vm.person.total = 0;

            angular.forEach(vm.guestList, function(item) {
                if (!item.status) return;
                if (item.type_person === 1) {
                    vm.person.man.quantity++;
                    if (vm.person.man.quantity > vm.person.man.min) {
                        vm.person.man.auxiliar = vm.person.man.quantity;
                    }
                } else if (item.type_person === 2) {
                    vm.person.woman.quantity++;
                    if (vm.person.woman.quantity > vm.person.woman.min) {
                        vm.person.woman.auxiliar = vm.person.woman.quantity;
                    }
                } else if (item.type_person === 3) {
                    vm.person.children.quantity++;
                    if (vm.person.children.quantity > vm.person.children.min) {
                        vm.person.children.auxiliar = vm.person.children.quantity;
                    }
                }

                vm.person.total += item.arrived;
            });

            angular.forEach(vm.guestListAdd, function(item) {
                if (item.type_person === 1) {
                    vm.person.man.quantity++;
                    if (vm.person.man.quantity > vm.person.man.min) {
                        vm.person.man.auxiliar = vm.person.man.quantity;
                    }
                } else if (item.type_person === 2) {
                    vm.person.woman.quantity++;
                    if (vm.person.woman.quantity > vm.person.woman.min) {
                        vm.person.woman.auxiliar = vm.person.woman.quantity;
                    }
                } else if (item.type_person === 3) {
                    vm.person.children.quantity++;
                    if (vm.person.children.quantity > vm.person.children.min) {
                        vm.person.children.auxiliar = vm.person.children.quantity;
                    }
                }

                vm.person.total += item.arrived;
            });
        };

        vm.changePerson = function(item, key) {
            var auxiliar = item[key];

            item.man = 0;
            item.woman = 0;
            item.children = 0;
            item[key] = auxiliar;

            if (item[key] === 0) {
                item.type_person = null;
                item.arrived = 0;
            } else {
                item.type_person = person[key];
                item.arrived = 1;
            }

            vm.countPerson();
        };

        var initList = function() {
            angular.forEach(vm.guestList, function(item) {
                if (item.type_person === 1) {
                    item.man = 1;
                } else if (item.type_person === 2) {
                    item.woman = 1;
                } else if (item.type_person === 3) {
                    item.children = 1;
                }
            });

            angular.forEach(vm.guestListAdd, function(item) {
                if (item.type_person === 1) {
                    item.man = 1;
                } else if (item.type_person === 2) {
                    item.woman = 1;
                } else if (item.type_person === 3) {
                    item.children = 1;
                }
            });

            vm.countPerson();
        };

        vm.removeGuestListAdd = function(i) {
            vm.guestListAdd.splice(i, 1);
            vm.countPerson();
        };

        vm.removeGuestList = function(item) {
            item.status = 0;
            vm.countPerson();
        };

        vm.save = function() {
            vm.waitingResponse = true;
            reservationService.guestList(reservation.id, {
                guest_list: vm.guestList,
                guest_list_add: vm.guestListAdd
            }).then(
                function success(response) {
                    angular.forEach(response.data.data, function(value, key) {
                        reservation[key] = value;
                    });
                    message.success("Se actualizo lista de invitados");
                    vm.waitingResponse = false;
                    vm.cancel();
                },
                function error(error) {
                    message.apiError(error);
                    vm.waitingResponse = false;
                });
        };

        vm.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        var initModule = function() {
            vm.configPeople = configuration.status_people_1 + configuration.status_people_2 + configuration.status_people_3;
            vm.configuration = configuration;
            vm.person.man.min = reservation.num_people_1 * 1;
            vm.person.woman.min = reservation.num_people_2 * 1;
            vm.person.children.min = reservation.num_people_3 * 1;

            vm.guestList = angular.copy(reservation.guest_list);
            initList();
        };

        (function init() {
            initModule();
        })();
    }]);
angular.module('floor.controller')
    .controller('serverCtrl', function($scope, $rootScope, $state, ServerFactory, ServerDataFactory, ColorFactory, FloorFactory, reservationService, global) {

        var sm = this;

        /**
         * Variable para manejo de pantalla nuevo y crear
         */
        sm.flagServer = false;
        sm.server = {};

        /**
         * Crear y agregar nuevo servidor
         */
        sm.addServer = function() {
            sm.flagServer = false;
            sm.showForm = true;
            sm.server = {
                tables: []
            };
            ServerDataFactory.setTableServerItemsEdit(sm.server.tables);
            FloorFactory.isEditServer(true);
            angular.element('.bg-window-floor').addClass('drag-dispel');
        };

        /**
         * Editar un servidor
         * @param  {[Object]} server
         */
        sm.editServer = function(server) {
            sm.flagServer = true;
            sm.showForm = true;

            $rootScope.$broadcast("floorZoneIndexSelected", server.tables);
            global.lienzo.data.tablesSelected(server.tables);

            sm.server = angular.copy(server);
            ServerDataFactory.setTableServerItemsEdit(sm.server.tables);

            sm.selectColorForColor(sm.server.color);

            FloorFactory.isEditServer(true);
            angular.element('.bg-window-floor').addClass('drag-dispel');
        };

        /**
         * Limpiar zona de edicion / creacion
         */
        sm.cancelEdit = function(server) {
            sm.flagServer = false;
            sm.showForm = false;

            sm.server = {};
            sm.selectColorForColor("");

            FloorFactory.isEditServer(false);
            ServerDataFactory.cleanTableServerItems();

            global.lienzo.data.clearSelected();
            angular.element('.bg-window-floor').removeClass('drag-dispel');
            $state.go('mesas.floor.server');
        };

        /**
         * Marcar color del listado de colores disponibles
         * @param  {Object} color
         */
        sm.selectColor = function(color) {
            sm.server.color = color.hex;
            angular.forEach(sm.colors, function(color) {
                color.selected = false;
            });
            color.selected = true;
        };

        /**
         * Seleccionar el color del server al editar
         * @param  {String} color
         */
        sm.selectColorForColor = function(colorSearch) {
            angular.forEach(sm.colors, function(color) {
                if (color.hex == colorSearch) {
                    sm.server.color = color.hex;
                    color.selected = true;
                } else {
                    color.selected = false;
                }
            });
        };

        /**
         * Quitar una tabla de servidor
         * Botoncito X 
         * @param  {[Int]} item [Indice de tabla]
         * @param  {[Object]} tabla
         */
        sm.removeTable = function(item, table) {
            ServerDataFactory.delTableServerItemIndex(item);
            global.lienzo.data.notSelect(table);
        };

        sm.saveOrUpdateServer = function() {
            if (sm.flagServer === false) { // Se Crea un server
                reservationService.blackList.key(sm.server);
                ServerFactory.addServer(sm.server)
                    .then(function(response) {
                        message.success("Se registro el servidor");
                        sm.servers.add(response.data.data);
                        sm.cancelEdit();
                    }).catch(function(error) {
                        message.apiError(error);
                    });
            } else if (sm.flagServer === true) { // Se actualiza el server
                reservationService.blackList.key(sm.server);
                ServerFactory.updateServer(sm.server, sm.server.id)
                    .then(function(response) {
                        message.success("Se registro el servidor");
                        sm.servers.update(response.data.data);
                        sm.cancelEdit();
                    }).catch(function(error) {
                        message.apiError(error);
                    });

            }
        };

        sm.btnDeleteServer = function() {
            message.confirm("¿ Esta seguro de eliminar este servidor ?", "Esta accion no se puede revertir", function() {
                ServerFactory.deleteServer(sm.server.id)
                    .then(function(response) {
                        message.success("Se elimino el servidor");
                        sm.servers.delete(response.data.data);
                        sm.cancelEdit();
                    }).catch(function(error) {
                        message.apiError(error);
                    });
            });
        };

        (function Init() {
            sm.servers = global.servers;
            sm.colors = ColorFactory.getColor();
        })();

    });
angular.module('floor.controller')
    .controller('FloorCtrl', function($scope, $timeout, $q, $uibModal, $state, reservationHelper, reservationService, FloorFactory,
        ServerDataFactory, $table, $window, screenHelper, screenSizeFloor, global, TypeFilterDataFactory, FloorDataFactory) {

        var vm = this;

        /**
         * Fecha Actual
         * @type {date}
         */
        var fecha_actual = getFechaActual();

        /**
         * Fecha Actual
         * @type {date}
         */
        vm.fecha_actual = fecha_actual;

        vm.typeTurns = [];

        /**
         * Variables de manejo general de informacion
         */
        vm.zones = global.lienzo;
        var reservations = global.reservations;
        var servers = global.servers;
        var blocks = global.blocks;
        var shifts = global.shifts;
        var config = global.config;
        var sourceTypes = global.sourceTypes;
        var status = global.status;
        var tags = global.tags;
        var schedule = global.schedule;
        var zones = [];
        /**
         * END Variables de manejo general de informacion
         */

        /**
         * Accion que debe realizarse al soltar un elemento en una tabla
         * @type {Object}
         */
        var eventEstablished = {};

        /**
         * Variable de apoyo para saber que evento ejecutar en arrastre de objeto a un mesa
         */
        vm.titulo = "Floor";

        vm.flagSelectedZone = 0;

        //Notas turnos
        vm.notesBox = false;
        vm.notesBoxValida = false;
        vm.notesData = {
            texto: '',
            res_type_turn_id: ''
        };
        // vm.notesNotify = false; //se activa cuando llega notificaciones de notas
        vm.notesSave = false; // se activa cuando creamos notas

        var timeoutNotes;
        var openNotesTimeOut;

        $scope.$on("floorNotesReload", function(evt, note) {
            if (!reservationService.blackList.contains(note.key)) {
                angular.forEach(vm.typeTurns, function(typeTurn) {
                    if (typeTurn.turn) {
                        if (note.data.res_type_turn_id == typeTurn.turn.res_type_turn_id) {
                            typeTurn.notes = typeTurn.notes ? typeTurn.notes : {};
                            typeTurn.notes.texto = note.data.texto;
                        }
                    }
                });
                if (!vm.notesBoxValida) {
                    vm.notesNotification = true;
                }
                $scope.$apply();
            }
        });

        $scope.$on("floorZoneIndexSelected", function(evt, tables) {
            // var index = $table.getZoneIndexForTable(vm.zones.data, tables);
            // if (index !== null) vm.tabSelectedZone(index);
            vm.findTableForServer(tables);
        });

        $scope.$on("floorReload", function(evt, data, action) {
            if (action == "update") {
                reservations.update(data);
            } else if (action == "add") {
                reservations.add(data);
            }
        });

        vm.eventEstablish = function(eventDrop, data) {
            eventEstablished.event = eventDrop;
            eventEstablished.data = data;
        };

        vm.findTableForServer = function(tables) {
            var zones = vm.zones.data.getZoneForTables(tables);
            var index = zones.length ? zones[0].index : 0;
            vm.tabSelectedZone(index);
        };

        vm.tabSelectedZone = function(value) {
            FloorFactory.setNavegationTabZone(value);
            vm.flagSelectedZone = value;
        };

        var listTypeTurns = function() {
            FloorFactory.listTurnosActivos(vm.fecha_actual).then(
                function success(response) {
                    vm.typeTurns = response;
                    TypeFilterDataFactory.setTypeTurnItems(response);
                },
                function error(error) {
                    message.apiError(error);
                }
            );
        };

        // var loadServersCtrl = function(servers) {
        //     ServerDataFactory.setServerItems(servers);

        //     angular.forEach(servers, function(server, m) {
        //         ServerDataFactory.setColorItems(server.color);
        //     });
        // };

        // var listSourceTypes = function() {
        //     FloorDataFactory.getSourceTypes().then(function success(response) {
        //         TypeFilterDataFactory.setSourceTypesItems(response.data.data);
        //     }, function error(error) {
        //         message.apiError(error);
        //     });
        // };

        // var listStatuses = function() {
        //     var deferred = $q.defer();
        //     reservationService.getStatuses().then(function(response) {
        //         //vm.statuses = response.data.data;
        //         //console.log(vm.statuses);
        //         TypeFilterDataFactory.setStatusTypesItems(response.data.data);
        //     }).catch(function(error) {
        //         message.apiError(error);
        //     }).finally(function() {
        //         deferred.resolve();
        //     });

        //     return deferred.promise;
        // };

        // var loadBlocks = function() {
        //     FloorFactory.getBlocks().then(
        //         function success(response) {
        //             blocks = response;
        //             FloorFactory.asingBlockTables(blocks, vm.zones.data);
        //             $table.setBorderColorForReservation(vm.zones.data, blocks);
        //             //console.log(angular.toJson(blocks, true));
        //         },
        //         function error(response) {
        //             message.apiError(response, "No se pudo cargar las reservaciones");
        //         }
        //     );
        // };

        // var loadReservations = function() {

        //     FloorFactory.getReservations()
        //         .then(function(response) {
        //             reservations = response;
        //             //FloorFactory.setServicioReservaciones(response);
        //             //$rootScope.$broadcast("saveReservations", response);
        //             //console.log('Listado de reservaciones', angular.toJson(reservations, true));
        //         }).catch(function(error) {
        //             message.apiError(error, "No se pudo cargar las reservaciones");
        //         });

        // };

        // var loadBlocksReservationsServers = function() {
        //     //return $q.all([loadBlocks(), loadReservations()]);
        //     loadReservations();
        //     loadBlocks();
        //     loadServers();
        // };

        // var loadZones = function(date, reload) {
        //     FloorFactory.getZones(date, reload).then(
        //         function success(response) {

        //             zones = response;
        //             vm.zones.data = reservationHelper.loadTable(zones);
        //             FloorFactory.setDataZonesTables(zones);
        //             reloadFloor();
        //             //console.log(angular.toJson(vm.zones.data, true));
        //         },
        //         function error(response) {
        //             console.error(response);
        //         }
        //     );

        // };

        /**
         * Nuevo modulo de carga de zonas|tablas
         */
        $scope.$on("floorEventEstablish", function(evt, eventDrop, data) {
            vm.eventEstablish(eventDrop, data);
        });

        $scope.$on("floorTablesSelected", function(evt, tables) {
            vm.zones.data.tablesSelected(tables);
        });

        $scope.$on("floorClearSelected", function() {
            if (vm.zones.data.clearSelected) vm.zones.data.clearSelected();
        });

        var loadZones = function(date) {
            var deferred = $q.defer();

            reservationService.getZones(date)
                .then(function(response) {
                    zones.data = response.data.data;
                    deferred.resolve(zones.data);
                }).catch(function(error) {
                    message.apiError(error);
                });

            return deferred.promise;
        };

        var loadBlocks = function(date) {
            var deferred = $q.defer();

            reservationService.getTBlocks(date, true)
                .then(function(response) {
                    blocks.data = response.data.data;
                    deferred.resolve(blocks.data);
                }).catch(function(error) {
                    message.apiError(error);
                });

            return deferred.promise;
        };

        var loadReservations = function() {
            var deferred = $q.defer();

            reservationService.getReservations(true)
                .then(function(response) {
                    reservations.data = response.data.data;
                    deferred.resolve(reservations.data);
                }).catch(function(error) {
                    message.apiError(error, "No se pudo cargar las reservaciones");
                });

            return deferred.promise;
        };

        var loadServers = function() {
            var deferred = $q.defer();

            reservationService.getServers(true)
                .then(function(response) {
                    servers.data = response.data.data;
                    deferred.resolve(servers.data);
                }).catch(function(error) {
                    message.apiError(error);
                });

            return deferred.promise;
        };


        var InitModule = function() {

            var date = fecha_actual;

            FloorFactory.getDataFloor(date).then(function(response) {

                zones.data = response.zones;
                blocks.data = response.blocks;
                reservations.data = response.reservations;
                servers.data = response.servers;
                shifts.data = response.shifts;
                sourceTypes.data = response.sourceTypes;
                tags.data = response.tags;
                status.data = response.status;
                Object.assign(config, response.config);
                schedule = response.schedule;
                loadTablesEdit(response.zones, response.blocks, response.reservations, response.servers);
                showTimeCustom();

                vm.typeTurns = shifts.data;
                TypeFilterDataFactory.setTypeTurnItems(shifts.data);
                vm.configuracion = config;

            }).catch(function(error) {
                message.apiError(error);
            });


            /*$q.all([
                loadZones(date),
                loadBlocks(date),
                loadReservations(),
                loadServers(),
                //FloorDataFactory.getSourceTypes()
            ]).then(function(data) {
                console.log(data);
                loadTablesEdit(data[0], data[1], data[2], data[3]);

                showTimeCustom();

            });*/
        };

        vm.showTimeColor = {
            "seated": "#33c200",
            "complete": "#e6c610",
            "nextTime": "#ed615b",
            "nextTimeAll": "#3a99d8"
        };

        var showTimeCustom = function() {
            var tActive = $table.lastTimeEvent();
            if (tActive) vm.zones.data.tActive = tActive;
        };

        var loadTablesEdit = function(zones, blocks, reservations, servers) {
            vm.zones.data = reservationHelper.loadTableV2(zones, [{
                name: "blocks",
                data: blocks
            }, {
                name: "reservations",
                data: reservations
            }, {
                name: "servers",
                data: servers
            }]);
        };

        /**
         * Filtro y muestra de caja de tiempo
         */
        vm.hideTimes = function() {
            $table.lastTimeEvent("reset");
            vm.zones.data.tActive = null;
        };

        vm.showTimeCustom = function(event) {
            $table.setTimeEvent(event);
            vm.zones.data.tActive = event;
        };
        /**
         * END
         */

        vm.tablesSelected = function(table) {
            var tables = table.reservations.active.tables;
            vm.zones.data.tablesSelected(tables);
            $scope.$apply();
        };

        vm.clearSelected = function() {
            vm.zones.data.clearSelected();
            $scope.$apply();
        };

        /**
         * Filtro de mesas recomendas, bloquedas
         * y ocupadas en el rango de hora que se
         * pretende ocupar
         */
        vm.tableFilter = function(num) {
            vm.filter = true;
            vm.zones.data.tableFilter(num);
            $scope.$apply();
        };

        vm.tableFilterClear = function() {
            vm.filter = false;
            vm.zones.data.tableFilterClear();
            $scope.$apply();
        };
        /**
         * END
         */

        /**
         * Cambio de de mesa de una reservacion
         */
        var changeTable = function(table) {
            var dropTable = eventEstablished.data;
            if (dropTable.id != table.id) {
                var id = dropTable.reservations.active.id;
                var data = {
                    table_id: table.id
                };

                reservationService.blackList.key(data);

                reservationService.sit(id, data)
                    .then(function(response) {
                        reservations.update(response.data.data);
                    }).catch(function(error) {
                        message.apiError(error);
                    });
            }
        };

        /**
         * Eventos de Web Socket
         */
        var reservationEvents = {};
        reservationEvents.update = function(data, callback) {
            reservations.update(data, callback);
        };
        reservationEvents.create = function(data, callback) {
            reservations.add(data, callback);
        };

        var serverEvents = {};
        serverEvents.update = function(data, callback) {
            servers.update(data, callback);
        };
        serverEvents.create = function(data, callback) {
            servers.add(data, callback);
        };
        serverEvents.delete = function(data, callback) {
            servers.delete(data, callback);
        };

        var blockEvents = {};
        blockEvents.update = function(data, callback) {
            blocks.update(data, callback);
        };
        blockEvents.create = function(data, callback) {
            blocks.add(data, callback);
        };
        blockEvents.delete = function(data, callback) {
            blocks.delete(data, callback);
        };
        /**
         * END
         */

        $scope.$on("NotifyFloorTableReservationReload", function(evt, data) {
            if (!reservationService.blackList.contains(data.key)) {
                if (typeof reservationEvents[data.action] == "function") {
                    reservationEvents[data.action](data.data, function() {
                        if (data.user_msg) alertMultiple("Notificación: ", data.user_msg, "inverse", null, 'top', 'left', 5000, 20, 150);
                    });
                    if (!$scope.$$phase && !$scope.$root.$$phase) {
                        $scope.$apply();
                    }
                }
            }
        });

        $scope.$on("NotifyFloorTableServerReload", function(evt, data) {
            if (!reservationService.blackList.contains(data.key)) {
                if (typeof serverEvents[data.action] == "function") {
                    serverEvents[data.action](data.data, function() {
                        if (data.user_msg) alertMultiple("Notificación: ", data.user_msg, "inverse", null, 'top', 'left', 5000, 20, 150);
                    });
                    if (!$scope.$$phase && !$scope.$root.$$phase) {
                        $scope.$apply();
                    }
                }
            }
        });

        $scope.$on("NotifyFloorBlock", function(evt, data) {
            if (!reservationService.blackList.contains(data.key)) {
                if (typeof blockEvents[data.action] == "function") {
                    blockEvents[data.action](data.data, function() {
                        if (data.user_msg) alertMultiple("Notificación: ", data.user_msg, "inverse", null, 'top', 'left', 5000, 20, 150);
                    });
                    if (!$scope.$$phase && !$scope.$root.$$phase) {
                        $scope.$apply();
                    }
                }
            }
        });
        /**
         * END Nuevo Modulo
         */

        vm.mostrarDetail = function(index, table) {
            var estado = FloorFactory.isEditServer();
            if (estado === false) {
                modalInstancesDetail(index, table);
            } else {
                storeTables(index, table);
            }
        };

        function modalInstancesDetail(index, table) {
            var modalInstance = $uibModal.open({
                templateUrl: 'myModalContentDetail.html',
                controller: 'DetailInstanceCtrl',
                controllerAs: 'vmd',
                size: '',
                resolve: {
                    content: function() {
                        return {
                            zoneName: vm.zones.data[index].name,
                            table: table,
                            status: status,
                            config: config,
                            tags: tags,
                            schedule: schedule
                        };
                    }
                }
            });
        }

        vm.handConfiguration = function(obj) {

            if (eventEstablished.event == "changeTable") {
                return changeTable(obj);
            }

            //Preguntar si abrir ventana o guardar directamente
            vm.cantidades = {
                men: vm.numpeople.num_men,
                women: vm.numpeople.num_women,
                children: vm.numpeople.num_children,
                total: vm.numpeople.total
            };

            if (vm.configuracion.status_people_1 === 0 &&
                vm.configuracion.status_people_2 === 0 &&
                vm.configuracion.status_people_3 === 0) {

                if (eventEstablished.event == "sit") {
                    sit(obj);
                } else if (eventEstablished.event == "create") {
                    create(obj);
                }

            } else {
                if (eventEstablished.event == "sit") {
                    if (eventEstablished.data.res_reservation_status_id == 4) {
                        return sit(obj);
                    }
                }

                modalInstancesConfiguration(vm.cantidades, obj, vm.configuracion);
            }

        };

        var parseReservation = function(obj) {
            var now = moment();
            var date = now.format("YYYY-MM-DD");
            var start_time = now.clone().add(-(now.minutes() % 15), "minutes").second(0).format("HH:mm:ss");
            return {
                table_id: obj.id,
                guests: {
                    men: 0,
                    women: 0,
                    children: 0,
                    total: vm.cantidades.total
                },
                date: date,
                hour: start_time
            };
        };

        var create = function(obj) {
            var reservation = parseReservation(obj);

            reservationService.quickCreate(reservation)
                .then(function(response) {
                    reservations.add(response.data.data);
                }).catch(function(error) {
                    message.apiError(error);
                });
        };

        var sit = function(obj) {
            var id = eventEstablished.data.id;
            reservationService.sit(id, {
                    table_id: obj.id
                })
                .then(function(response) {
                    reservations.update(response.data.data);
                }).catch(function(error) {
                    message.apiError(error);
                });
        };

        function modalInstancesConfiguration(cantidades, obj, config) {
            var modalInstance = $uibModal.open({
                templateUrl: 'modalConfiguration.html',
                controller: 'ConfigurationInstanceCtrl',
                controllerAs: 'vmc',
                size: 'lg',
                resolve: {
                    num: function() {
                        return cantidades;
                    },
                    table: function() {
                        return obj;
                    },
                    config: function() {
                        return config;
                    },
                    eventEstablished: function() {
                        return eventEstablished;
                    }
                }
            });
        }

        function storeTables(num, table) {
            table.selected = !table.selected;

            if (!table.selected) {
                ServerDataFactory.delTableServerItem(table);
            } else {
                ServerDataFactory.setTableServerItems(table);
            }
        }

        var sizeLienzo = function() {
            vm.size = screenHelper.size(screenSizeFloor);
            vm.fontSize = (14 * vm.size / screenSizeFloor.minSize + "px");
        };

        vm.readNotes = function(notification) {
            vm.notesBoxValida = true;
            vm.notesNotification = false;
        };

        vm.listenNotes = function(notification) {
            vm.notesBoxValida = false;
            vm.notesNotification = false;
        };

        vm.saveNotes = function(turn) {
            if (timeoutNotes) $timeout.cancel(timeoutNotes);
            vm.notesData.id = turn.notes.id;
            vm.notesData.res_type_turn_id = turn.id;
            vm.notesData.texto = turn.notes.texto;
            vm.notesData.date_add = turn.notes.date_add;

            reservationService.blackList.key(vm.notesData);

            timeoutNotes = $timeout(function() {
                FloorFactory.createNotes(vm.notesData).then(
                    function success(response) {
                        vm.notesSave = true;
                        console.log("saveNotes success " + angular.toJson(response, true));
                    },
                    function error(response) {
                        console.error("saveNotes " + angular.toJson(response, true));
                    }
                );
            }, 1000);
        };

        angular.element($window).bind('resize', function() {
            sizeLienzo();
            $scope.$digest();
        });

        // $scope.$on("NotifyFloorNotesReload", function(evt, data) {
        //     if (!vm.notesBox) {
        //         vm.notesNotify = true;
        //         vm.notesNotification = true;

        //     }
        //     listTypeTurns();
        // });

        var loadConfigurationPeople = function() {
            FloorFactory.getConfiguracionPeople().then(function(response) {
                vm.configuracion = {
                    status_people_1: response.status_people_1,
                    status_people_2: response.status_people_2,
                    status_people_3: response.status_people_3,
                };
                //console.log("Configuracion: " + angular.toJson(vm.configuracion, true));
            });
        };

        $scope.$on("NotifyFloorConfigUpdateReload", function(evt, message) {
            alert(message + " Se requiere volver a cargar la página.");
            $window.location.reload();
        });

        var init = function() {
            InitModule();
            //listTypeTurns();
            sizeLienzo();
            //closeNotes();
            //loadConfigurationPeople();

        };

        init();
    })
    //POPUP CONFIGURACION DE PERSONAS (HOMBRES, MUJHERS Y NIÑOS)
    .controller('ConfigurationInstanceCtrl', function($uibModalInstance, num, table, config, eventEstablished, OperationFactory, reservationService, $rootScope) {
        var vmc = this;

        //Datos pasados al modal
        vmc.numperson = num;
        vmc.table = table;
        vmc.config = config;

        //Definiendo valores por defecto
        vmc.flagSelectedNumMen = num.men;
        vmc.flagSelectedNumWomen = num.women;
        vmc.flagSelectedNumChildren = num.children;
        vmc.resultado = num.men + num.women + num.children;

        vmc.colectionNum = []; //N° de casillas

        //Creando numero de casillas
        var createNumCollection = function() {
            var vNumpeople = [];
            for (var i = 0; i <= 12; i++) {
                vNumpeople.push({
                    num: i
                });
            }
            vmc.colectionNum = vNumpeople;
        };

        //Al pulsar numero 13 o mayor
        vmc.numThirteen = function(value, person) {
            if (person == 'men') {
                vmc.flagSelectedNumMen = value;
                vmc.flagSelectedCountNumMen = value;
                vmc.numdinamicoMen = value;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoMen);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
            if (person == 'women') {
                vmc.flagSelectedNumWomen = value;
                vmc.flagSelectedCountNumWomen = value;
                vmc.numdinamicoWomen = value;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoWomen);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
            if (person == 'children') {
                vmc.flagSelectedNumChildren = value;
                vmc.flagSelectedCountNumChildren = value;
                vmc.numdinamicoChildren = value;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoChildren);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
        };

        //Al pulsar numero menor a 13
        vmc.btnSelectedNum = function(value, person) {
            if (person == 'men') {
                vmc.flagSelectedNumMen = value;
                vmc.flagSelectedCountNumMen = 0;
                vmc.numdinamicoMen = 13;
                OperationFactory.setNumPerson(vmc.numperson, person, value);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
            if (person == 'women') {
                vmc.flagSelectedNumWomen = value;
                vmc.flagSelectedCountNumWomen = 0;
                vmc.numdinamicoWomen = 13;
                OperationFactory.setNumPerson(vmc.numperson, person, value);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
            if (person == 'children') {
                vmc.flagSelectedNumChildren = value;
                vmc.flagSelectedCountNumChildren = 0;
                vmc.numdinamicoChildren = 13;
                OperationFactory.setNumPerson(vmc.numperson, person, value);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
        };

        //Automarcar mayores que 13 segun datos traidos por defecto
        var defaultNumGuest = function() {
            if (num.men > 12) {
                vmc.numdinamicoMen = num.men;
                vmc.flagSelectedCountNumMen = num.men;
            } else {
                vmc.numdinamicoMen = 13;
            }

            if (num.women > 12) {
                vmc.numdinamicoWomen = num.women;
                vmc.flagSelectedCountNumWomen = num.women;
            } else {
                vmc.numdinamicoWomen = 13;
            }

            if (num.children > 12) {
                vmc.numdinamicoChildren = num.children;
                vmc.flagSelectedCountNumChildren = num.children;

            } else {
                vmc.numdinamicoChildren = 13;
            }
        };

        //Al pulsar boton plus
        vmc.sumar = function(person) {
            if (person == 'men') {
                vmc.numdinamicoMen++;
                vmc.flagSelectedCountNumMen = vmc.numdinamicoMen;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoMen);

                vmc.flagSelectedNumMen = vmc.numperson.men;
                console.log('Datos ' + angular.toJson(vmc.numperson));
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }

            if (person == 'women') {
                vmc.numdinamicoWomen++;
                vmc.flagSelectedCountNumWomen = vmc.numdinamicoWomen;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoWomen);

                vmc.flagSelectedNumWomen = vmc.numperson.women;
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }

            if (person == 'children') {
                vmc.numdinamicoChildren++;
                vmc.flagSelectedCountNumChildren = vmc.numdinamicoChildren;

                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoChildren);
                vmc.flagSelectedNumChildren = vmc.numperson.children;
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
        };
        //Al pulsar boton minus
        vmc.restar = function(person) {
            if (person == 'men') {
                if (vmc.numdinamicoMen > 13) {
                    vmc.numdinamicoMen--;
                    vmc.flagSelectedCountNumMen = vmc.numdinamicoMen;

                    OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoMen);
                    vmc.flagSelectedNumMen = vmc.numperson.men;
                    vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
                }
            }
            if (person == 'women') {
                if (vmc.numdinamicoWomen > 13) {
                    vmc.numdinamicoWomen--;
                    vmc.flagSelectedCountNumWomen = vmc.numdinamicoWomen;

                    OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoWomen);
                    vmc.flagSelectedNumWomen = vmc.numperson.women;
                    vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
                }
            }
            if (person == 'children') {
                if (vmc.numdinamicoChildren > 13) {
                    vmc.numdinamicoChildren--;
                    vmc.flagSelectedCountNumChildren = vmc.numdinamicoChildren;

                    OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoChildren);
                    vmc.flagSelectedNumChildren = vmc.numperson.children;
                    vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
                }
            }
        };

        vmc.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        function parseReservation() {
            return {
                table_id: table.id,
                guests: {
                    men: vmc.flagSelectedNumMen,
                    women: vmc.flagSelectedNumWomen,
                    children: vmc.flagSelectedNumChildren
                }
            };
        }

        vmc.save = function() {
            if (eventEstablished.event == "sit") {
                sit();
            } else if (eventEstablished.event == "create") {
                create();
            }
        };

        var create = function() {
            vmc.waitingResponse = true;
            var reservation = parseReservation();

            reservationService.blackList.key(reservation);

            reservationService.quickCreate(reservation)
                .then(function(response) {
                    $rootScope.$broadcast("floorReload", response.data.data, "add");
                    $uibModalInstance.dismiss('cancel');
                }).catch(function(error) {
                    message.apiError(error);
                    vmc.waitingResponse = false;
                });
        };

        var sit = function() {
            vmc.waitingResponse = true;

            var id = eventEstablished.data.id;
            var data = {
                table_id: table.id,
                guests: {
                    men: vmc.flagSelectedNumMen,
                    women: vmc.flagSelectedNumWomen,
                    children: vmc.flagSelectedNumChildren
                },
            };

            reservationService.blackList.key(data);

            reservationService.sit(id, data)
                .then(function(response) {
                    $rootScope.$broadcast("floorReload", response.data.data, "update");
                    $uibModalInstance.dismiss('cancel');
                }).catch(function(error) {
                    message.apiError(error);
                    vmc.waitingResponse = false;
                });
        };

        var init = function() {
            createNumCollection();
            defaultNumGuest();
        };

        init();
    })
    .controller('DetailInstanceCtrl', function($scope, $rootScope, $uibModalInstance, $uibModal, content, FloorFactory, reservationService, $state, $table, $q, global) {
        var vmd = this;

        /**
         * Tags de reservacion
         * @type {Array}
         */
        vmd.tags = [];

        /**
         * Tags de reservacion seleccionados
         * @type {Object}
         */
        vmd.selectTags = {};

        vmd.itemZona = {
            name_zona: content.zoneName,
            name: content.table.name
        };
        vmd.existTagsReservations = false;
        vmd.existPoximasReservationsBlocks = false;
        vmd.reservations = content.table.reservations;
        vmd.blocks = content.table.blocks;
        vmd.reservation = {};

        //  revisar
        // vmd.status = content.status;
        // vmd.servers = content.servers;
        // vmd.config = content.config;
        // vmd.schedule = content.schedule;
        // 

        vmd.statuses = global.status.data;
        vmd.servers = global.servers.data;
        vmd.tags = global.tags.data;
        vmd.configuration = global.config;

        vmd.countKeys = function(obj) {
            return Object.keys(obj).length;
        };

        vmd.reservationEditAll = function() {
            $uibModalInstance.dismiss('cancel');
            $state.go('mesas.floor.reservation.edit', {
                id: vmd.reservation.id,
                date: vmd.reservation.date_reservation
            });
        };

        var originalReservation = {};

        vmd.reservationEdit = function(reservation) {
            reservationService.getGuest().then(function(guests) {
                vmd.covers = guests;
            });
            // vmd.statuses = content.status;
            // vmd.servers = content.servers;
            // vmd.tags = content.tags;
            // vmd.configuration = content.config;
            resetTags();
            originalReservation = reservation;
            parseData(reservation);
            paintTags(reservation.tags);
            guest_list_count(reservation);

            vmd.EditContent = true;
        };

        vmd.blockEdit = function(date, blockId) {
            $uibModalInstance.dismiss('cancel');
            $state.go('mesas.floor.blockEdit', {
                date: date,
                block_id: blockId,
            });
        };

        vmd.infoName = function() {
            var first_name = originalReservation.guest ? originalReservation.guest.first_name : "Reservacion sin nombre";
            var last_name = originalReservation.guest ? originalReservation.guest.last_name : "";
            return first_name + " " + last_name;
        };
        vmd.infoDate = function() {
            return moment(originalReservation.date_reservation).format("dddd, D [de] MMMM");
        };
        vmd.infoTime = function(hour) {
            var hour_eval = hour || originalReservation.hours_reservation;
            return moment(hour_eval, "HH:mm:ss").format("H:mm A");
        };
        vmd.infoTables = function() {
            return getTables(originalReservation.tables);
        };

        function getTables(tables) {
            var reservationTables = "";
            angular.forEach(tables, function(table) {
                reservationTables += table.name + ", ";
            });

            return reservationTables.substring(0, reservationTables.length - 2);
        }

        function parseData(reservation) {
            var men = 0;
            var women = 0;
            var children = 0;
            if (vmd.configuration.status_people_1) {
                men = reservation.num_people_1 || 0;
            }
            if (vmd.configuration.status_people_2) {
                women = reservation.num_people_2 || 0;
            }
            if (vmd.configuration.status_people_3) {
                children = reservation.num_people_3 || 0;
            }
            vmd.reservation = {
                id: reservation.id,
                covers: reservation.num_guest,
                status_id: reservation.res_reservation_status_id,
                server_id: reservation.res_server_id,
                note: reservation.note || null,
                guests: {
                    men: men,
                    women: women,
                    children: children
                },
                date_reservation: reservation.date_reservation,
                hours_reservation: reservation.hours_reservation,
            };

            totalGuests();
        }

        function listResource() {
            return $q.all([
                listGuest(),
                listStatuses(),
                listServers(),
                loadConfiguration(),
                listReservationTags()
            ]);
        }

        vmd.sumar = function(guest) {
            vmd.reservation.guests[guest]++;
            totalGuests();
            guest_list_valid(guest);
        };

        vmd.restar = function(guest) {
            var quantity = vmd.reservation.guests[guest];
            if (quantity - 1 >= 0) {
                vmd.reservation.guests[guest]--;
                totalGuests();
            }
            guest_list_valid(guest);
        };

        /**
         * Validacion de cantidad invitados  vs cantidad en lista de invitados 
         */
        vmd.guestMessage = {
            men: {
                text: "• La  cantidad de  hombres es menor a la cantidad de hombres en la lista de invitados.",
                active: false
            },
            women: {
                text: "• La  cantidad de  mujeres es menor a la cantidad de mujeres en la lista de invitados.",
                active: false
            },
            children: {
                text: "• La  cantidad de  niños es menor a la cantidad de niños en la lista de invitados.",
                active: false
            }
        };

        var guest_list;
        var guest_list_count = function(reservation) {
            guest_list = reservation.guest_list.reduce(function(count, item) {
                if (item.type_person === 1) {
                    count.men++;
                } else if (item.type_person === 2) {
                    count.women++;
                } else if (item.type_person === 3) {
                    count.children++;
                }
                return count;
            }, {
                men: 0,
                women: 0,
                children: 0
            });

            guest_list_valid("men");
            guest_list_valid("women");
            guest_list_valid("children");
        };

        var guest_list_valid = function(guest) {
            if (vmd.reservation.guests[guest] < guest_list[guest]) {
                vmd.guestMessage[guest].active = true;
            } else {
                vmd.guestMessage[guest].active = false;
            }
        };
        /**
         * END
         */

        var totalGuests = function() {
            vmd.reservation.guests.total = vmd.reservation.guests.men + vmd.reservation.guests.women + vmd.reservation.guests.children;
        };

        var listGuest = function() {
            var deferred = $q.defer();
            reservationService.getGuest()
                .then(function(guests) {
                    vmd.covers = guests;
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    deferred.resolve();
                });

            return deferred.promise;
        };

        var listStatuses = function() {
            var deferred = $q.defer();
            reservationService.getStatuses()
                .then(function(response) {
                    vmd.statuses = response.data.data;
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    deferred.resolve();
                });

            return deferred.promise;
        };

        var listServers = function() {
            var deferred = $q.defer();
            reservationService.getServers()
                .then(function(response) {
                    vmd.servers = response.data.data;
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    deferred.resolve();
                });

            return deferred.promise;
        };

        var listReservationTags = function() {
            var deferred = $q.defer();

            reservationService.getReservationTags()
                .then(function(response) {
                    vmd.tags = response.data.data;
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    deferred.resolve();
                });

            return deferred.promise;
        };

        var loadConfiguration = function() {
            var deferred = $q.defer();
            reservationService.getConfigurationRes()
                .then(function(response) {
                    vmd.configuration = response.data.data;
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    deferred.resolve();
                });

            return deferred.promise;
        };

        vmd.cancelEdit = function() {
            vmd.EditContent = false;
            vmd.reservation = {};
            vmd.info = {};

            vmd.guestMessage.men.active = false;
            vmd.guestMessage.women.active = false;
            vmd.guestMessage.children.active = false;
        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };

        vmd.save = function() {
            var id = vmd.reservation.id;

            if ((vmd.configuration.status_people_1 || vmd.configuration.status_people_2 || vmd.configuration.status_people_3) &&
                (vmd.reservation.status_id == 4 | vmd.reservation.status_id == 5)) {
                var suma = vmd.reservation.guests.men + vmd.reservation.guests.women + vmd.reservation.guests.children;
                if (suma === 0 ) {
                    return message.alert("Es obligatorio indicar cantidad de invitados por tipo", "Este campo se encuentra en la parte inferior del formulario.");
                }
            } else {
                vmd.reservation.guests.men  = 0;
                vmd.reservation.guests.women = 0;
                vmd.reservation.guests.children = 0;
            }


            ///////////////////////////////////////////////////////////////
            // parse reservation.tags
            ///////////////////////////////////////////////////////////////
            vmd.reservation.tags = [];
            vmd.reservation.tags = Object.keys(vmd.selectTags).reduce(function(result, value) {
                result.push(parseInt(value));
                return result;
            }, []);

            reservationService.blackList.key(vmd.reservation);

            reservationService.quickEdit(id, vmd.reservation)
                .then(function(response) {
                    $rootScope.$broadcast("floorReload", response.data.data, "update");
                    message.success(response.data.msg);
                    $uibModalInstance.dismiss('cancel');
                }).catch(function(error) {
                    message.apiError(error);
                });
        };

        vmd.cancelReservation = function() {
            message.confirm("¿ Esta seguro de cencelar la reservacion ?", "Esta accion se puede revertir", function() {
                vmd.waitingResponse = true;
                var id = vmd.reservation.id;

                reservationService.blackList.key();

                reservationService.cancel(id, {
                        key: key
                    })
                    .then(function(response) {
                        $rootScope.$broadcast("floorReload", response.data.data, "update");
                        message.success(response.data.msg);
                        $uibModalInstance.dismiss('cancel');
                        vmd.waitingResponse = false;
                    }).catch(function(error) {
                        message.apiError(error);
                        vmd.waitingResponse = false;
                    });
            });
        };

        vmd.redirect = function() {
            $uibModalInstance.dismiss('cancel');
            var fecha_actual = getFechaActual();
            $state.go("mesas.floor.reservation.add", {
                date: fecha_actual,
                tables: [{
                    id: content.table.id
                }]
            });
        };

        /**
         * Select tags
         */
        vmd.addTag = function(tag) {
            tag.checked = !tag.checked;
            listTagsSelected();
        };

        var listTagsSelected = function() {
            angular.forEach(vmd.tags, function(tag) {
                if (tag.checked) {
                    vmd.selectTags[tag.id] = angular.copy(tag);
                } else {
                    delete vmd.selectTags[tag.id];
                }
            });
        };

        var paintTags = function(tags) {
            angular.forEach(tags, function(tagInUse) {
                angular.forEach(vmd.tags, function(tag) {
                    if (tag.id == tagInUse.id) {
                        tag.checked = true;
                    }
                });
            });

            listTagsSelected();
        };

        var resetTags = function() {
            vmd.selectTags = {};
            angular.forEach(vmd.tags, function(tag) {
                tag.checked = false;
            });
        };
        /**
         * END Select tags
         */
    });
  angular.module('floor.controller')
      .controller('WaitListCtrl', function($rootScope, $scope, $uibModal, $timeout, FloorFactory, $interval, global) {

          var wm = this;
          var validaModal = false;

          wm.res_listado = {
              actives: [],
              canceled: []
          };

          wm.search = {
              show: true
          };

          $rootScope.$broadcast("floorClearSelected");

          wm.disabledModal = function() {
              validaModal = true;
              $timeout(function() {
                  validaModal = false;
              }, 600);
          };

          wm.searchReservation = function() {
              wm.search.show = !wm.search.show;
          };

          wm.selectWaitlist = function(waitlist) {
              $scope.$apply(function() {
                  $rootScope.$broadcast("floorEventEstablish", "sit", waitlist);
              });
          };

          wm.createWait = function(option, data) {
              if (validaModal === true) {
                  return;
              }
              var modalInstance = $uibModal.open({
                  templateUrl: 'ModalCreateWaitList.html',
                  controller: 'ModalWaitListCtrl',
                  controllerAs: 'wl',
                  size: '',
                  resolve: {
                      option: function() {
                          return option;
                      },
                      data: function() {
                          return data;
                      }
                  }
              });
          };

          wm.mailReservationShow = function(reservation) {
              wm.disabledModal();
              var modalMailReservation = $uibModal.open({
                  animation: true,
                  templateUrl: 'myModalMailReservation.html',
                  size: 'md',
                  //keyboard: false,
                  controller: 'ModalMailReservationCtrl',
                  controllerAs: 'vm',
                  resolve: {
                      reservation: function() {
                          return reservation;
                      }
                  }
              });
          };

          var waitList = function() {
              wm.res_listado.actives.length = 0;
              wm.res_listado.canceled.length = 0;

              angular.forEach(wm.reservations.data, function(reservation) {

                  if (reservation.wait_list == 1) {
                      if (reservation.res_reservation_status_id != 6) {
                          var reservationCopy = angular.copy(reservation);
                          reservationCopy.minutes = calculateMinutesTime(reservationCopy.date_reservation + " " + reservationCopy.quote);
                          reservationCopy.time_out = false;

                          var interval = function() {
                              var now = moment();
                              var start_time = moment(reservationCopy.date_add);
                              reservationCopy.time_wait_list = moment.utc(now.diff(start_time)).format("HH:mm");

                              var validaTime = calculateMinutesTime(reservationCopy.date_reservation + " " + reservationCopy.time_wait_list);

                              if (validaTime >= reservationCopy.minutes) {
                                  reservationCopy.time_out = true;
                                  $interval.cancel(interval);
                              }
                          };

                          interval();
                          $interval(interval, 60000);

                          wm.res_listado.actives.push(reservationCopy);

                      } else {
                          wm.res_listado.canceled.push(angular.copy(reservation));
                      }
                  }
              });
          };

          var clear = function() {
              FloorFactory.isEditServer(false);
              angular.element('.bg-window-floor').removeClass('drag-dispel');
          };

          (function init() {
              wm.reservations = global.reservations;
              $scope.$watch("wm.reservations", waitList, true);

              clear();
          })();
      })
      .controller("ModalWaitListCtrl", function($rootScope, $state, $uibModalInstance, $q, reservationService, $timeout, option, data, FloorFactory, WaitListFactory, global) {

          var wl = this;
          var auxiliar;

          wl.reservation = {};
          wl.addGuest = true;
          wl.buttonText = 'Agregar a lista de espera';
          wl.title = "Nueva entrada";
          wl.option = option; //opcion del formulario : create | edit
          wl.covers = [];

          var listGuest = function() {
              var deferred = $q.defer();
              reservationService.getGuest()
                  .then(function(guests) {
                      wl.covers = guests;
                      wl.reservation.covers = 2;
                  }).catch(function(error) {
                      message.apiError(error);
                  }).finally(function() {
                      deferred.resolve();
                  });

              return deferred.promise;
          };

          var listDurations = function() {
              var deferred = $q.defer();

              reservationService.getDurations()
                  .then(function(durations) {
                      wl.durations = durations;
                      wl.reservation.quote = "00:15:00";
                  }).finally(function() {
                      deferred.resolve();
                  });

              return deferred.promise;
          };

          //Search guest list
          wl.searchGuest = function(name) {
              // console.log(name);
              if (auxiliar) $timeout.cancel(auxiliar);
              if (name === "") {
                  wl.guestList = [];
                  return;
              }
              var search = function() {
                  reservationService.getGuestList(name)
                      .then(function(response) {
                          wl.guestList = response.data.data.data;
                      }).catch(function(error) {
                          message.apiError(error);
                      });
              };

              auxiliar = $timeout(search, 500);
          };

          wl.selectGuest = function(guest) {
              wl.reservation.guest_id = guest.id;
              wl.guest = guest;
              wl.addGuest = false;
          };

          wl.removeGuest = function() {
              wl.reservation.guest_id = null;
              wl.newGuest = null;
              wl.guestList = [];
              wl.addGuest = true;
          };
          //End Search

          wl.cancel = function() {
              $uibModalInstance.dismiss('cancel');
          };

          wl.save = function() {
              if (!wl.reservation.guest_id) {
                  if (wl.newGuest) {
                      delete wl.reservation.guest_id;
                      wl.reservation.guest = wl.newGuest;
                  }
              } else {
                  delete wl.reservation.guest;
              }

              wl.reservation.guest = wl.newGuest;
              wl.buttonText = 'Enviando ...';

              if (wl.option == "create") {
                  save();
              } else {
                  update();
              }
          };

          var save = function() {
              reservationService.blackList.key(wl.reservation);
              reservationService.createWaitList(wl.reservation).then(
                  function success(response) {
                      global.reservations.add(response.data.data);
                      wl.buttonText = 'Agregar a lista de espera';
                      message.success(response.data.msg);
                      $uibModalInstance.dismiss('cancel');
                  },
                  function error(response) {
                      wl.buttonText = 'Agregar a lista de espera';
                      message.apiError(response.data);
                  });
          };

          var update = function() {
              reservationService.blackList.key(wl.reservation);
              reservationService.updateWaitList(wl.reservation).then(
                  function success(response) {
                      global.reservations.update(response.data.data);
                      wl.buttonText = 'Agregar a lista de espera';
                      message.success(response.data.msg);
                      $uibModalInstance.dismiss('cancel');
                  },
                  function error(response) {
                      wl.buttonText = 'Agregar a lista de espera';
                      message.apiError(response.data);
                  });
          };

          wl.delete = function() {
              var key = reservationService.blackList.key();
              reservationService.deleteWaitList(data.id, {
                  key: key
              }).then(
                  function success(response) {
                      global.reservations.update(response.data.data);
                      message.success(response.data.msg);
                      $uibModalInstance.dismiss('cancel');
                  },
                  function error(response) {
                      message.apiError(response.data);
                  });
          };

          var listResource = function() {
              return $q.all([listGuest(), listDurations()]);
          };

          var defineOption = function() {
              if (option === "edit") {

                  wl.reservation.id = data.id;
                  loadEditData();
              }
          };

          var loadEditData = function() {
              wl.title = "Editar entrada";

              if (data.guest !== null) {
                  wl.selectGuest(data.guest);
              }

              wl.reservation.covers = data.num_guest;
              wl.reservation.quote = data.quote;
              wl.reservation.note = data.note;
          };

          var init = function() {
              listResource().then(
                  function success(response) {
                      defineOption();
                  },
                  function error(response) {
                      console.error("listResource" + angular.toJson(response, true));
                  }
              );
          };

          init();
      });
angular.module('global.service', [])
    .factory('global', [function() {
        var
            reservations = {
                data: []
            },
            blocks = {
                data: []
            },
            servers = {
                data: []
            },
            zones = {
                data: []
            },
            lienzo = {
                data: []
            },
            tags = {
                data: []
            },
            status = {
                data: []
            },
            shifts = {
                data: []
            },
            sourceTypes = {
                data: []
            },
            schedule = {},
            config = {};

        /**
         * Funcion de actualizacion de objecto
         */
        reservations.update = function(updateList, callback) {
            try {
                var dateNow = moment().format("YYYY-MM-DD");
                angular.forEach(this.data, function(reservation, index) {
                    angular.forEach(updateList, function(item) {
                        if (reservation.id == item.id) {
                            angular.forEach(reservation.tables, function(obj_table) {
                                angular.forEach(lienzo.data.tables, function(table) {
                                    if (table.id == obj_table.id) {
                                        table.reservations.remove(reservation);
                                    }
                                });
                            });
                            if (item.date_reservation == dateNow) {
                                Object.assign(reservation, item);
                                angular.forEach(reservation.tables, function(obj_table) {
                                    angular.forEach(lienzo.data.tables, function(table) {
                                        if (table.id == obj_table.id) {
                                            table.reservations.add(reservation);
                                        }
                                    });
                                });
                            } else {
                                this.data.splice(index, 1);
                            }
                        }
                    });
                });
                if (typeof callback == "function") callback();
            } catch (e) {
                console.log("Reservations #update : " + e);
            }
        };
        reservations.add = function(reservation, callback) {
            try {
                var dateNow = moment().format("YYYY-MM-DD");
                if (reservation.date_reservation == dateNow) {
                    this.data.push(reservation);
                    angular.forEach(lienzo.data.tables, function(table) {
                        angular.forEach(reservation.tables, function(obj_table) {
                            if (table.id == obj_table.id) {
                                table.reservations.add(reservation);
                            }
                        });
                    });

                    if (typeof callback == "function") callback();
                }
            } catch (e) {
                console.log("Reservations #add : " + e);
            }
        };
        servers.update = function(data) {
            try {
                angular.forEach(this.data, function(server) {
                    angular.forEach(data, function(obj_data) {
                        if (server.id == obj_data.id) {
                            angular.forEach(lienzo.data.tables, function(table) {
                                angular.forEach(server.tables, function(obj_table) {
                                    if (table.id == obj_table.id && table.server.id == obj_data.id) {
                                        delete table.server;
                                    }
                                });
                            });
                            angular.forEach(obj_data, function(value, index) {
                                server[index] = value;
                            });
                            angular.forEach(lienzo.data.tables, function(table) {
                                angular.forEach(server.tables, function(obj_table) {
                                    if (table.id == obj_table.id) {
                                        table.server = server;
                                    }
                                });
                            });
                        }
                    });
                });
            } catch (e) {
                console.log("Servers #update : " + e);
            }
        };
        servers.add = function(server) {
            try {
                this.data.push(server);
                angular.forEach(lienzo.data.tables, function(table) {
                    angular.forEach(server.tables, function(obj_table) {
                        if (table.id == obj_table.id) {
                            table.server = server;
                        }
                    });
                });
            } catch (e) {
                console.log("Servers #add : " + e);
            }
        };
        servers.delete = function(del_server, callback) {
            try {
                angular.forEach(this.data, function(server, server_index) {
                    if (server.id == del_server.id) {
                        angular.forEach(lienzo.data.tables, function(table) {
                            angular.forEach(server.tables, function(obj_table) {
                                if (table.id == obj_table.id && table.server.id == del_server.id) {
                                    delete table.server;
                                }
                            });
                        });
                        servers.data.splice(server_index, 1);
                    }
                });
                if (typeof callback == "function") callback();
            } catch (e) {
                console.log("Servers #delete: " + e);
            }

        };
        blocks.update = function(updateList, callback) {
            try {
                var dateNow = moment().format("YYYY-MM-DD");
                angular.forEach(this.data, function(block, index) {
                    angular.forEach(updateList, function(item) {
                        if (block.id == item.id) {
                            angular.forEach(lienzo.data.tables, function(table) {
                                angular.forEach(block.tables, function(obj_table) {
                                    if (table.id == obj_table.id) {
                                        table.blocks.remove(block);
                                    }
                                });
                            });
                            if (item.start_date == dateNow) {
                                Object.assign(block, item);
                                angular.forEach(lienzo.data.tables, function(table) {
                                    angular.forEach(block.tables, function(obj_table) {
                                        if (table.id == obj_table.id) {
                                            table.blocks.add(block);
                                        }
                                    });
                                });
                            } else {
                                this.data.splice(index, 1);
                            }
                        }
                    });
                });
                if (typeof callback == "function") callback();
            } catch (e) {
                console.log("Blocks #update : " + e);
            }
        };
        blocks.add = function(block, callback) {
            try {
                var dateNow = moment().format("YYYY-MM-DD");
                if (block.start_date == dateNow) {
                    this.data.push(block);
                    angular.forEach(lienzo.data.tables, function(table) {
                        angular.forEach(block.tables, function(obj_table) {
                            if (table.id == obj_table.id) {
                                table.blocks.add(block);
                            }
                        });
                    });

                    if (typeof callback == "function") callback();
                }
            } catch (e) {
                console.log("Blocks #add : " + e);
            }
        };
        blocks.delete = function(del_block, callback) {
            try {
                angular.forEach(this.data, function(block, server_index) {
                    if (block.id == del_block.id) {
                        angular.forEach(lienzo.data.tables, function(table) {
                            angular.forEach(block.tables, function(obj_table) {
                                if (table.id == obj_table.id) {
                                    table.blocks.remove(del_block);
                                }
                            });
                        });
                        delete blocks.data[server_index];
                        blocks.data.splice(server_index, 1);
                    }
                });
                if (typeof callback == "function") callback();
            } catch (e) {
                console.log("Blocks #Delete : " + e);
            }
        };
        /**
         * END
         */

        return {
            reservations: reservations,
            servers: servers,
            lienzo: lienzo,
            blocks: blocks,
            shifts: shifts,
            config: config,
            schedule: schedule,
            tags: tags,
            status: status,
            sourceTypes: sourceTypes
        };
    }]);
angular.module('floor.service')
    .factory('WaitListFactory', function($q, $interval, FloorFactory, reservationService) {
        return {
            getWailList: function(reload) {
                var defered = $q.defer();
                var self = this;
                FloorFactory.getReservations(reload).then(
                    function success(response) {
                        var waitList = {
                            actives: [],
                            canceled: []
                        };

                        angular.forEach(response, function(reservation) {
                            if (reservation.wait_list == 1) {
                                if (reservation.res_reservation_status_id != 6) {
                                    reservation.minutes = calculateMinutesTime("2016-11-08 " + reservation.quote);
                                    reservation.time_out = false;

                                    var interval = function() {
                                        var now = moment();
                                        var start_time = moment(reservation.start_time, "HH:mm:ss");
                                        reservation.time_wait_list = moment.utc(now.diff(start_time)).format("HH:mm");

                                        var validaTime = calculateMinutesTime("2016-11-08 " + reservation.time_wait_list);

                                        if (validaTime >= reservation.minutes) {
                                            reservation.time_out = true;
                                            $interval.cancel(interval);
                                        }

                                        // console.log(calculateMinutesTime("2016-11-08 " + reservation.time_wait_list));
                                    };

                                    interval();
                                    $interval(interval, 60000);

                                    waitList.actives.push(reservation);
                                } else {
                                    waitList.canceled.push(reservation);
                                }
                            }
                        });

                        defered.resolve(waitList);
                    },
                    function error(response) {
                        defered.reject(response);
                    }
                );

                return defered.promise;
            },
            setDataWaitList: function(waitListData) {
                var waitList = {
                    actives: [],
                    canceled: []
                };

                angular.forEach(waitListData, function(reservation) {
                    if (reservation.wait_list == 1) {
                        if (reservation.res_reservation_status_id != 6) {
                            reservation.minutes = calculateMinutesTime("2016-11-08 " + reservation.quote);
                            reservation.time_out = false;

                            var interval = function() {
                                var now = moment();
                                var start_time = moment(reservation.start_time, "HH:mm:ss");
                                reservation.time_wait_list = moment.utc(now.diff(start_time)).format("HH:mm");

                                var validaTime = calculateMinutesTime("2016-11-08 " + reservation.time_wait_list);

                                if (validaTime >= reservation.minutes) {
                                    reservation.time_out = true;
                                    $interval.cancel(interval);
                                }
                            };

                            interval();
                            $interval(interval, 60000);

                            waitList.actives.push(reservation);

                        } else {
                            waitList.canceled.push(reservation);
                        }
                    }
                });

                return waitList;
            },
            saveWaitList: function(data, option) {
                var defered = null;

                if (option == "create") {
                    defered = reservationService.createWaitList(data);
                } else {
                    defered = reservationService.updateWaitList(data);
                }

                return defered;
            },
            deleteWaitList: function(waitListActives, waitListCancelled, dataWaitList) {
                //Eliminar de activos
                angular.forEach(waitListActives, function(value, key) {
                    if (value.reservation_id == dataWaitList.reservation_id) {
                        waitListActives.splice(key, 1);
                    }
                });
                //Agregar la lista de espera a cancelados
                waitListCancelled.push(dataWaitList);

                return waitListCancelled;
            },
            updateWaitList: function(waitListActives, dataWaitList) {
                angular.forEach(waitListActives, function(value, key) {
                    if (value.reservation_id == dataWaitList.reservation_id) {
                        waitListActives[key] = dataWaitList;
                    }
                });
            }
        };
    });
angular.module("notification.app")
    .controller('notificationCtrl', ["$scope", "$rootScope", "$q","notificationService", "reservationService", "$filter", "ServerNotification","$window", "DomainBookersnapAdmin",
         function($scope, $rootScope, $q, service, reservationService, $filter, ServerNotification, $window, bsDomain) {
        vm = this;

        vm.notification_count = 0;
        vm.reservations = [];
        vm.next_page_url = null;

        vm.prevReserves = function(){
            if (vm.next_page_url) {
                getNotifications(vm.next_page_url)
                    .then(function(){
                        var notifBody = $("#notif-body");
                        notifBody.animate({ scrollTop: notifBody.prop("scrollHeight")}, 800);
                    });
            }
        };

        var getNotifications = function(url)
        {
            var deferred = $q.defer();

            service.getNotifications(url)
                .then(function(response) {
                    vm.notification_count = response.data.data.notification_count;
                    var data = response.data.data.paginate.data;
                    angular.forEach(data, function(item) {
                        vm.reservations.push(item);
                    });
                    vm.next_page_url = response.data.data.paginate.next_page_url;
                    deferred.resolve();
                })
                .catch(function(error) {
                    console.log(error);
                    deferred.reject();
                });

            return deferred.promise;
        };

        vm.clearNotifications = function() {
            if (vm.notification_count) {
                service.clearNotifications()
                    .finally(function() {
                        vm.notification_count = 0;
                    });
            }
        };

        $rootScope.$on("NotifyWebReservation", function(evt, req) {
            var reservation = req.data;
            if (!reservationService.blackList.contains(req.key)) {
                if (reservation.res_source_type_id == 4 && req.action == "create") {
                    if (!$scope.$$phase && !$scope.$root.$$phase) {
                        $scope.$apply(function() {
                            $('#audio_notipromocion')[0].play();
                            vm.reservations.unshift(reservation);
                            vm.notification_count ++;
                            notifyMessage(reservation);
                        });
                    }
                }
            }
        });

        var notifyMessage = function(reservation) {
            var title =  reservation.guest.first_name +" "+ reservation.guest.last_name;
            var date = $filter("latamDate")(reservation.date_reservation+' '+reservation.hours_duration);
            var description = "Hizo una reserva para día " + date + " para " + reservation.num_guest  + " personas.";
            notify(title, description);
        };

        var serverSocket = ServerNotification.getConnection();

        serverSocket.on("b-mesas-floor-res", function(data) {
            $rootScope.$broadcast("NotifyWebReservation", data);
        });

        vm.closeSession = function() {
            delete localStorage.api_token;
            $window.location.href = bsDomain + "/auth/auth/logout";
        };

        (function Init() {
            getNotifications();
        })();
    }]);
angular.module("notification.app")
    .filter('latamDate', function() {
        return function(date_time) {
            return moment(date_time).format("dddd, D [de] MMM [a las] h:mm A");
        };
    });
angular.module("notification.app")
    .factory('notificationService', ["$http", "ApiUrlMesas", function($http, ApiUrlMesas) {
        return {
            getNotifications: function(page) {
                return $http.get(page ? page : ApiUrlMesas + "/notification");
            },
            clearNotifications: function() {
                return $http.put(ApiUrlMesas + "/notification");
            }
        };
    }]);
angular.module("widget.app")
    .controller("widgetCtrl", ["$scope", "$sce", "MenuConfigFactory", "IdMicroSitio", "DomainBookersnapAdmin", function($scope, $sce, menu, IdMicroSitio, DomainBookersnapAdmin) {
        var vm = this;

        vm.url= DomainBookersnapAdmin+"/w/"+ IdMicroSitio;
        vm.params = "#/?orientation=vertical";
        vm.iframe = templateIframe(vm.url + vm.params);
        vm.iframesrc = vm.url + vm.params;

        $("#color").change(function() {
            $scope.$apply(function(){
                vm.params= '#/?orientation=vertical&color=' + $("#color").val();
                vm.iframe =  templateIframe(vm.url + vm.params);
            });
        });

        vm.generateIframe = function() {
            vm.iframesrc = $sce.trustAsResourceUrl(vm.url + randon() + vm.params);
        };

        function randon() {
           return "?r=" + Math.round (Math.random() * 100 + 1);
        }

        function templateIframe (src) {
            return '<iframe id="bookersnap-widget" frameborder="0" width="260" height="535" src="' +src + '"></iframe>';
        }

        (function() {
            jsc.register();
            menu.menuActive(3);
        })();

    }]);
angular.module('bookersnap', ['bookersnap.directives','tables.app', 'bookersnap.services'])
angular.module("bookersnap.directives", [])
    .constant("loadTime", 5000)
    .directive("loadingBox", ["$interval", "loadTime", function($interval, loadTime) {
        return {
            restrict: 'E',
            scope: {
                waitLoad: "=wait",
                time: "=?",
                bg: "=?",
                pls: "=?"
            },
            template: '<div class="load-parent" ng-show="waitLoad" ng-class="[bg]">\
                              <div class="load-child" ng-class="[with]">\
                                     <div class="preloader" ng-class="[size,pls]">\
                                          <svg class="pl-circular" viewBox="25 25 50 50">\
                                                <circle class="plc-path" cx="50" cy="50" r="20"></circle>\
                                          </svg>\
                                      </div>\
                              </div>\
                        </div>',
            link: function(vm, element, attrs) {
                vm.with = attrs.size || "size-default";
                vm.size = attrs.size ? "pl-" + attrs.size : null;
                vm.bg = attrs.bg ? "bgm-" + attrs.bg : null;
                vm.pls = attrs.pls ? "pls-" + attrs.pls : null;

                var timeoutId;
                vm.time = vm.time || loadTime;

                vm.$watch("waitLoad", function(value) {
                    if (value === true) {
                        destroy();
                        setTime();
                    } else {
                        cancelLoad();
                    }
                });

                function setTime() {
                    timeoutId = $interval(function() {
                        cancelLoad();
                    }, vm.time);
                }

                function cancelLoad() {
                    destroy();
                    vm.waitLoad = false;
                }

                function destroy() {
                    if (timeoutId) {
                        $interval.cancel(timeoutId);
                    }
                }
            }
        };
    }])
    .directive("bsToggleClick", ["$document", function($document) {
        return {
            restrict: 'A',
            scope: {
                bsClose: "&",
                bsOpen: "&"
            },
            link: function(scope, element, attrs) {
                var parent = $(element).closest("[bs-toggle-click]").parent().parent();
                var children = parent.find("[bs-toggle-show]");

                var closeChildren = function(evt) {
                    if ($.contains(parent.get(0), evt.target)) {
                        children.removeClass("ng-hide");
                        $document.bind('click');
                    } else {
                        children.addClass("ng-hide");
                        $document.unbind('click');
                        scope.bsClose();
                        if (!scope.$$phase && !scope.$root.$$phase) {
                            scope.$apply();
                        }
                    }
                };

                element.bind("click", function(evt) {
                    if (children) {
                        children.toggleClass("ng-hide");

                        if (children.hasClass("ng-hide")) {
                            scope.bsClose();
                            $document.unbind('click', closeChildren);
                        } else {
                            scope.bsOpen();
                            $document.bind('click', closeChildren);
                        }
                        if (!scope.$$phase && !scope.$root.$$phase) {
                            scope.$apply();
                        }
                    }
                });

                children.addClass("ng-hide");
            }
        };
    }]);
angular.module("bookersnap.services", [])
    .factory('MenuConfigFactory', function($timeout) {
        return {
            menuActive: function(index) {

                $timeout(function() {
                    angular.element("#menu-config li").removeClass("active");
                    angular.element("#menu-config li").eq(index).addClass("active");
                }, 500);

            }
        };

    })
    .factory('HttpFactory', function($http) {
        return {
            get: function(httpUrl, config, objectData, reload) {

                if (reload === true) objectData = null;
                if (objectData) return objectData;

                return $http.get(httpUrl, config);

            }
        };
    })
    .factory('ServerNotification', function(UrlServerNotify, $http) {
        var serverConnection;
        return {
            createConnection: function() {
                if (serverConnection) {
                    console.log("existe serverConnection");
                    return serverConnection;
                }
                try {
                    serverConnection = io.connect(UrlServerNotify);
                } catch (err) {
                    console.log("error conexion realtime", err);
                }

                console.log(serverConnection);

                return serverConnection;
            },
            createRoom: function(room) {
                //var roomJwt = JwtKey.generated();
                //var roomJwt = $http.defaults.headers.common['Authorization'];
                serverConnection.emit("create-room-micrositio", room);
            },
            getConnection: function() {
                return serverConnection;
            }
        };
    })
    .factory('JwtKey', function(IdMicroSitio) {

        return {
            generated: function() {
                // Header
                var oHeader = {
                    alg: 'HS256',
                    typ: 'JWT'
                };
                // Payload
                var oPayload = {};
                var tNow = KJUR.jws.IntDate.get('now');
                var tEnd = KJUR.jws.IntDate.get('now + 1day');
                //oPayload.iss = "http://foo.com";
                //oPayload.sub = "mailto:mike@foo.com";
                oPayload.nbf = tNow;
                oPayload.iat = tNow;
                oPayload.exp = tEnd;
                oPayload.jti = "id123456";

                oPayload.micro = IdMicroSitio;
                // Sign JWT, password=616161
                var sHeader = JSON.stringify(oHeader);
                var sPayload = JSON.stringify(oPayload);
                var sJWT = KJUR.jws.JWS.sign("HS256", sHeader, sPayload, "616161");

                console.log("generated " + angular.toJson(sJWT, true));
                return sJWT;

            }
        };
    });