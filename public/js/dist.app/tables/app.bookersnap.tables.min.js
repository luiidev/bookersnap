angular.module('block.app', ['block.controller','block.service','block.directive'])
.config(function ($stateProvider, $urlRouterProvider){
	$stateProvider
		.state ('mesas.block', {
			url: '/block/:date',
			templateUrl: '/js/app/tables/block/view/create.old.html',
                        controller: "blockCtr",
                        cache: false
		})
		.state ('mesas.blockEdit', {
			url: '/block/:date/:block_id',
			templateUrl: '/js/app/tables/block/view/edit.new.html',
                        controller: "blockCtrEdit",                        
                        cache: false
		})
    
});
angular.module('block.controller', [])
    .controller('blockCtr', function($scope, $http, $state, $sce, $stateParams, $document, $window, reservationScreenHelper, ApiUrlMesas, BlockFactory, ZoneFactory, ZoneLienzoFactory, TableFactory, $uibModal, IdMicroSitio) {

        $scope.date = $stateParams.date;

        /* Listado array de zonas incluyendo sus zonas */
        ZoneFactory.getZones().then(function(response) {
            $scope.zones = response.data.data; // Lista de Zonas que contienen mesas
            return $scope.zones;
        }).then(function(zonas) {
            // Se obtiene de array de las mesas que estan en ese rango de fecha
            BlockFactory.getAllBlock("date=" + $scope.date).then(function(response) {
                var mesasFuturasBloqueadas = response.data.data;

                /////////////////////////////////////////////////////////////////////////////////////// 
                //Se agrega la clase para identificar los bloqueos futuros dentro del array principal  
                ///////////////////////////////////////////////////////////////////////////////////////
                angular.forEach(zonas, function(zona, key) {
                    angular.forEach(zona.tables, function(mesa, i) {
                        // Iteracion para identificar las mesas bloqueadas 
                        for (var p = 0; p < mesasFuturasBloqueadas.length; p++) {
                            if (mesa.id == mesasFuturasBloqueadas[p].res_table_id) {
                                $scope.zones[key].tables[i].classBloqueado = "selected-table-2";
                            }
                        }
                        // Iteracion para mostrar mesas bloqueadas en el mismo rango de fechas bloqueadas 
                    });
                });
                //////////////////////////////////////////////////////////////////////////////////////
            });

        });

        /** Carga la informacion de la pantalla add Block **/
        $scope.shifts = [];
        $scope.startTimes = [];
        $scope.endTimes = [];
        $http.get(ApiUrlMesas + '/calendar/' + $stateParams.date + '/shifts').success(function(response) {
            angular.forEach(response.data, function(item, i) {
                if (item.turn != null) { // Se obtienes los Shifts que contienen datos

                    $scope.shifts.push({
                        id: item.id,
                        name: item.name,
                        startTimes: getRangoHours(item.turn.hours_ini, item.turn.hours_end),
                        endTimes: getRangoHours(addHourByMin(item.turn.hours_ini), item.turn.hours_end),
                    });

                    // Se muestra el primer array para cuando se esta creando el bloqueo
                    $scope.shift = $scope.shifts[0];
                    $scope.startTimes = $scope.shifts[0].startTimes;
                    $scope.endTimes = $scope.shifts[0].endTimes;
                }
            });
        });


        // Se muestran las mesas de la zona seleccionada   
        $scope.selectZone = function(item) {
            angular.forEach($scope.zones, function(value, key) {
                if (value.id == item.id) {
                    $scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                    loadTablesEdit(value.tables);
                }
            });
        };

        // Se cambia el rango del shift elegido de acuerdo a la eleccion   
        $scope.changueRange = function(item) {
            $scope.startTimes = item.startTimes;
            $scope.endTimes = item.endTimes;
        };

        $scope.coversList = BlockFactory.coverList();
        $scope.boxTables = BlockFactory.boxTables();

        var listCovers = function(option) {

            var coverList = "";

            if (option == "min") {
                coverList = $scope.coversList.dataMin;
            } else {
                coverList = $scope.coversList.dataMax;
            }

            for (var i = 1; i <= 30; i++) {
                var data = {
                    label: i + " covers",
                    id: i
                }

                coverList.push(data);
            }

            if (option == "min") {
                $scope.coversList.selectedMin = coverList[0];
            } else {
                $scope.coversList.selectedMax = coverList[0];
            }
        };


        /***************Funcion ejecutado para agregar  o retirar una mesa bloqueada ****************/
        $scope.mesasBloqueadas = [];
        $scope.activarTableOptions = function(index, data) {
            BlockFactory.checkTable($scope, $sce, index, data);
        };

        $scope.desactivarTable = function(index, data) {
            BlockFactory.uncheckTable($scope, $sce, index, data);
        };

        var getDataTableSelected = function(index) {

            $scope.indexTable = index;

            angular.element("#name-table").val($scope.itemTables[index].name);
            $scope.changeShapeTable($scope.itemTables[index].shape);

            $scope.itemTables[index].top = angular.element("#tb-item" + index).css("top").replace("px", "");
            $scope.itemTables[index].left = angular.element("#tb-item" + index).css("left").replace("px", "");

            $scope.coversList.selectedMin = {
                id: $scope.itemTables[$scope.indexTable].minCover,
                label: $scope.itemTables[$scope.indexTable].minCover + " covers"
            };

            $scope.coversList.selectedMax = {
                id: $scope.itemTables[$scope.indexTable].maxCover,
                label: $scope.itemTables[$scope.indexTable].maxCover + " covers"
            };

            $scope.sizeTableList.selectedOption = {
                id: TableFactory.getIdSize($scope.itemTables[index].size),
                label: $scope.itemTables[index].size
            };
        };

        $scope.openCalendar = function($event, opened) {
            $event.preventDefault();
            $event.stopPropagation();
            $scope.opened = true;
        };

        $scope.object = [];
        $scope.saveZone = function(option) {


            if ($scope.startTime == undefined || $scope.endTime == undefined || $scope.date == undefined) {

                messageAlert("Warning", "Tienes que seleccionar \"Start Time\", \"End Time\" y \"date\" ", "warning", 3000);

            } else {

                //Se arma la estrutura de datos
                $scope.object = {
                    start_date: $scope.date,
                    start_time: $scope.startTime.hour24,
                    end_time: $scope.endTime.hour24,
                    tables: [],
                }

                //Se crea el array de mesas bloqueadas          
                for (var i = 0; i < $scope.mesasBloqueadas.length; i++) {
                    $scope.object.tables.push({
                        id: $scope.mesasBloqueadas[i]
                    });
                }

                BlockFactory.addNewBlock($scope.object).then(function(response) {
                    if (response.data.success === true) {
                        messageAlert("Success", response.data.msg, "success", 3000);
                    } else if (response.data.response == false) {
                        messageAlert("Warning", response.data.jsonError, "warning", 2000);
                    }
                });

            }

        };


        /* Esta clase recorre las mesas listadas y crea un nuevo objeto dataTable que se iterara en la vista para imprimir las mesas * */
        var loadTablesEdit = function(tables) {
            BlockFactory.initItemTables($scope, tables, TableFactory);
        };

        $scope.selectAllTables = function() {
            BlockFactory.selectAllTables($scope, $sce, loadTablesEdit);
        }

        $scope.unselectAllTables = function() {
            BlockFactory.unselectAllTables($scope, $sce, loadTablesEdit);
        }
        
        angular.element($window).bind('resize', function(){
            var size = reservationScreenHelper.size($scope);
            $scope.size = size;
            $scope.$digest();
        });
        
        (function Init() {
            $scope.size = reservationScreenHelper.size();
        })();
    
        listCovers("min");
        listCovers("max");
    })

.controller('blockCtrEdit', function($scope, $http, $sce, $state, $stateParams, $document, $window, reservationScreenHelper, ApiUrlMesas, BlockFactory, ZoneFactory, ZoneLienzoFactory, TableFactory, $uibModal, IdMicroSitio) {

    $scope.date = $stateParams.date;
    var block_id = $stateParams.block_id;
    // Se trae la informacion del bloqueo para poder mostrar las tablas y editar
    BlockFactory.getBlock(block_id).then(function(response) {
        
        $scope.tableBlock = response.data.data;
        angular.forEach(response.data.data.tables, function(mesa, indexMesa) {
            $scope.mesasBloqueadas.push(mesa.id);
        });

        BlockFactory.updateTablesBlocked($scope, $sce); // Actualizar mensaje

        return $scope.mesasBloqueadas;

    }).then(function(mesasBloqueadas) {                
        // Listado array de zonas incluyendo sus zonas 
        return ZoneFactory.getZones().then(function(response) {

            $scope.zones = response.data.data; // Lista de Zonas que contienen mesas

            ////////////////////////////////////////////////////////////////////////////////////////
            //Se crea crea el metodo para poder identificar cual es la clase que esta seleccionada// 
            ////////////////////////////////////////////////////////////////////////////////////////
            angular.forEach($scope.zones, function(zona, key) {

                angular.forEach(zona.tables, function(mesa, i) {

                    // Iteracion para identificar las mesas bloqueadas 
                    for (var p = 0; p < mesasBloqueadas.length; p++) {
                        if (mesa.id === mesasBloqueadas[p]) {                            
                            $scope.zones[key].tables[i].class = "selected-table";                            
                        }

                    }
                    // Iteracion para mostrar mesas bloqueadas en el mismo rango de fechas bloqueadas 
                });
            });

            return $scope.zones;
            //////////////////////////////////////////////////////////////////////////////////////
        });

    }).then(function(zones) {
        $scope.zones = zones;
        // Se obtiene de array de las mesas que estan en ese rango de fecha
        BlockFactory.getAllBlock("date=" + $scope.date).then(function(response) {
                        
            var mesasFuturasBloqueadas = [];
            angular.forEach(response.data.data, function(mesaFuturaBloqueada, i) {
                if (mesaFuturaBloqueada.res_block_id != block_id && mesaFuturaBloqueada.res_reservation_id === null) {
                    mesasFuturasBloqueadas.push(mesaFuturaBloqueada);
                }
            });
            /////////////////////////////////////////////////////////////////////////////////////// 
            //Se agrega la clase para identificar los bloqueos futuros dentro del array principal  
            ///////////////////////////////////////////////////////////////////////////////////////
            
            angular.forEach($scope.zones, function(zona, key) {
                angular.forEach(zona.tables, function(mesa, i) {
                    // Iteracion para identificar las mesas bloqueadas 
                    for (var p = 0; p < mesasFuturasBloqueadas.length; p++) {
                        if (mesa.id == mesasFuturasBloqueadas[p].res_table_id) {          
                            $scope.zones[key].tables[i].classBloqueado = "block";                      
                        }
                    }
                    // Iteracion para mostrar mesas bloqueadas en el mismo rango de fechas bloqueadas 
                });
            });
            //////////////////////////////////////////////////////////////////////////////////////
        });
    });

    /** carga la información de la pantalla edit Block **/
    $scope.shifts = [];
    $scope.startTimes = [];
    $scope.endTimes = [];
    $http.get(ApiUrlMesas + '/calendar/' + $stateParams.date + '/shifts').success(function(response) {
        //console.log(response);
        angular.forEach(response.data, function(item, i) {
            if (item.turn != null) { // Se obtienes los Shifts que contienen datos

                $scope.shifts.push({
                    id: item.id,
                    name: item.name,
                    startTimes: getRangoHours(item.turn.hours_ini, item.turn.hours_end),
                    endTimes: getRangoHours(addHourByMin(item.turn.hours_ini), item.turn.hours_end),
                });

                /* Rango de horas */
                rangoInicialItem = item.turn.hours_ini;
                rangoFinalItem = item.turn.hours_end;

                rangoInicialTableBlock = $scope.tableBlock.start_time;
                rangoFinalTableBlock = $scope.tableBlock.end_time;

                console.log("item ini:", rangoInicialItem);
                console.log("item end:", rangoFinalItem);
                console.log("scope ini:", rangoInicialTableBlock);
                console.log("scope end:", rangoFinalTableBlock);

                if (rangoInicialTableBlock >= rangoInicialItem && rangoFinalTableBlock <= rangoFinalItem) {

                    var indexFound = $scope.shifts.length - 1;
                    $scope.shift = $scope.shifts[indexFound];

                    angular.forEach($scope.shifts[indexFound].startTimes, function(startTime, i) {
                        if (startTime.hour24 == rangoInicialTableBlock) {

                            $scope.startTimes = $scope.shifts[indexFound].startTimes;
                            $scope.endTimes = $scope.shifts[indexFound].endTimes;

                            $scope.startTime = $scope.shifts[indexFound].startTimes[i];
                            $scope.endTime = $scope.shifts[indexFound].endTimes[i];
                        }
                        /*
                         */
                    });
                }

                /*
                $scope.shift = $scope.shifts[0];
                $scope.startTimes = $scope.shifts[0].startTimes;
                $scope.endTimes = $scope.shifts[0].endTimes;
                */
            }
        });

        /* Se busca si el rango coincide con el editar */
        // console.log($scope.shifts);
        // Se muestra el primer array para cuando se esta creando el bloqueo
        //console.log($scope.tableBlock.start_time);
        //console.log($scope.tableBlock.end_time);

    });

    // Se muestran las mesas de la zona seleccionada   
    $scope.selectZone = function(item) {
        angular.forEach($scope.zones, function(value, key) {
            if (value.id == item.id) {
                $scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                loadTablesEdit(value.tables);
            }
        });
    };


    // Se cambia el rango del shift elegido de acuerdo a la eleccion   
    $scope.changueRange = function(item) {
        $scope.startTimes = item.startTimes;
        $scope.endTimes = item.endTimes;
    };

    $scope.coversList = BlockFactory.coverList();
    $scope.boxTables = BlockFactory.boxTables();

    var listCovers = function(option) {

        var coverList = "";

        if (option == "min") {
            coverList = $scope.coversList.dataMin;
        } else {
            coverList = $scope.coversList.dataMax;
        }

        for (var i = 1; i <= 30; i++) {
            var data = {
                label: i + " covers",
                id: i
            }            
            coverList.push(data);
        }

        if (option == "min") {
            $scope.coversList.selectedMin = coverList[0];
        } else {
            $scope.coversList.selectedMax = coverList[0];
        }
    };


    /***************Funcion ejecutado para agregar  o retirar una mesa bloqueada ****************/
    $scope.mesasBloqueadas = [];
    $scope.activarTableOptions = function(index, data) {
        BlockFactory.checkTable($scope, $sce, index, data);
    };

    $scope.desactivarTable = function(index, data) {
        BlockFactory.uncheckTable($scope, $sce, index, data);
    }

    var getDataTableSelected = function(index) {

        $scope.indexTable = index;

        angular.element("#name-table").val($scope.itemTables[index].name);
        $scope.changeShapeTable($scope.itemTables[index].shape);

        $scope.itemTables[index].top = angular.element("#tb-item" + index).css("top").replace("px", "");
        $scope.itemTables[index].left = angular.element("#tb-item" + index).css("left").replace("px", "");

        $scope.coversList.selectedMin = {
            id: $scope.itemTables[$scope.indexTable].minCover,
            label: $scope.itemTables[$scope.indexTable].minCover + " covers"
        };

        $scope.coversList.selectedMax = {
            id: $scope.itemTables[$scope.indexTable].maxCover,
            label: $scope.itemTables[$scope.indexTable].maxCover + " covers"
        };

        $scope.sizeTableList.selectedOption = {
            id: TableFactory.getIdSize($scope.itemTables[index].size),
            label: $scope.itemTables[index].size
        };
    };

    $scope.openCalendar = function($event, opened) {
        $event.preventDefault();
        $event.stopPropagation();
        $scope.opened = true;
    };


    $scope.deleteBlock = function() {

        // Se obtiene de array de las mesas que estan en ese rango de fecha
        BlockFactory.deleteBlock(block_id).then(function(response) {
            if (response.data.success == true) {
                messageAlert("Success", response.data.msg, "success", 3000);
            } else if (response.data.success == false) {
                messageAlert("Warning", response.data.msg, "warning", 3000);
            }
        });

    };

    $scope.object = [];
    $scope.saveZone = function(option) {

        if ($scope.startTime == undefined || $scope.endTime == undefined || $scope.date == undefined) {

            messageAlert("Warning", "Tienes que seleccionar \"Start Time\", \"End Time\" y \"date\" ", "warning", 3000);

        } else {

            //Se arma la estrutura de datos
            $scope.object = {
                start_date: $scope.date,
                start_time: $scope.startTime.hour24,
                end_time: $scope.endTime.hour24,
                tables: [],
            }

            //Se crea el array de mesas bloqueadas          
            for (var i = 0; i < $scope.mesasBloqueadas.length; i++) {
                $scope.object.tables.push({
                    id: $scope.mesasBloqueadas[i]
                });
            }

            BlockFactory.editBlock("/" + block_id, $scope.object).then(function(response) {
                if (response.data.success === true) {
                    messageAlert("Success", response.data.msg, "success", 3000);
                } else if (response.data.success == false) {
                    messageAlert("Warning", response.data.msg, "warning", 3000);
                }
            });

        }

    };

    /* Esta clase recorre las mesas listadas y crea un nuevo objeto dataTable que se iterara en la vista para imprimir las mesas * */
    var loadTablesEdit = function(tables) {
        BlockFactory.initItemTables($scope, tables, TableFactory);
    };

    $scope.selectAllTables = function() {
        BlockFactory.selectAllTables($scope, $sce, loadTablesEdit);
    }

    $scope.unselectAllTables = function() {
        BlockFactory.unselectAllTables($scope, $sce, loadTablesEdit);
    }

    angular.element($window).bind('resize', function(){
            var size = reservationScreenHelper.size($scope);
            $scope.size = size;
            $scope.$digest();
    });
    
    (function Init() {
        $scope.size = reservationScreenHelper.size();
    })();

    listCovers("min");
    listCovers("max");
});
angular.module('block.directive', [])
.directive('ngSelectTable', function(){

  function makeSelectTable(scope, element, attr) {
    
    var left = attr.x;
    var top = attr.y;

    element.css({
      position: 'absolute',
      cursor: 'pointer',
      top: top + 'px',
      left: left + 'px',
    });

    element.on('click',function(event){

      event.preventDefault();
      if(this.classList.contains('selected-table') === true){
        this.classList.remove('selected-table');
        scope.onDeselectFn();
      }else{
        if (this.classList.contains('selected-table')) {
          this.classList.remove('selected-table');
        } else {
          this.classList.add('selected-table');
        }
        scope.onSelectedFn();
      }

    });
  }

  return {
    link: makeSelectTable,
    scope: {
      onSelectedFn : '&',
      onDeselectFn : '&'
    }
  };

});
angular.module('block.service', [])
.factory('BlockFactory',function($http,ApiUrlMesas){
	return {
		getAllBlock: function(vDate){
				return $http.get(ApiUrlMesas+"/blocks/tables?"+vDate); 
		},
		getBlock: function(vDate){
				return $http.get(ApiUrlMesas+"/blocks/"+vDate); 
		},
		addNewBlock: function(data){

				return $http({url:ApiUrlMesas+"/blocks", method: "POST", data: data}).then(function successCallback(response) {
						    return response;
						  }, function errorCallback(response) {
						  	return response;
						  });

		},
		deleteBlock: function(id_block){
				return $http({url:ApiUrlMesas+"/blocks/"+id_block, method: "DELETE"}).then(function successCallback(response) {
						    return response;
						  }, function errorCallback(response) {
						  	return response;
						  });

		},
		editBlock: function(variablesUrl, data){
				return $http({url: ApiUrlMesas + "/blocks" + variablesUrl, method: "PUT", data: data}); 
		},
		coverList: function (){
			return {
	            dataMin : [],
	            selectedMin : '',
	            dataMax : [],
	            selectedMax : ''
        	};
		},
		boxTables: function (){
			return {
	            items : true,
	            item : false
        	};
		},
		updateTablesBlocked: function(scope, sce){
			 /* Mensaje */
            var res = scope.mesasBloqueadas.toString().replace(/,/g,", "); 
            scope.someSafeContent = sce.trustAsHtml("<b>" + res + "</b>");
		},
		checkTable: function(scope, sce, index, data){

            /************************************************************************************* 
            Se crea crea el metodo para poder identificar cual es la clase que esta seleccionada  
            **************************************************************************************/
                //Se carga la clase a la mesa para poder mostrar en el sistema
                var zoneSelect = scope.zone;
                angular.forEach(scope.zones, function(value, key) {

                  if(value.id == zoneSelect.id){
                    scope.zones[key].tables[index].class = "selected-table"; // Se carga una clase cuando se selecciona la mesa
                  }

                });
            /*************************************************************************************/
                scope.mesasBloqueadas.push(data.id);
                this.updateTablesBlocked(scope, sce); // Actualizar mensaje

		},uncheckTable: function(scope,sce, index, data){

            /************************************************************************************* 
            Se crea crea el metodo para poder identificar cual es la clase que esta seleccionada  
            **************************************************************************************/
                //Se carga la clase a la mesa para poder mostrar en el sistema
                var zoneSelect = scope.zone;
                angular.forEach(scope.zones, function(value, key) {

                  if(value.id == zoneSelect.id){
                    scope.zones[key].tables[index].class = ""; // Se carga una clase cuando se selecciona la mesa
                  }

                });
            /*************************************************************************************/
            
            var item = scope.mesasBloqueadas.indexOf(data.id);
            
            if(item > -1){
                data.class = "";
                scope.mesasBloqueadas.splice(item, 1);
            }

            this.updateTablesBlocked(scope, sce); // Actualizar mensaje
		},
		selectAllTables: function (scope,sce, loadTablesEdit){
			 
			 angular.forEach(scope.zones, function(zona, key) {
                    angular.forEach(zona.tables, function(mesa, i) {
                        scope.zones[key].tables[i].class = "selected-table";

                         // Se agrega la mesa bloqueada en el array de mesasBloqueadas
                         if(scope.mesasBloqueadas.indexOf(scope.zones[key].tables[i].id) == -1 ){
                             scope.mesasBloqueadas.push(scope.zones[key].tables[i].id);   
                         }
                    });    
            });

            this.updateTablesBlocked(scope, sce); // Actualizar mensaje
            
            var posicion = scope.zones.indexOf(scope.zone);
            if(posicion != -1){
                var item = scope.zones[posicion];
                angular.forEach(scope.zones, function(value, key){
                    if(value.id == item.id){
                        scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                        loadTablesEdit(value.tables);
                    }
                });
            }

		},
		unselectAllTables: function (scope,sce, loadTablesEdit){

			angular.forEach(scope.zones, function(zona, key) {
                    angular.forEach(zona.tables, function(mesa, i) {
                        scope.zones[key].tables[i].class = "";
                        scope.mesasBloqueadas = []; // Se remuven todas las mesas bloqueadas  
                    });    
            });

            this.updateTablesBlocked(scope, sce); // Actualizar mensaje
            
            var posicion = scope.zones.indexOf(scope.zone);
            if(posicion != -1){
                var item = scope.zones[posicion];
                angular.forEach(scope.zones, function(value, key){
                    if(value.id == item.id){
                        scope.itemTables = []; // Variable donde se cargan las mesas a mostrar
                        loadTablesEdit(value.tables);
                    }
                });
            }

		},
		initItemTables: function (scope, tables, TableFactory){

			angular.forEach(tables,function(data){

                var position = data.config_position.split(",");
                var dataTable = {
                    name : data.name,
                    class : data.class,
                    classBloqueado : data.classBloqueado,
                    minCover : data.min_cover,
                    maxCover : data.max_cover,
                    left : position[0],
                    top : position[1],
                    shape : TableFactory.getLabelShape(data.config_forme),
                    size : TableFactory.getLabelSize(data.config_size),
                    rotate : data.config_rotation,
                    id : data.id,
                    status : data.status
                }
                console.log(dataTable);
                if(data.status == 1){
                    scope.itemTables.push(dataTable);
                }else{
                    scope.itemTablesDeleted.push(dataTable);
                }

            });

		}	

	};

})
.factory("blockHelper", ["BlockFactory", "reservationScreenHelper", function(BlockFactory, screenHelper){
    var loadTable = function(zones) {
        var itemZones = [];
        itemZones = zones;
//
//        angular.forEach(zones, function(zone) {
//            var item = {};
//            var tables = [];
//            angular.forEach(zone.tables, function(data) {
//                var position = data.config_position.split(",");
//                var left = (parseInt(position[0])  / screenHelper.minSize() ) * 100 + "%";
//                var top = (parseInt(position[1]) / screenHelper.minSize()) * 100 + "%";
//                var size = TableFactory.getLabelSize(data.config_size) + "-relative";
//                var dataTable = {
//                    name: data.name,
//                    minCover: data.min_cover,
//                    maxCover: data.max_cover,
//                    left: left,
//                    top: top,
//                    shape: TableFactory.getLabelShape(data.config_forme),
//                    size: size,
//                    rotate: data.config_rotation,
//                    id: data.id,
//                    status: data.status,
//                    suggested: false
//                };
//
//                if (data.status == 1) {
//                    tables.push(dataTable);
//                }
//            });
//            item.name = zone.name;
//            item.tables = tables;
//            itemZones.push(item);
//        });
//
        return itemZones;
    };
    
    return {
        loadTable: loadTable
    };
}]);
angular.module('book.app', ['book.controller', 'book.service', 'book.directive'])
	.config(function($stateProvider, $urlRouterProvider) {
		$stateProvider
			.state('mesas.book', {
				url: '/book',
				templateUrl: '/js/app/tables/book/view/index.html'
			});
		/*
		.state ('block', {
			url: '/block/:fecha',
			templateUrl: '/js/app/tables/book/view/block.html'
		})
		*/

	});
angular.module('book.controller', [])

.controller('BookCtrl', function($scope,BookFactory,BookDateFactory,TurnFactory,$uibModal) {

	$scope.formats = ['dd-MMMM-yyyy', 'yyyy/MM/dd', 'dd.MM.yyyy', 'shortDate'];

	$scope.book = { 
		time : '',
		date : BookDateFactory.getDate("es-ES", {weekday: "long", year: "numeric", month: "short",day: "numeric"})
	};

	$scope.calendarBtn = {
		dateText : BookDateFactory.getDate("es-ES", {weekday: "long", month: "short",day: "numeric"}),
		dateNumber : BookDateFactory.getDate("es-ES", {}),
		dateOptions : {formatYear: 'yy',startingDay: 1},
		dateFormat :  $scope.formats[0],
		dateCalendar : new Date(),
		clickArrow : null
	};

	$scope.timeAvailability = [];

	//Paginador Guest

	$scope.searchGuest = {
		totalItems : [1,2,3,4,5,6],
		//selected : 1,
		moreGuest : [],
		moreGuestSelected : '+'
	};

	$scope.$watch("calendarBtn.dateCalendar", function(newValue, oldValue) {

    	if($scope.calendarBtn.clickArrow == false){

    		var date = BookDateFactory.getDate("es-ES", {},$scope.calendarBtn.dateCalendar);

    		$scope.calendarBtn.dateText = BookDateFactory.getDate("es-ES", {weekday: "long", month: "short",day: "numeric"},date);
    		$scope.calendarBtn.dateNumber = date;

    		date = BookDateFactory.changeformatDate(date);

    		$scope.book.date = BookDateFactory.getDate("es-ES", {weekday: "long", year: "numeric", month: "short",day: "numeric"},date);
    		getTimeAvailability(date);
    	}

    	$scope.calendarBtn.clickArrow  = false;
	});

	$scope.setDate = function(option){
	
		var date = BookDateFactory.setDate($scope.calendarBtn.dateNumber,option);

		$scope.calendarBtn.dateText = BookDateFactory.getDate("es-ES", {weekday: "long", month: "short",day: "numeric"},date);
		$scope.calendarBtn.dateNumber = date;
        
        date = BookDateFactory.changeformatDate(date);
		$scope.calendarBtn.dateCalendar = date;

		$scope.calendarBtn.clickArrow = true;

		$scope.book.date = BookDateFactory.getDate("es-ES", {weekday: "long", year: "numeric", month: "short",day: "numeric"},date);

		getTimeAvailability(date);
	};

	$scope.openCalendar = function($event, opened) {
		$event.preventDefault();
		$event.stopPropagation();
		$scope[opened] = true;
	};

	$scope.newReservation = function(time){
		console.log("newReservation " + time);

		$scope.book.time = time;

		var modalNewReservation = $uibModal.open({
			animation: true,
			templateUrl: 'modalNewReservation.html',
			size: '',
			controller : 'modalNewReservationCtrl',
			resolve: {
				book : function(){
					return $scope.book;
				}
			}
		});
	};

	$scope.selectGuest = function(id,index,option){

		angular.element(".search-guest li").removeClass("active");
		
		if(option == "more"){
			$scope.searchGuest.moreGuestSelected = id;

			angular.element("#btn-more-guest").addClass("btn-info");

			angular.element(".guest-list li").removeClass("active");
			angular.element(".guest-list li").eq(index).addClass("active");

		}else{
			$scope.searchGuest.moreGuestSelected = '+';

			angular.element("#btn-more-guest").removeClass("btn-info");
			angular.element(".search-guest li").eq(index).addClass("active");
		}
	};

	var getTimeAvailability = function(vDate){

		TurnFactory.getTurnsAvailables(vDate).success(function(data,status){

			var times = [];
			var timesFinal = [];

			angular.forEach(data["data"], function(turn, key){
				times.push(BookDateFactory.rangeDateAvailable(15,turn));
			});

			angular.forEach(times, function(data, key){
				angular.forEach(data, function(value, key){
					var jsonValue = angular.toJson(timesFinal);
					
					if(jsonValue.indexOf(value.time) == -1){
						timesFinal.push(value);
					}
					
				});
			});

			$scope.timeAvailability = timesFinal;

		}).error(function(data,status,headers){

			messageAlert("Error",status,"warning");
			
		});
	};

	var listMoreGuest = function(){
		for (var i = 8; i <=20; i++) {
			var data = {
				label : i+" Guest",
				id : i
			}

			$scope.searchGuest.moreGuest.push(data);
		}
	};

	listMoreGuest();
	getTimeAvailability(BookDateFactory.changeformatDate($scope.calendarBtn.dateNumber));

})

.controller('modalNewReservationCtrl', function($scope,book,$uibModalInstance) {

	$scope.book = book;

   	$scope.create = function () {
   		$uibModalInstance.close();
   	};

   	$scope.moreDetails = function(){
   		$uibModalInstance.dismiss('cancel');
   	};
});
angular.module('book.directive', [])

angular.module('book.service', [])
.factory('BookFactory',function($http,ApiUrlMesas){
	return {
		getBooks: function(vDate){
			// return $http.get(ApiUrlMesas+"/book/"+vDate); 
		}
	};

})
.factory('BlockFactory',function($http,ApiUrlMesas){
	return {
		getAllBlock: function(vDate){
				return $http.get(ApiUrlMesas+"/blocks?"+vDate); 
		}
	};

})
.factory('BookDateFactory',function(){
	return {
		rangeDateAvailable: function(minSteep,turn){

			var iniHour = turn.hours_ini.split(":");
			var iniMin = turn.hours_ini.split(":");

			var endHour = turn.hours_end.split(":");
			var endMin = turn.hours_end.split(":");

			endHour = parseInt(endHour[0]);
			endMin = parseInt(endMin[1]);

			var hour = parseInt(iniHour[0]);
			var min = parseInt(iniMin[1]);

			var time = [];
	
			while(hour <= endHour){

				var sHorario = (hour <=12) ? "AM":"PM";

				var hora = hour +":"+ ((min == 0) ? "00" : min) + " " + sHorario
				time.push(hora);
				
				if(min == (60 - minSteep) ){
					hour += 1;
					min = 0;
				}else{
					if(hour == endHour && min == endMin){
						hour = 45;
					}
					min += minSteep;	
				}
					
			}

			return time;
		},
		getDate : function(language,options,date = null){
		 	var me = this;

		 	if(date != null){
		 		date = me.changeformatDate(date.toString());
		 		return new Date(date).toLocaleDateString(language, options);
		 	}else{
		 		return new Date().toLocaleDateString(language, options);
		 	}	
		},
		setDate : function (date,option){

			var me = this;

			var date = me.changeformatDate(date);

			var d = new Date(date);

			if(option == "+"){
				d.setDate(d.getDate() +  1);
			}else{
				d.setDate(d.getDate() -  1);
			}

			var dateFinal = me.getDate("es-ES",{},d);

			return dateFinal;
		},
		changeformatDate : function(date){

			var d = date.split("/");
			var dateFormat = d[2]+"-"+d[1] +"-"+d[0];

			return dateFormat;
		}

	};

})

;
/**
 * Created by BS on 25/08/2016.
 */

angular.module('calendar.app', ['calendar.controller', 'calendar.service'])

.config(function($stateProvider) {
	$stateProvider
		.state('mesas.calendar', {
			url: '/calendar',
			templateUrl: '/js/app/tables/calendar/view/index.html',
			controller: 'CalendarIndexController',
			controllerAs: 'vm'
		});
});
/**
 * Created by BS on 25/08/2016.
 */

angular.module('calendar.controller', [])
    .controller('CalendarIndexController', function(CalendarService, MenuConfigFactory, $uibModal, $scope, $compile) {
        var vm = this;
        var now;

        function GetEvents() {
            var month = vm.calendar.fullCalendar('getDate').format('YYYY-MM');
            vm.loading = true;
            CalendarService.GetShiftsByMonth(month, {
                OnSuccess: function(Response) {
                    vm.events = Response.data.data;
                    updateCalendar();
                    vm.loading = false;
                },
                OnError: function(Response) {
                    vm.loading = false;
                }
            });
        }

        function updateCalendar() {
            vm.calendar.fullCalendar('removeEvents');
            vm.calendar.fullCalendar('addEventSource', vm.events);
        }

        function initCalendar() {
            vm.calendar = angular.element('#calendar');

            vm.calendar.fullCalendar({
                header: {
                    right: '',
                    center: 'prev, title, next',
                    left: 'today'
                },
                buttonText: {
                    today: "Hoy"
                },
                locale: 'es',
                theme: true,
                selectable: true,
                selectHelper: true,
                events: vm.events,
                eventOrder: 'start_time',
                eventClick: function(calEvent, jsEvent, view) {
                    OpenDay(calEvent.date);
                },
                dayClick: function(date, jsEvent, view) {
                    var $date = date.format('YYYY-MM-DD');
                    OpenDay($date);
                },
                viewRender: function(view, element) {
                    GetEvents();
                },
                eventRender: function(event, element) {
                    if (CalendarService.isBefore(event.date, now)) {
                        $(element).addClass('event-disabled');
                    }

                    var $text = '<div class="fc-content" >';
                    $text += '<h5 class="text-center" style="color:white;margin: 2px;white-space: pre-line">' + event.title + '</h5>';
                    $text += '<div class="fc-title text-center">' + CalendarService.FormatTime(event.date, event.start_time) + ' - ' + CalendarService.FormatTime(event.date, event.end_time) + '</div>';
                    $text += '</div>';
                    element.html($text);
                }
            });

            var loadingBoxElement = angular.element('<loading-box wait="vm.loading" time="5000" size="xxl"></loading-box>');
            var loadingBox = $compile(loadingBoxElement)($scope);
            var content = vm.calendar.contents().get(1);
            angular.element(content).addClass("pos-r");
            angular.element(content).append(loadingBox);
        }

        function OpenDay($date) {
            if (CalendarService.isBefore($date, now)) {
                return false;
            }

            var modalInstance = $uibModal.open({
                templateUrl: 'addEvent.html',
                controller: 'DayShiftController',
                controllerAs: 'vm',
                backdrop: 'static',
                keyboard: false,
                resolve: {
                    data: function() {
                        return {
                            date: $date,
                            GetEvents: function() {
                                GetEvents();
                            }
                        };
                    }
                }
            });
        }

        function DateNow() {
            now = moment();
            now.set({
                'hour': 0,
                'minute': 0,
                'second': 0,
                'millisecond': 0
            });
        }

        function init() {
            DateNow();
            initCalendar();
            MenuConfigFactory.menuActive(2);
        }

        init();

    })

.controller('DayShiftController', function(data, $uibModalInstance, CalendarService, $uibModal, $state) {
    var vm = this;
    vm.date = data.date;
    vm.flags = {
        isLoading: false
    };

    vm.shifts = [];

    vm.dismiss = function() {
        $uibModalInstance.dismiss();
    };

    vm.AddSchedule = function(type_shift_id, $name) {
        openDialogShedule(type_shift_id, $name);
    };

    vm.moduleEdit = function(turn) {
        $state.go('turn-edit', {
            turn: turn
        });
        vm.dismiss();
    };

    vm.removeSchedule = function(id) {
        swal({
            title: "Confimar",
            text: "Se va eliminar el turno",
            type: "warning",
            showCancelButton: true,
            confirmButtonColor: "#DD6B55",
            confirmButtonText: "Sí, borrar ahora",
            cancelButtonText: "No, cancelar",
            closeOnConfirm: true,
            closeOnCancel: true
        }, function(isConfirm) {
            if (isConfirm) {
                vm.loading = true;
                CalendarService.DeleteShift(id, vm.date, {
                    OnSuccess: function(Response) {
                        GetData();
                        data.GetEvents();
                        vm.dismiss();
                        vm.loading = false;
                    },
                    OnError: function(Response) {
                        vm.loading = false;
                        message.apiError(Response);
                    }
                });
            }
        });
    };

    function GetData() {
        vm.loading = true;
        CalendarService.GetShiftByDate(vm.date, {
            OnSuccess: function(Response) {
                vm.shifts = Response.data.data;
                vm.loading = false;
            },
            OnError: function(Response) {
                vm.loading = false;
                message.apiError(Response);
            }
        });
    }

    function openDialogShedule(type_shift_id, $name) {
        vm.flags.isLoading = true;
        CalendarService.GetShiftsByType(type_shift_id, {
            OnSuccess: function(Response) {
                vm.flags.isLoading = false;
                try {
                    var $type_shift = {
                        id: type_shift_id,
                        name: $name
                    };
                    var modalInstance = $uibModal.open({
                        templateUrl: 'schedule.html',
                        controller: 'ScheduleShiftController',
                        controllerAs: 'vm',
                        backdrop: 'static',
                        keyboard: false,
                        resolve: {
                            data: function() {
                                return {
                                    modalInstance: $uibModalInstance,
                                    typeShift: $type_shift,
                                    date: vm.date,
                                    shifts: Response.data.data,
                                    updateShifts: function() {
                                        GetData();
                                        data.GetEvents();
                                    }
                                };
                            }
                        }
                    });
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            },
            OnError: function(Response) {
                vm.flags.isLoading = false;
                try {
                    if (Response.status == 401 || Response.status == 403) {
                        swal("Error", "No tiene permisos para realizar esta acción", "error");
                    } else {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            }
        });
    }

    vm.changeSchedule = function(type_shift_id, $name, turn_id) {
        openDialogChangeShedule(type_shift_id, $name, turn_id);
    };

    function openDialogChangeShedule(type_shift_id, $name, turn_id) {
        vm.flags.isLoading = true;
        CalendarService.GetShiftsByType(type_shift_id, {
            OnSuccess: function(Response) {
                vm.flags.isLoading = false;
                try {
                    var $type_shift = {
                        id: type_shift_id,
                        name: $name
                    };
                    var modalInstance = $uibModal.open({
                        templateUrl: 'changeSchedule.html',
                        controller: 'ScheduleChangeController',
                        controllerAs: 'vm',
                        backdrop: 'static',
                        keyboard: false,
                        resolve: {
                            data: function() {
                                return {
                                    modalInstance: $uibModalInstance,
                                    turn_id: turn_id,
                                    typeShift: $type_shift,
                                    date: vm.date,
                                    shifts: Response.data.data,
                                    updateShifts: function() {
                                        GetData();
                                        data.GetEvents();
                                    }
                                };
                            }
                        }
                    });
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            },
            OnError: function(Response) {
                vm.flags.isLoading = false;
                try {
                    if (Response.status == 401 || Response.status == 403) {
                        swal("Error", "No tiene permisos para realizar esta acción", "error");
                    } else {
                        swal("Error", "Ocurrió un error en el servidor", "error");
                    }
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            }
        });
    }

    function init() {
        var $date = moment(vm.date);

        vm.fulldate = ($date.format("dddd D [de] MMMM [de] YYYY"));

        GetData();
    }

    init();
})

.controller('ScheduleShiftController', function(data, $uibModalInstance, CalendarService) {
    var vm = this;
    vm.typeShift = data.typeShift;
    vm.shifts = data.shifts;
    vm.date = data.date;
    vm.flags = {
        isLoading: false
    };
    var modalInstanceBefore = data.modalInstance;

    vm.dismiss = function() {
        $uibModalInstance.dismiss();
    };

    vm.am_pm = function(time) {
        return CalendarService.FormatTime(vm.date, time);
    };

    vm.schedule = function(shift_id) {
        vm.flags.isLoading = true;
        CalendarService.ScheduleShift(shift_id, vm.date, {
            OnSuccess: function(Response) {
                vm.flags.isLoading = false;
                try {
                    if (Response.data.statuscode == 201) {
                        data.updateShifts();
                        messageAlert('Turno Programado', '', 'success');
                        vm.dismiss();
                        modalInstanceBefore.dismiss();
                    }
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            },
            OnError: function(Response) {
                vm.flags.isLoading = false;
                try {
                    swal("Error", Response.data.error.user_msg, "error");
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            }
        });
    };

    function init() {
        var $moment = moment(vm.date);
        vm.formatted_date = $moment.format('MMMM DD');
        vm.day_name = $moment.format('dddd') + ($moment.day() == 6 || $moment.day() == 0 ? 's' : '');
    }

    init();
})

.controller('ScheduleChangeController', function(data, $uibModalInstance, CalendarService) {
    var vm = this;
    vm.typeShift = data.typeShift;
    vm.date = data.date;
    var turn_id = data.turn_id;
    var modalInstanceBefore = data.modalInstance;

    vm.dismiss = function() {
        $uibModalInstance.dismiss();
    };

    vm.am_pm = function(time) {
        return CalendarService.FormatTime(vm.date, time);
    };

    vm.changeCheduless = function(shift_id) {
        vm.loading = true;
        CalendarService.ChangeSchedule(turn_id, shift_id, vm.date, {
            OnSuccess: function(Response) {
                vm.loading = false;
                try {
                    if (Response.data.statuscode == 201) {
                        data.updateShifts();
                        message.success('Turno Reprogramado');
                        vm.dismiss();
                        modalInstanceBefore.dismiss();
                    }
                } catch (e) {
                    swal("Error", "Ocurrió un error en el servidor", "error");
                }
            },
            OnError: function(Response) {
                vm.loading = false;
                message.apiError(Response);
            }
        });
    };

    function removeShift(shifts) {
        for (var i = shifts.length - 1; i >= 0; i--) {
            if (shifts[i].id == turn_id) {
                shifts.splice(i, 1);
                break;
            }
        }

        return shifts;
    }

    function init() {
        vm.shifts = removeShift(data.shifts);
    }

    init();
});
/**
 * Created by BS on 25/08/2016.
 */

angular.module('calendar.service', [])

    .service('CalendarService', function ($http, ApiUrlMesas) {
        return {
            FormatTime: function (str_date, str_hour) {
                var date_obj = new Date(str_date + " " + str_hour);
                var hour = date_obj.getHours();
                var minute = date_obj.getMinutes();
                var amPM = (hour > 11) ? "pm" : "am";
                if (hour > 12) {
                    hour -= 12;
                } else if (hour == 0) {
                    hour = "12";
                }
                if (minute < 10) {
                    minute = "0" + minute;
                }
                return hour + ":" + minute + amPM;
            },
            isBefore: function(date, now){
                var dateCalendar = moment(date);
                return moment(dateCalendar).isBefore(now);
            },
            GetShiftsByMonth: function ($month, $listener) {
                $http.get(ApiUrlMesas + '/calendar/' + $month, null).then($listener.OnSuccess, $listener.OnError);
            },
            GetShiftByDate: function ($date, $listener) {
                $http.get(ApiUrlMesas + '/calendar/' + $date + '/shifts', null).then($listener.OnSuccess, $listener.OnError);
            },
            GetShiftsByType: function (id, $listener) {
                $http.get(ApiUrlMesas + '/turns?type_turn=' + id, null).then($listener.OnSuccess, $listener.OnError);
                //var $res = {};
                //var $response = [
                //    {id: 1, name: 'Turno D1', hours_ini: '07:00:00', hours_end: '10:00:00'},
                //    {id: 2, name: 'Turno D2', hours_ini: '08:00:00', hours_end: '11:00:00'},
                //    {id: 3, name: 'Turno D3', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 4, name: 'Turno D4', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 5, name: 'Turno D5', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 6, name: 'Turno D6', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 7, name: 'Turno D7', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 8, name: 'Turno D8', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 9, name: 'Turno D9', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 10, name: 'Turno D10', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 11, name: 'Turno D11', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 12, name: 'Turno D12', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 13, name: 'Turno D13', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 14, name: 'Turno D14', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 15, name: 'Turno D15', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 16, name: 'Turno D16', hours_ini: '09:00:00', hours_end: '12:00:00'},
                //    {id: 17, name: 'Turno D17', hours_ini: '09:00:00', hours_end: '12:00:00'}
                //];
                //
                //$res.data = $response;
                //
                //$listener.OnSuccess($res);
            },
            GetTypeShiftById: function (id) {
                var $name = null;
                switch (id) {
                    case 1:
                        $name = 'Desayuno';
                        break;
                    case 2:
                        $name = 'Brunch';
                        break;
                    case 3:
                        $name = 'Almuerzo';
                        break;
                    case 4:
                        $name = 'Cena';
                        break;

                }
                return {
                    id: id,
                    name: $name
                };
            },
            ScheduleShift: function (id, date, $listener) {
                $http.post(ApiUrlMesas + '/calendar', {
                    res_turn_id: id,
                    date: date
                }).then($listener.OnSuccess, $listener.OnError);
                //$listener.OnSuccess({data: {statuscode: 200}, status: 200});
            },

            DeleteShift: function (id, date, $listener) {
                $http.delete(ApiUrlMesas + '/calendar/' + id , { params: {date: date}}).
                then($listener.OnSuccess, $listener.OnError);
            },

            ChangeSchedule: function (turn_id, shift_id, date, $listener) {
                $http.put(ApiUrlMesas + '/calendar/change', {
                    turn_id: turn_id,
                    shift_id: shift_id,
                    date: date
                }).then($listener.OnSuccess, $listener.OnError);
            },
        };
    });

angular.module('floor.app', ['floor.controller', 'floor.service', 'floor.directive', 'floor.filter', 'server.service'])
    .constant("screenSizeFloor", {
        minSize: 675,
        header: 185,
        menu: 400
    })
    .config(function($stateProvider, $urlRouterProvider, $httpProvider) {
        $stateProvider
            .state('mesas.floor', {
                url: '/floor',
                views: {
                    '@': {
                        templateUrl: '/js/app/tables/floor/view/index.html',
                        controller: 'FloorCtrl',
                        controllerAs: 'vm'
                    },
                    'principal@mesas.floor': {
                        templateUrl: '/js/app/tables/floor/view/principal.html',
                    },
                    'tabReservaciones@mesas.floor': {
                        templateUrl: '/js/app/tables/floor/view/tabReservaciones.html',
                    },
                },
            })
            .state('mesas.floor.reservation', {
                url: '/reservation',
                templateUrl: '/js/app/tables/floor/view/reservation.html',
                controller: 'reservationController',
                controllerAs: 'rm'
            })
            .state('mesas.floor.walkin', {
                url: '/walkin',
                templateUrl: '/js/app/tables/floor/view/waitlist.html',
                controller: 'waitlistController',
                controllerAs: 'wm'
            })
            .state('mesas.floor.server', {
                url: '/server',
                templateUrl: '/js/app/tables/floor/view/server.html',
                controller: 'serverController',
                controllerAs: 'sm'
            })
            .state('mesas.floor.server.create', {
                url: '/create',
                views: {
                    'principal@floor': {
                        templateUrl: '/js/app/tables/floor/view/serverCreate.html',
                        controller: 'serverTablesController',
                        controllerAs: 'se'
                    },
                },
            })
            .state('mesas.floor.server.edit', {
                url: '/edit/:server_id',
                views: {
                    'principal@floor': {
                        templateUrl: '/js/app/tables/floor/view/serverEdit.html',
                        controller: 'serverTablesController',
                        controllerAs: 'se'
                    },
                },
            });
    });
angular.module('floor.controller', [])

.controller('FloorCtrl', function($scope, $uibModal, $rootScope, FloorFactory, ServerFactory, $window, screenHelper, screenSizeFloor) {
        var vm = this;
        var fecha_actual = getFechaActual();

        vm.titulo = "Floor";
        vm.colorsSelect = [];
        vm.flagSelectedZone = 0;

        vm.fecha_actual = fecha_actual;

        var getZones = function() {
            FloorFactory.listZonesReservas().then(function success(data) {
                vm.zonas = data;
                //console.log('Formateado: ' + angular.toJson(data, true));
            }, function error(data) {
                messageErrorApi(data, "Error", "warning");
            });
        };
        getZones();

        ServerFactory.getAllTablesFromServer().then(function(response) {
            $rootScope.servers = response.data.data;
            return $rootScope.servers;
        }).then(function(servers) {
            var colors = [];
            /* Se cargan los colores que ya fueron asignados  */
            angular.forEach(servers, function(server, m) {

                colors.push(server.color);

            });
            vm.colorsSelect = uniqueArray(colors); // Se colocan solo los colores ya asigandos a los servidores

        });

        vm.mostrarDetail = function(index, data) {
            modalInstancesDetail(index, data);
        };

        function modalInstancesDetail(index, data) {
            var modalInstance = $uibModal.open({
                templateUrl: 'myModalContentDetail.html',
                controller: 'DetailInstanceCtrl',
                controllerAs: 'vmd',
                size: '',
                resolve: {
                    content: function() {
                        return data;
                    }
                }
            });
        }

        vm.tabSelectedZone = function(value) {
            vm.flagSelectedZone = value;

        };

        vm.handConfiguration = function(obj) {
            var res = vm.numpeople;
            var num = res.substring(3);
            modalInstancesConfiguration(num, obj);
        };

        function modalInstancesConfiguration(num, obj) {
            var modalInstance = $uibModal.open({
                templateUrl: 'modalConfiguration.html',
                controller: 'ConfigurationInstanceCtrl',
                controllerAs: 'vmc',
                size: 'lg',
                resolve: {
                    num: function() {
                        return num;
                    },
                    table: function() {
                        return obj;
                    }
                }
            });
        }

        angular.element($window).bind('resize', function() {
            var size = screenHelper.size(screenSizeFloor);
            vm.size = size;
            vm.fontSize = 14 * vm.size / screenSizeFloor.minSize + "px";
            $scope.$digest();

        });

        (function Init() {
            vm.size = screenHelper.size(screenSizeFloor);
            vm.fontSize = 14 * vm.size / screenSizeFloor.minSize + "px";
        })();

    })
    .controller('ConfigurationInstanceCtrl', function($modalInstance, num, table, OperationFactory) {
        var vmc = this;
        vmc.numpeople = num;
        vmc.resultado = num;
        vmc.table = table;

        //Creando numero de casillas
        var vNumpeople = [];
        for (i = 1; i <= 12; i++) {
            vNumpeople.push({
                num: i
            });
        }
        vmc.colectionNum = vNumpeople;

        //Definiendo valores por defecto
        vmc.flagSelectedNumMen = num;
        vmc.flagSelectedNumWomen = 0;
        vmc.flagSelectedNumChildren = 0;

        vmc.numperson = {
            men: num,
            women: 0,
            children: 0
        };

        vmc.btnSelectedNum = function(value, person) {
            if (person == 'men') {
                vmc.flagSelectedNumMen = value;
                vmc.flagSelectedCountNumMen = 0;
                vmc.numdinamicoMen = 13;
                OperationFactory.setNumPerson(vmc.numperson, person, value);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
            if (person == 'women') {
                vmc.flagSelectedNumWomen = value;
                vmc.flagSelectedCountNumWomen = 0;
                vmc.numdinamicoWomen = 13;
                OperationFactory.setNumPerson(vmc.numperson, person, value);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
            if (person == 'children') {
                vmc.flagSelectedNumChildren = value;
                vmc.flagSelectedCountNumChildren = 0;
                vmc.numdinamicoChildren = 13;
                OperationFactory.setNumPerson(vmc.numperson, person, value);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
        };


        if (num > 12) {
            vmc.numdinamicoMen = num;
            vmc.flagSelectedCountNumMen = num;

            vmc.numdinamicoWomen = 13;
            vmc.flagSelectedCountNumWomen = 0;

            vmc.numdinamicoChildren = 13;
            vmc.flagSelectedCountNumChildren = 0;

        } else {
            vmc.numdinamicoMen = 13;
            vmc.numdinamicoWomen = 13;
            vmc.numdinamicoChildren = 13;
        }

        vmc.sumar = function(person) {
            if (person == 'men') {
                vmc.numdinamicoMen++;
                vmc.flagSelectedCountNumMen = vmc.numdinamicoMen;
                vmc.flagSelectedNumMen = 0;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoMen);
                //console.log('Datos ' + angular.toJson(vmc.numperson));
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }

            if (person == 'women') {
                vmc.numdinamicoWomen++;
                vmc.flagSelectedCountNumWomen = vmc.numdinamicoWomen;
                vmc.flagSelectedNumWomen = 0;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoWomen);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }

            if (person == 'children') {
                vmc.numdinamicoChildren++;
                vmc.flagSelectedCountNumChildren = vmc.numdinamicoChildren;
                vmc.flagSelectedNumChildren = 0;
                OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoChildren);
                vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
            }
        };
        vmc.restar = function(person) {
            if (person == 'men') {
                if (vmc.numdinamicoMen > 13) {
                    vmc.numdinamicoMen--;
                    vmc.flagSelectedCountNumMen = vmc.numdinamicoMen;
                    vmc.flagSelectedNumMen = 0;
                    OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoMen);
                    vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
                }
            }
            if (person == 'women') {
                if (vmc.numdinamicoWomen > 13) {
                    vmc.numdinamicoWomen--;
                    vmc.flagSelectedCountNumWomen = vmc.numdinamicoWomen;
                    vmc.flagSelectedNumWomen = 0;
                    OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoWomen);
                    vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
                }
            }
            if (person == 'children') {
                if (vmc.numdinamicoChildren > 13) {
                    vmc.numdinamicoChildren--;
                    vmc.flagSelectedCountNumChildren = vmc.numdinamicoChildren;
                    vmc.flagSelectedNumChildren = 0;
                    OperationFactory.setNumPerson(vmc.numperson, person, vmc.numdinamicoChildren);
                    vmc.resultado = OperationFactory.getTotalPerson(vmc.numperson);
                }
            }
        };

        vmc.cancel = function() {
            $modalInstance.dismiss('cancel');
        };

    })
    .controller('DetailInstanceCtrl', function($scope, $modalInstance, content, FloorFactory) {
        var vmd = this;
        vmd.itemZona = {
            name_zona: content.name_zona,
            name: content.name
        };

        var getTableReservation = function() {
            FloorFactory.rowTableReservation(content.table_id).then(function success(data) {
                vmd.itemReservations = data;
                //console.log('PopUp: ' + angular.toJson(data, true));
            });
        };
        getTableReservation();

        $scope.cancel = function() {
            $modalInstance.dismiss('cancel');
        };


    })


.controller('reservationController', function(FloorFactory) {
    var rm = this;


    var getlistZonesBloqueosReservas = function() {
        FloorFactory.listZonesBloqueosReservas().then(function success(data) {
            rm.listado = data;
            //console.log('Listado reservaciones Total: ' + angular.toJson(data, true));
        });
    };
    getlistZonesBloqueosReservas();


}).

controller('waitlistController', function($scope) {
    var wm = this;
})

.controller('serverTablesController', function($scope, $stateParams, $rootScope, FloorFactory, ServerFactory) {

    var server_id = $stateParams.server_id;
    var se = this;
    var arrayTables = [];
    se.zonas = [];
    $rootScope.mesasSeleccionadas = []; // Array donde se agregan las mesas seleccionadas

    ServerFactory.getServerSelect(FloorFactory, ServerFactory, server_id).then(function(response) {
        // Entregan las zonas con sus mesas adicionalmente se agregan las clases y bordes de acuerdo a lo elegido por el cliente
        se.zonas = response;

        /* Se agregan insertan en el array de mesasSeleccionadas las mesas que ya han sido elegidas para ese server */
        angular.forEach(se.zonas, function(zonas, i) {
            angular.forEach(zonas.table, function(mesa, m) {
                if (typeof mesa.tableSelectedByServer === "string") {
                    $rootScope.mesasSeleccionadas.push(se.zonas[i].table[m]);
                }
            });
        });

    });

    /* Logica para seleccionar las mesas */
    se.selectTable = function(item) {
        console.log("item:", item);
        var element = angular.element('#el' + item.table_id);
        if (element.hasClass("is-selected") === true) { // Si ya fue seleccionado se remueve la clase

            element.removeClass("is-selected");

            // Se retira el index del array cuando se selecciona 
            var index = $rootScope.mesasSeleccionadas.indexOf(item);
            $rootScope.mesasSeleccionadas.splice(index, 1);

        } else { // Si aun no se selecciona la mesa se agrega la clase
            $rootScope.mesasSeleccionadas.push(item);
            element.addClass("is-selected");
        }

    };

}).controller('serverController', function($scope, $rootScope, $stateParams, $state, ServerFactory, ColorFactory, FloorFactory) {

    var sm = this;
    // Se trae la informacion de las zonas independientemente para poder realizar un trato especial a la variable
    sm.flagServer = false;
    sm.data = [];
    sm.tables = [];
    sm.showForm = false;

    sm.colors = ColorFactory.getColor();

    sm.selectColor = function(color) {

        sm.color = color.colorHexadecimal;
        var position = sm.colors.indexOf(color);
        for (var i = 0; i < sm.colors.length; i++) {
            sm.colors[i].classSelect = "";
        }
        sm.colors[position].classSelect = "is-selected";

    };

    sm.editServer = function(server) {

        sm.flagServer = true;
        sm.showForm = true;
        var position = $rootScope.servers.indexOf(server);
        sm.server = $rootScope.servers[position];
        sm.name = sm.server.name;

        for (var i = 0; i < sm.colors.length; i++) {
            sm.colors[i].classSelect = "";
            if (sm.colors[i].colorHexadecimal === $rootScope.servers[position].color) {
                sm.color = $rootScope.servers[position].color;
                sm.colors[i].classSelect = "is-selected";
            }
        }

    };


    sm.removeTable = function(item) {

        var element = angular.element('#el' + item.table_id);
        var index = $rootScope.mesasSeleccionadas.indexOf(item);
        $rootScope.mesasSeleccionadas.splice(index, 1);
        element.removeClass("is-selected");

    };

    sm.newServer = function(server) {
        console.log(server);

        sm.flagServer = true;
        var position = $rootScope.servers.indexOf(server);
        sm.server = $rootScope.servers[position];
        sm.name = sm.server.name;

        for (var i = 0; i < sm.colors.length; i++) {
            sm.colors[i].classSelect = "";
            if (sm.colors[i].colorHexadecimal === $rootScope.servers[position].color) {
                sm.color = $rootScope.servers[position].color;
                sm.colors[i].classSelect = "is-selected";
            }
        }

    };

    var limpiarData = function() {

        sm.name = "";
        sm.color = "";
        for (var i = 0; i < sm.colors.length; i++) {
            sm.colors[i].classSelect = "";
        }

    };

    sm.saveOrUpdateServer = function() {

        /* Se construye la estructura de las mesas seleccionadas */
        angular.forEach($rootScope.mesasSeleccionadas, function(mesa, i) {
            sm.tables.push({
                id: mesa.table_id
            });
        });



        if (sm.flagServer === false) { // Se Crea un server

            sm.data = {
                name: sm.name,
                color: sm.color,
                tables: sm.tables
            };

            ServerFactory.addServer(sm.data).then(function(response) {
                var mensaje = "";
                if (response.data.response === false) {
                    mensaje = setearJsonError(response.data.jsonError);
                    messageAlert("Warning", mensaje, "warning", 3000);
                } else if (response.data.success === true) {
                    mensaje = response.data.msg;
                    messageAlert("success", mensaje, "success", 3000);
                    $state.go($state.current, {}, {
                        reload: true
                    });
                    $rootScope.servers.push(response.data.data);
                    limpiarData();

                }

            });

        } else if (sm.flagServer === true) { // Se actualiza la data

            sm.data = {
                id: sm.server.id,
                name: sm.name,
                color: sm.color,
                tables: sm.tables
            };

            ServerFactory.updateServer(sm.data, sm.server.id).then(function(response) { // Se actualiza el server

                var mensaje = "";
                if (response.data.response === false) {
                    mensaje = setearJsonError(response.data.jsonError);
                    messageAlert("Warning", mensaje, "warning", 3000);
                } else if (response.data.success === true) {
                    mensaje = response.data.msg;
                    sm.server.name = sm.name;
                    sm.server.color = sm.color;
                    messageAlert("success", mensaje, "success", 3000);
                    $state.go('floor.server.create', {}, {
                        reload: true
                    });
                    sm.flagServer = false;
                    limpiarData();
                } else if (response.data.success === false) {
                    mensaje = response.data.msg;
                    messageAlert("Warning", mensaje, "warning", 3000);
                }

            });

        }

    };

    sm.cancelEditServer = function(server) {
        sm.flagServer = false;
        limpiarData();
        $state.go('floor.server.create', {}, {
            reload: true
        });
    };

    sm.deleteServer = function() {

        ServerFactory.deleteServer(sm.server.id).then(function(response) {
            var mensaje = "";
            if (response.data.response === false) {
                mensaje = setearJsonError(response.data.jsonError);
                messageAlert("Warning", mensaje, "warning", 2000);
            } else if (response.data.success === true) {
                mensaje = response.data.msg;

                /* Se filtra el item y se elimina del array*/
                for (var i = 0; i < $rootScope.servers.length; i++) {
                    if ($rootScope.servers[i].id === sm.server.id) {
                        $rootScope.servers.splice(i, 1);
                    }
                }

                messageAlert("success", mensaje, "success", 1000);

                sm.flagServer = false;
                limpiarData();
                $state.go('floor.server.create', {}, {
                    reload: true
                });
            } else if (response.data.success === false) {
                mensaje = response.data.msg;
                messageAlert("Warning", mensaje, "warning", 2000);
            }
        });

    };

});
angular.module('floor.directive', [])
    .directive('ngDetailTable', function() {

        function makeSelectTable(scope, element, attr) {

            var left = attr.x;
            var top = attr.y;
            var borde = "";
            var color = (attr.color) ? attr.color : 'none';
            if (color == 'none') {
                borde = '';
            } else {
                borde = '2px solid ' + attr.color;
            }

            element.css({
                position: 'absolute',
                cursor: 'pointer',
                top: top + 'px',
                left: left + 'px',
                border: borde,
                none: 'none',
            });

            element.droppable({
                accept: ".listado-column",
                drop: function(event, ui) {
                    //console.log(ui.draggable[0].id);
                    scope.$apply(function() {
                        scope.num = ui.draggable[0].id;
                    });
                    scope.onDroppedFn();
                }
            });

            element.on('click', function(event) {
                event.preventDefault();
                scope.onClickFn();
            });
        }

        return {
            link: makeSelectTable,
            scope: {
                num: "=",
                onClickFn: '&',
                onDroppedFn: '&'
            }
        };

    }).directive('ngTable', function() {

        function tableSelected(scope, element, attr) {

            var left = attr.x;
            var top = attr.y;

            element.css({
                position: 'absolute',
                cursor: 'pointer',
                top: top + 'px',
                left: left + 'px',
                border: '2px solid ' + attr.color,
                none: 'none',
            });


            element.on('click', function(event) {

                event.preventDefault();
                scope.onClickFn();

            });
        }

        return {
            link: tableSelected,
            scope: {
                onClickFn: '&'
            }
        };

    })
    .directive('ngDragNumPeople', function() {

        function makeDraggable(scope, element, attr) {
            element.draggable({
                helper: "clone",
                drag: function(event, ui) {
                    //console.log(ui.position.left);
                },
                start: function(event, ui) {
                    angular.element('#bg-window-floor').addClass('drag-dispel');
                },
                stop: function(event, ui) {
                    angular.element('#bg-window-floor').removeClass('drag-dispel');
                }
            });
        }

        return {
            link: makeDraggable,
        };

    });
angular.module('floor.filter', [])
	.filter("statusReservation", function() {
		return function(valor) {
			if (valor !== null) {
				var name_status = "";
				switch (valor) {
					case 1:
						name_status = "not-confirmed";
						break;
					case 2:
						name_status = "confirmed";
						break;
					case 3:
						name_status = "left-message";
						break;
					case 4:
						name_status = "no-answer";
						break;
					case 5:
						name_status = "wrong-number";
						break;
					case 6:
						name_status = "partially-arrived";
						break;
					case 7:
						name_status = "all-arrived";
						break;
					case 8:
						name_status = "paged";
						break;
					case 9:
						name_status = "running-late";
						break;
					case 10:
						name_status = "finished";
						break;
					case 11:
						name_status = "canceled-guest";
						break;
					case 12:
						name_status = "canceled-restaurant";
						break;
					case 13:
						name_status = "no-show";
						break;
					case 14:
						name_status = "seated";
						break;
					case 15:
						name_status = "partially-seated";
						break;
					case 16:
						name_status = "entree";
						break;
					case 17:
						name_status = "dessert";
						break;
					case 18:
						name_status = "table-cleared";
						break;
					case 19:
						name_status = "appetizer";
						break;
					case 20:
						name_status = "check-dropped";
						break;
					case 21:
						name_status = "check-paid";
						break;
					default:
						name_status = "";
						break;
				}
				return name_status;
			}
		};
	})
	.filter("statusOnlySeated", function() {
		return function(valor) {
			if (valor !== null) {
				var name_status = "";
				switch (valor) {
					case 14:
						name_status = "seated";
						break;
					case 15:
						name_status = "partially-seated";
						break;
					case 16:
						name_status = "entree";
						break;
					case 17:
						name_status = "dessert";
						break;
					case 18:
						name_status = "table-cleared";
						break;
					case 19:
						name_status = "appetizer";
						break;
					case 20:
						name_status = "check-dropped";
						break;
					case 21:
						name_status = "check-paid";
						break;
					default:
						name_status = "";
						break;
				}
				return name_status;
			}
		};
	})
	.filter("statusCondicion", function() {
		return function(items) {
			var salida = [];
			angular.forEach(items, function(item) {
				if (item.res_reservation_status_id !== null) {
					var status = item.res_reservation_status_id;
					switch (status) {
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 9:
							salida.push(item);
							break;
					}

				}
			});
			return salida;
		};
	})
	.filter("statusSeated", function() {
		return function(items) {
			var salida = [];
			angular.forEach(items, function(item) {
				if (item.res_reservation_status_id !== null) {
					var status = item.res_reservation_status_id;
					switch (status) {
						case 14:
						case 15:
						case 16:
						case 17:
						case 18:
						case 19:
						case 20:
						case 21:
							salida.push(item);
							break;
					}

				}
			});
			return salida;
		};
	});
angular.module('floor.service', [])
	.factory('FloorDataFactory', function($http, ApiUrlMesas) {
		return {
			getBloqueos: function() {
				//return $http.get(ApiUrlRoot + "/admin/ms/1/mesas/reservation/getreservas");
				return $http.get(ApiUrlMesas + "/blocks/tables");
			},
			getReservas: function() {
				return $http.get(ApiUrlMesas + "/reservations");
			},

		};
	})

.factory('FloorFactory', function($q, ZoneFactory, TableFactory, FloorDataFactory, ServerFactory) {
		return {
			listTableServes: function() {
				var defered = $q.defer();
				ServerFactory.getAllTablesFromServer().success(function(data) {
					var vTables = [];
					angular.forEach(data.data, function(server) {
						var tables = server.tables;
						angular.forEach(tables, function(table) {
							var dataTable = {
								server_id: server.id,
								color: server.color,
								table_id: table.id
							};
							vTables.push(dataTable);
						});
					});

					defered.resolve(vTables);
				}).error(function(data, status, headers) {
					defered.reject(data);
				});
				return defered.promise;
			},
			listBloqueos: function() {
				var defered = $q.defer();
				FloorDataFactory.getBloqueos().success(function(data) {
					var vReservation = [];
					angular.forEach(data.data, function(reserva) {
						var dataReservation = {
							table_id: reserva.res_table_id,
							//table_name: reserva.res_table_name,
							block_id: reserva.res_block_id,
							reservation_id: reserva.res_reservation_id,
							num_people: reserva.num_people,
							res_reservation_status_id: reserva.res_reservation_status_id,
							start_date: reserva.start_date,
							start_time: reserva.start_time,
							end_time: reserva.end_time,
							//first_name: reserva.first_name,
							//last_name: reserva.last_name
						};
						vReservation.push(dataReservation);
					});

					defered.resolve(vReservation);
				}).error(function(data, status, headers) {
					defered.reject(data);
				});
				return defered.promise;
			},
			listReservas: function() {
				var defered = $q.defer();
				FloorDataFactory.getReservas().success(function(data) {
					var vReservation = [];
					angular.forEach(data.data, function(reserva) {
						var dataReservation = {
							reservation_id: reserva.id,
							res_reservation_status_id: reserva.res_reservation_status_id,
							first_name: reserva.guest.first_name,
							last_name: reserva.guest.last_name
						};
						vReservation.push(dataReservation);
					});

					defered.resolve(vReservation);
				}).error(function(data, status, headers) {
					defered.reject(data);
				});
				return defered.promise;
			},
			listBloqueosReservas: function() {
				var me = this;
				var defered = $q.defer();
				me.listBloqueos().then(function success(data) {
					return data;
				}, function error(data) {
					return data;
				}).then(function(blocks) {
					me.listReservas().then(function success(response) {
							return response;
						},
						function error(response) {
							return response;
						}).then(function success(reservations) {
							var vReserva = [];
							angular.forEach(blocks, function(block) {
								var itemRes = block.reservation_id;
								//angular.forEach(zone.table, function(table) {
								if (itemRes) {
									angular.forEach(reservations, function(resData, key) {
										//console.log(angular.toJson(tableData, true));
										if (resData.reservation_id == itemRes) {
											//console.log(angular.toJson(key, true));
											block.res_reservation_status_id = resData.res_reservation_status_id;
											block.first_name = resData.first_name;
											block.last_name = resData.last_name;

										}
									});
								}
								vReserva.push(block);
							});

							defered.resolve(vReserva);
						},
						function error(response) {
							defered.reject(response);
						}
					);

				});

				return defered.promise;
			},
			rowTableReservation: function(idTable) {
				var me = this;
				var defered = $q.defer();
				me.listBloqueosReservas().then(function success(reservations) {
					var vTables = [];
					angular.forEach(reservations, function(reservation) {
						if (reservation.table_id === idTable) {
							vTables.push(reservation);
							//console.log(angular.toJson(reservations, true));
						}
					});
					//console.log(angular.toJson(vTables, true));
					//vTables.push(vTable);
					defered.resolve(vTables);
					//return vTables;
				}, function error(data) {
					return data;
				});
				return defered.promise;
			},
			listZonesReservas: function() {
				var me = this;
				var defered = $q.defer();
				ZoneFactory.getZones().success(function(data) {
					return data;
				}).error(function(data) {
					defered.reject(data);
				}).then(function(zonesData) {

					me.listBloqueos().then(function success(response) {
						return response;
					}, function error(response) {
						return response;
					}).then(function success(blocks) {

						me.listTableServes().then(function success(server) {
							return server;
						}, function error(server) {
							return server;
						}).then(function success(servers) {

							var vZones = [];
							angular.forEach(zonesData.data.data, function(zone) {
								var tables = zone.tables;
								var vTables = [];
								angular.forEach(tables, function(table) {
									var position = table.config_position.split(",");
									var dataTable = {
										zone_id: zone.id,
										name_zona: zone.name,
										table_id: table.id,
										name: table.name,
										minCover: table.min_cover,
										maxCover: table.max_cover,
										left: position[0],
										top: position[1],
										shape: TableFactory.getLabelShape(table.config_forme),
										size: TableFactory.getLabelSize(table.config_size),
										rotate: table.config_rotation,
										price: table.price,
									};
									angular.forEach(blocks, function(block) {
										//console.log(blocks);
										if (block.table_id === table.id) {
											dataTable.res_reservation_status_id = block.res_reservation_status_id;
										}
									});
									angular.forEach(servers, function(server) {
										//console.log(blocks);
										if (server.table_id === table.id) {
											dataTable.server_id = server.server_id;
											dataTable.color = server.color;
										}
									});
									vTables.push(dataTable);
								});
								var dataZone = {
									zone_id: zone.id,
									name: zone.name,
									table: vTables,
								};
								vZones.push(dataZone);
							});

							defered.resolve(vZones);

						}, function error(server) {
							defered.reject(server);
						});

					}, function error(response) {
						defered.reject(response);
					});

				});
				return defered.promise;
			},
			listZonesBloqueosReservas: function() {
				var me = this;
				var defered = $q.defer();
				ZoneFactory.getZones().success(function(data) {
					return data;
				}).error(function(data) {
					defered.reject(data);
				}).then(function(zonesData) {

					me.listBloqueosReservas().then(function success(response) {
						return response;
					}, function error(response) {
						return response;
					}).then(function success(blocks) {
							var vTables = [];
							angular.forEach(zonesData.data.data, function(zone) {
								var tables = zone.tables;

								angular.forEach(tables, function(table) {

									angular.forEach(blocks, function(block) {
										//console.log(blocks);
										if (block.table_id === table.id) {
											var dataTable = {
												zone_id: zone.id,
												name_zona: zone.name,
												table_id: table.id,
												name: table.name,
												block_id: block.block_id,
												reservation_id: block.reservation_id,
												num_people: block.num_people,
												res_reservation_status_id: block.res_reservation_status_id,
												start_date: block.start_date,
												start_time: block.start_time,
												end_time: block.end_time,
												first_name: block.first_name,
												last_name: block.last_name,
											};
											vTables.push(dataTable);
										}
									});

								});

							});

							defered.resolve(vTables);

						},
						function error(response) {
							defered.reject(response);
						}
					);

				});
				return defered.promise;
			}
		};

	})
	.factory('OperationFactory', function() {
		return {
			setNumPerson: function(numperson, tipo, value) {
				if (tipo == 'men') {
					numperson.men = value;
				}
				if (tipo == 'women') {
					numperson.women = value;
				}
				if (tipo == 'children') {
					numperson.children = value;
				}
			},
			getTotalPerson: function(numperson) {
				var total = parseInt(numperson.men) + parseInt(numperson.women) + parseInt(numperson.children);
				return total;
			}
		};
	});
angular.module('server.service', [])
    .factory('ServerFactory', function($http, ApiUrlMesas, $q) {
        return {
            getAllTablesFromServer: function() {
                return $http.get(ApiUrlMesas + "/servers");
            },
            addServer: function(data) {
                return $http({
                    url: ApiUrlMesas + "/servers",
                    method: "POST",
                    data: data
                }).then(function successCallback(response) {
                    return response;
                }, function errorCallback(response) {
                    return response;
                });
            },
            updateServer: function(data, id_server) {
                return $http({
                    url: ApiUrlMesas + "/servers/" + id_server,
                    method: "PUT",
                    data: data
                }).then(function successCallback(response) {
                    return response;
                }, function errorCallback(response) {
                    return response;
                });
            },
            deleteServer: function(id_server) {
                return $http({
                    url: ApiUrlMesas + "/servers/" + id_server,
                    method: "DELETE"
                }).then(function successCallback(response) {
                    return response;
                }, function errorCallback(response) {
                    return response;
                });
            },
            getServerSelect: function(FloorFactory, ServerFactory, server_id) {

                var defered = $q.defer();
                var promise = defered.promise;

                var zonas = [];

            FloorFactory.listZonesReservas().then(function(data) { // Lista de zonas y mesas predefinidas del piso del servidor
                    zonas = data;

                    ServerFactory.getAllTablesFromServer().then(function success(response) { // Zonas y mesas seleccionadas por el cliente

                        angular.forEach(response.data.data, function(server, i) {

                            angular.forEach(server.tables, function(table, m) {
                                // La variable contiene el id de la mesa de la BD

                                //IMPRESION DE MESAS 
                                angular.forEach(zonas, function(zona, j) {

                                    angular.forEach(zona.table, function(tablePredefinida, m) {

                                        // Se agregan los bordes de las mesas de acuerdo a los servidores
                                        if (tablePredefinida.table_id == table.id) {
                                            zonas[j].table[m].color = server.color;
                                            if (server.id == server_id) {
                                                zonas[j].table[m].tableSelectedByServer = "is-selected";
                                            }
                                        }
                                    });
                                });

                            });
                        });
                        defered.resolve(zonas);
                    });
                });
                return promise;
            }
        };
    })
    .factory('ColorFactory', function() {
        return {
            getColor: function() {
                return colors = [{
                    colorHexadecimal: "#9F7421"
                }, {
                    colorHexadecimal: "#82d1d3"
                }, {
                    colorHexadecimal: "#7c004c"
                }, {
                    colorHexadecimal: "#e176ce"
                }, {
                    colorHexadecimal: "#7e3c91"
                }, {
                    colorHexadecimal: "#b30011"
                }, {
                    colorHexadecimal: "#1e9084"
                }, {
                    colorHexadecimal: "#ffffe8"
                }, {
                    colorHexadecimal: "#eead00"
                }, {
                    colorHexadecimal: "#ff6138"
                }, {
                    colorHexadecimal: "#007fff"
                }, {
                    colorHexadecimal: "#ffc4b5"
                }, {
                    colorHexadecimal: "#a9d4ff"
                }, {
                    colorHexadecimal: "#30c6bd"
                }, {
                    colorHexadecimal: "#5fefe7"
                }, {
                    colorHexadecimal: "#ffc26b"
                }, {
                    colorHexadecimal: "#00aeef"
                }, {
                    colorHexadecimal: "#cdc3ff"
                }, {
                    colorHexadecimal: "#9be4ff"
                }, {
                    colorHexadecimal: "#aa0d71"
                }, {
                    colorHexadecimal: "#e891d7"
                }, {
                    colorHexadecimal: "#fc00ff"
                }, {
                    colorHexadecimal: "#901eac"
                }, {
                    colorHexadecimal: "#c41200"
                }, {
                    colorHexadecimal: "#ffffff"
                }, {
                    colorHexadecimal: "#2c3e50"
                }, {
                    colorHexadecimal: "#ab7714"
                }, {
                    colorHexadecimal: "#755e33"
                }, {
                    colorHexadecimal: "#83ff5a"
                }, {
                    colorHexadecimal: "#2085d8"
                }];
            },
        };
    });
angular.module('guest.app', ['guest.controller', 'guest.service', 'guest.directive'])
	.config(function($stateProvider, $urlRouterProvider) {
		$stateProvider
			.state('mesas.guest', {
				url: '/config/guest',
				views: {
					'@': {
						templateUrl: '/js/app/tables/guest/view/index.html',
						controller: 'GuestCtrl',
						controllerAs: 'vm'
					}
				},
				resolve: {
					$title: function() {
						return 'Lista de invitados';
					}
				}

			})
			.state('mesas.guest.create', {
				url: '/new',
				templateUrl: '/js/app/tables/guest/view/guest-create.html',
				controller: 'GuestCreateCtrl',
				controllerAs: 'vm',
				resolve: {
					$title: function() {
						return 'Registrar Invitado';
					}
				}
			})
			.state('mesas.guest.view', {
				url: '/:guest',
				templateUrl: '/js/app/tables/guest/view/guest-view.html',
				controller: 'GuestViewCtrl',
				controllerAs: 'vm',
				resolve: {
					$title: function() {
						return 'Perfil invitado';
					}
				}
			})
			.state('mesas.guest.edit', {
				url: '/:guest/edit',
				templateUrl: '/js/app/tables/guest/view/guest-create.html',
				controller: 'GuestCreateCtrl',
				controllerAs: 'vm',
				resolve: {
					$title: function() {
						return 'Editar Invitado';
					}
				}
			});
	});
angular.module('guest.controller', [])
	.controller('GuestCtrl', function(GuestFactory, $state) {

		var vm = this;

		vm.guestList = [];

		vm.init = function() {
			vm.guestAll();
		};

		vm.configScrollBar = optionsScrollBarPLugin('y', 'light', '100%');

		vm.guestAll = function() {
			GuestFactory.guestList().then(function success(response) {

				vm.guestList = response;

				vm.showGuest(vm.guestList);

			}, function error(response) {
				messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
			});
		};

		vm.showGuest = function(guestData) {
			$state.go("mesas.guest.view", {
				'guest': guestData[0].id
			});
		};

		vm.init();

	})
	.controller('GuestViewCtrl', function(GuestFactory, GuestDataFactory, $stateParams) {
		var vm = this;
		var dateNow = convertFechaYYMMDD(new Date(), "es-ES", {});

		vm.guestId = $stateParams.guest;

		vm.guestData = {
			name: '',
			contact: '',
			reservations: {
				resumen: {},
				past: [],
				last: []
			}
		};

		vm.paginationReservation = {
			totalItems: 0,
			currentPage: 1,
			maxSize: 10,
			itemsPage: 1
		};

		vm.init = function() {
			vm.getGuest();

			vm.getReservations({
				page: vm.paginationReservation.currentPage,
				page_size: vm.paginationReservation.itemsPage,
				end_date: dateNow
			}, "past");

			vm.getReservations({
				start_date: dateNow
			}, "last");

			vm.getResumenReservation();
		};

		vm.getGuest = function() {
			if ($stateParams.guest !== undefined) {

				GuestDataFactory.getGuest($stateParams.guest).then(function success(response) {
					var data = response.data.data;
					vm.guestData.name = data.first_name + " " + data.last_name;
					vm.guestData.contact = GuestFactory.parserContactData(data);

				}, function error(response) {
					messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
				});
			}
		};

		vm.getReservations = function(options, type) {

			options = getAsUriParameters(options);

			angular.element("#item-reserva").addClass("hide");

			GuestFactory.reservationsList(vm.guestId, options).then(function success(response) {

				if (type == "last") {
					vm.guestData.reservations.last = response.data;
				} else {
					vm.guestData.reservations.past = response.data;
					vm.paginationReservation.totalItems = response.pagination.total;
				}
				setTimeout(function() {
					angular.element("#item-reserva").removeClass("hide");
				}, 500);

			}, function error(response) {
				messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
			});
		};

		vm.pageReservationChanged = function(page) {
			vm.getReservations({
				page: page,
				page_size: vm.paginationReservation.itemsPage,
				end_date: dateNow
			}, "past");
		};

		vm.getResumenReservation = function() {
			GuestFactory.getResumenReservation(vm.guestId).then(function success(response) {
				console.log(angular.toJson(response, true));
				vm.guestData.reservations.resumen = response;
			}, function error(response) {
				messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
			});
		};

		vm.init();
	})
	.controller('GuestCreateCtrl', function(GuestFactory, GuestDataFactory, $compile, $scope, $state, $stateParams) {
		var vm = this;

		vm.formats = ['dd-MMMM-yyyy', 'yyyy/MM/dd', 'dd.MM.yyyy', 'shortDate'];
		vm.format = vm.formats[1];

		vm.contentTab = {
			active: "datos.html",
			tab1: 'active',
			tab2: ''
		};

		vm.guestData = {
			first_name: '',
			last_name: '',
			birthdate: '',
			gender: '',
			phones: [],
			emails: [],
			tags: []
		};

		vm.guestFormData = {
			gender: '',
			birthdate: ''
		};

		vm.tagsList = [];
		vm.tagsListAdd = [];

		vm.phone = "";
		vm.email = "";

		vm.genderData = null;

		vm.init = function() {
			vm.listGender();

			GuestFactory.getTags().then(function success(response) {
				vm.tagsList = response.tagsList;
				vm.tagsListAdd = response.tagsListAdd;
				vm.loadDataGuestEdit();
			}, function error(response) {
				console.log("getTags error ", angular.toJson(response, true));
			});
		};

		vm.listGender = function() {
			vm.genderData = getGender();
			vm.guestFormData.gender = vm.genderData[0];
		};

		vm.selectTab = function(tabItem) {
			vm.contentTab = GuestFactory.getTabSelected(tabItem);
		};

		vm.validaSaveGuest = function(frmGuest) {
			if (frmGuest.$valid) {
				vm.saveGuest();
			}
		};

		vm.saveGuest = function() {

			console.log("saveGuest " + angular.toJson(vm.guestData, true));

			vm.guestData.birthdate = convertFechaYYMMDD(vm.guestFormData.birthdate, "es-ES", {});
			vm.guestData.gender = vm.guestFormData.gender.id;

			var option = ($stateParams.guest !== undefined) ? "edit" : "create";

			GuestFactory.saveGuest(vm.guestData, option).then(function success(response) {
				$state.reload();
				messageAlert("Success", "Huesped registrado", "success", 0, true);
			}, function error(response) {
				messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
			});
		};

		vm.insertPhone = function() {
			vm.guestData.phones = GuestFactory.insertDataContact(vm.guestData.phones, vm.phone, 'telefono');
			vm.phone = "";
		};

		vm.deletePhone = function(index) {
			vm.guestData.phones.splice(index, 1);
		};

		vm.insertEmail = function() {
			vm.guestData.emails = GuestFactory.insertDataContact(vm.guestData.emails, vm.email, 'email');
			vm.email = "";
		};

		vm.deleteEmail = function(index) {
			vm.guestData.emails.splice(index, 1);
		};

		vm.openCalendar = function($event, opened) {
			$event.preventDefault();
			$event.stopPropagation();
			vm.opened = true;
			console.log("abrir");
		};

		vm.addTag = function(tag, category) {

			var index = GuestFactory.existsTag(vm.tagsListAdd[category].data, tag.id);

			var tagsData = {
				id: tag.id,
				name: tag.name,
				res_guest_tag_category_id: tag.res_guest_tag_gategory_id
			};

			if (index === null) {
				vm.tagsListAdd[category].data.push(tagsData);
				vm.guestData.tags.push({
					id: tagsData.id
				});
			} else {
				vm.tagsListAdd[category].data.splice(index, 1);
				var indexTag = GuestFactory.existsTag(vm.guestData.tags, tag.id);
				vm.guestData.tags.splice(indexTag, 1);
			}
		};

		vm.loadDataGuestEdit = function() {
			if ($stateParams.guest !== undefined) {

				GuestFactory.getGuest($stateParams.guest).then(function success(response) {
					vm.guestData = response.guest;

					vm.guestFormData.birthdate = convertFechaToDate(vm.guestData.birthdate);
					vm.guestFormData.gender = vm.guestData.gender;

					GuestFactory.showTags(response.guest.tags, vm.tagsListAdd);

				}, function error(response) {
					messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
				});
			}
		};

		vm.init();
	});
angular.module('guest.directive', []);
angular.module('guest.service', [])
	.factory('GuestDataFactory', function($http, ApiUrlMesas, ApiUrlRoot) {
		return {
			getAllGuest: function() {
				return $http.get(ApiUrlMesas + "/guests");
			},
			getAllTags: function() {
				return $http.get(ApiUrlMesas + "/guests/tags");
			},
			getGuest: function(idGuest) {
				return $http.get(ApiUrlMesas + "/guests/" + idGuest);
			},
			create: function(vData) {
				return $http.post(ApiUrlMesas + '/guests', vData);
			},
			update: function(vData) {
				return $http.put(ApiUrlMesas + '/guests/' + vData.id, vData);
			},
			getReservations: function(idGuest, options) {
				return $http.get(ApiUrlMesas + "/guests/" + idGuest + "/reservations?" + options);
			}
		};

	})

.factory('GuestFactory', function($http, $q, GuestDataFactory) {
	return {
		guestList: function() {
			var guestAll = [];
			var defered = $q.defer();
			var me = this;

			GuestDataFactory.getAllGuest().success(function(data) {

				data = data.data.data;

				angular.forEach(data, function(value, key) {

					value.contact = me.parserContactData(value);

					guestAll.push(value);
				});

				defered.resolve(guestAll);

			}).error(function(data, status, headers) {
				var response = jsonErrorData(data, status, headers);
				defered.reject(response);
			});

			return defered.promise;
		},
		getTabSelected: function(tabItem) {
			var contentTab = {};
			if (tabItem == 1) {
				contentTab.active = "datos.html";
				contentTab.tab1 = "active";
				contentTab.tab2 = "";

			}

			if (tabItem == 2) {
				contentTab.active = "datos-contact.html";
				contentTab.tab1 = "";
				contentTab.tab2 = "active";
			}

			return contentTab;
		},
		insertDataContact: function(elements, element, type) {

			var jsonData = JSON.stringify(elements);

			if (element !== undefined) {
				console.log(jsonData);
				if (jsonData.indexOf(element) == -1) {
					var data = {
						email: element
					};

					if (type == "telefono") {
						data = {
							number: element
						};
					}

					elements.push(data);
				} else {
					messageAlert("Alerta", "El " + type + " ya ha sido agregado", "info", 0, true);
				}
			} else {
				messageAlert("Alerta", "El " + type + " no es correcto", "info", 0, true);
			}
			return elements;
		},
		existsTag: function(tagList, tag) {
			var index = null;

			angular.forEach(tagList, function(value, key) {
				if (value.id == tag) {
					index = key;
				}
			});

			return index;
		},
		createGuest: function(dataGuest) {
			var defered = $q.defer();

			GuestDataFactory.create(dataGuest).success(function(data) {
				defered.resolve(data);
			}).error(function(data, status, headers) {
				var response = jsonErrorData(data, status, headers);
				defered.reject(response);
			});

			return defered.promise;
		},
		updateGuest: function(dataGuest) {
			var defered = $q.defer();

			GuestDataFactory.update(dataGuest).success(function(data) {
				defered.resolve(data);
			}).error(function(data, status, headers) {
				var response = jsonErrorData(data, status, headers);
				defered.reject(response);
			});

			return defered.promise;
		},
		saveGuest: function(dataGuest, option) {
			var defered = null;
			var me = this;

			if (option == "create") {
				defered = me.createGuest(dataGuest);
			} else {
				defered = me.updateGuest(dataGuest);
			}

			return defered;
		},
		getGuest: function(idGuest) {
			var defered = $q.defer();

			GuestDataFactory.getGuest(idGuest).success(function(data) {
				data = data.data;

				var guestData = {
					guest: {
						id: data.id,
						first_name: data.first_name,
						last_name: data.last_name,
						birthdate: (data.birthdate == "0000-00-00") ? "1970-01-01" : data.birthdate,
						gender: {
							id: data.gender
						},
						phones: [],
						emails: [],
						tags: []
					}
				};

				angular.forEach(data.phones, function(value, key) {
					guestData.guest.phones.push({
						id: value.id,
						number: value.number
					});
				});

				angular.forEach(data.emails, function(value, key) {
					guestData.guest.emails.push({
						id: value.id,
						email: value.email
					});
				});

				angular.forEach(data.tags, function(value, key) {
					guestData.guest.tags.push({
						id: value.id,
						res_guest_tag_gategory_id: value.res_guest_tag_gategory_id,
						name: value.name
					});
				});

				defered.resolve(guestData);

			}).error(function(data, status, headers) {
				var response = jsonErrorData(data, status, headers);
				defered.reject(response);
			});

			return defered.promise;
		},
		showTags: function(guestTags, tagsListGuest) {

			angular.forEach(guestTags, function(value, key) {
				angular.forEach(tagsListGuest, function(data, key) {

					if (data.id == value.res_guest_tag_gategory_id) {

						tagsListGuest[key].data.push({
							id: value.id,
							name: value.name,
							res_guest_tag_category_id: data.id
						});
					}
				});

			});
			return tagsListGuest;
		},
		getTags: function() {
			var defered = $q.defer();
			var tagsList = [];
			var tagsListAdd = [];

			GuestDataFactory.getAllTags().success(function(data) {
				tagsList = data.data;

				angular.forEach(tagsList, function(value, key) {
					tagsListAdd.push({
						id: value.id,
						data: []
					});
				});

				var response = {
					tagsList: tagsList,
					tagsListAdd: tagsListAdd
				};

				defered.resolve(response);

			}).error(function(data, status, headers) {
				defered.reject(data);
			});

			return defered.promise;
		},
		parserContactData: function(value) {
			var contact = "";

			if (value.phones.length === 0 && value.emails.length === 0) {
				contact = "sin telefono / correo";
			} else {

				if (value.phones.length > 0) {
					contact = value.phones[0].number;
				}

				if (value.emails.length > 0) {
					contact = value.emails[0].email;
				}
			}
			return contact;
		},
		reservationsList: function(idGuest, options) {
			var defered = $q.defer();

			GuestDataFactory.getReservations(idGuest, options).success(function(data) {
				var reservData = {
					pagination: {
						last_page: data.last_page,
						next_page_url: data.next_page_url,
						per_page: data.per_page,
						total: data.total
					},
					data: []
				};

				angular.forEach(data.data, function(value, key) {
					value.date_reservation_text = convertTextToDate("es-ES", {
						weekday: "long",
						month: "short",
						day: "numeric"
					}, value.date_reservation);
					value.hours_reservation_text = defineTimeSytem(value.hours_reservation);

					reservData.data.push(value);
				});

				defered.resolve(reservData);
			}).error(function(data, status, headers) {
				var response = jsonErrorData(data, status, headers);
				defered.reject(response);
			});

			return defered.promise;
		},
		getResumenReservation: function(idGuest) {
			var defered = $q.defer();

			GuestDataFactory.getReservations(idGuest, "").success(function(data) {

				var reservData = {
					finished: 0,
					canceled: 0
				};

				angular.forEach(data.data, function(value, key) {

					if (value.res_reservation_status_id == 9 || value.res_reservation_status_id == 10) {
						reservData.canceled += 1;
					}

					if (value.res_reservation_status_id == 12) {
						reservData.finished += 1;
					}

				});

				defered.resolve(reservData);
			}).error(function(data, status, headers) {
				var response = jsonErrorData(data, status, headers);
				defered.reject(response);
			});

			return defered.promise;
		}
	};
})

;
angular.module('reservation.app', ['reservation.controller', 'reservation.service'])
    .constant("screenSize", {
        minSize: 675,
        header: 185,
        menu: 400
    })
    .constant("quantityGuest", 100)
    .config(function($stateProvider) {

        $stateProvider
            .state('mesas.reservation', {
                url: '/reservation',
                templateUrl: '/js/app/tables/reservation/view/index.html',
                controller: "reservationCtrl.Index",
                //controllerAs: 'vm',
            })
            .state('mesas.reservation-new', {
                url: '/reservation/:date/new',
                templateUrl: '/js/app/tables/reservation/view/new.html',
                controller: "reservationCtrl.Store",
                // controllerAs: 'vm',
            });

    });
angular.module('reservation.controller', [])
.controller("reservationCtrl.Index", [function(){
    console.log("=)");
}])
.controller("reservationCtrl.Store", ["$scope", "ZoneLienzoFactory", "$window", "$stateParams", "$timeout",
    "screenHelper", "reservationService", "reservationHelper", "screenSize", 
        function(vm, ZoneLienzoFactory, $window, $stateParams, $timeout, screenHelper, service, helper, screenSize){

    vm.reservation = {};
    vm.tablesSelected = {};
    vm.isTablesSelected = 0;
    vm.conflicts = [];
    vm.zones = [];
    vm.zoneIndex = 0;
    vm.tableSuggested = {};
    var zoneIndexMax = 0;
    var blocks = [];

    vm.guest = {};
    vm.guestList = [];

    vm.testJsonCreate = function() {
        // parse reservation.tables ids
        vm.reservation.tables = [];
        vm.reservation.tables = Object.keys(vm.tablesSelected).reduce(function(result, value) {
                result.push(parseInt(value));
                return result;
            }, []);
        if (vm.reservation.tables.length === 0) {
            if (vm.tableSuggested) {
                vm.reservation.tables.push(vm.tableSuggested.id);
            } else {
                return alert("Debe elegir mesas para la reservacion");
            }
        }
        // end

        //  parse guest
        if (!vm.reservation.guest_id) {
            vm.reservation.guest = vm.newGuest || {};
            delete vm.reservation.guest_id;
        } else {
            delete vm.reservation.guest;
        }
        //  end

        console.log(vm.reservation);
    };

    vm.selectTableAllOrNone = function(indicator) {
        if (indicator == "all") {
            angular.forEach(vm.zones[vm.zoneIndex].tables, function(table) {
                table.selected = true;
            });
        } else if (indicator == "none") {
            angular.forEach(vm.zones[vm.zoneIndex].tables, function(table) {
                table.selected = false;
            });
        }
        listTableSelected();
    };

    var alertConflicts = function() {
        vm.conflicts = [];
        angular.forEach(vm.tablesSelected, function(table, i) {
            var conflict = {};

            if ( vm.reservation.covers < table.minCover ) {
                conflict.name = table.name;
                conflict.desc = "Mesa  demasiado grande";
                vm.conflicts.push(conflict);
            } else if (table.block) {
                conflict.name = table.name;
                conflict.desc = "La mesa se encuentra bloqueada en el rango de duracion de esta reservacion";
                vm.conflicts.push(conflict);
            } else if (table.occupied) {
                conflict.name = table.name;
                conflict.desc = "La mesa ya se encuentra ocupada en el rango de duracion de esta reservacion";
                vm.conflicts.push(conflict);
            }
        });
    };

    var listTableSelected = function() {
        tablesForEach(function(table) {
            if (table.selected) {
                vm.tablesSelected[table.id] = angular.copy(table);
            } else {
                delete vm.tablesSelected[table.id];
            }
        });
        vm.isTablesSelected = Object.keys(vm.tablesSelected).length;

        alertConflicts();
    };

    vm.selectTable = function(table) {
        table.selected = !table.selected;
        listTableSelected();
    };

    vm.tablesBlockValid = function() {
        // console.log("------------------------------------------------");
        var start_time =  moment(vm.reservation.hour, "HH:mm:ss");
        var auxiliar =  moment(vm.reservation.duration, "HH:mm:ss");
        var end_time = start_time.clone().add(auxiliar.hour(), "h").add(auxiliar.minute(), "m");
        // console.log(start_time.format("YYYY-MM-DD HH:mm:ss"), end_time.format("YYYY-MM-DD HH:mm:ss"));
        // console.log(blocks);
        angular.forEach(blocks, function(block){
            var start_block =  moment(block.start_time, "HH:mm:ss");
            var end_block =  moment(block.end_time, "HH:mm:ss");
            // console.log(start_block.format("YYYY-MM-DD HH:mm:ss"), end_time.format("YYYY-MM-DD HH:mm:ss"));
            tablesForEach(function(table) {
                if (table.id == block.res_table_id) {
                    if (block.res_reservation_id !== null) {
                        table.occupied = true;
                        table.suggested = false;
                    } 
                    if ( (start_time.isBetween(start_block, end_block,  null, "()")) || 
                            (end_time.isBetween(start_block, end_block, null, "()")) ||
                                (start_time.isSameOrBefore(start_block) && end_time.isSameOrAfter(end_block))) {
                        table.block = true;
                        table.suggested = false;
                    } else {
                        table.block = false;
                        table.occupied = false;
                    }
                }
            });
        });
        vm.tablesSuggested(vm.reservation.covers);
    };

    vm.tablesSuggested = function(cant){
        vm.tableSuggested = null;
        tablesForEach(function(table) {
            if (cant >= table.minCover && cant <= table.maxCover) {
                if (!table.occupied && !table.block) {
                    if (!vm.tableSuggested) vm.tableSuggested = table;
                    table.suggested = true;
                }
            } else {
                table.suggested = false;
            }
        });
        listTableSelected();
    };

    var tablesForEach = function(callback){
        angular.forEach(vm.zones, function(zone) {
            angular.forEach(zone.tables, function(table) {
                callback(table);
            });
        });
    };

    var listServers = function() {
        service.getServers()
            .then(function(response) {
                vm.servers = response.data.data;
            }).catch(function(error) {
                message.apiError(error);
            });
    };

    var listGuest = function() {
        service.getGuest()
            .then(function(guests) {
                vm.covers = guests;
                vm.reservation.covers = 2;
                vm.tablesSuggested(vm.reservation.covers);
            });
    };

    var listStatuses = function() {
        service.getStatuses()
            .then(function(response) {
                vm.statuses = response.data.data;
                if (vm.statuses.length) vm.reservation.status_id = vm.statuses[0].id;
            }).catch(function(error) {
                message.apiError(error);
            });
    };

    var loadBlocks = function(date) {
        service.getBlocks(date)
            .then(function(response) {
                blocks = response.data.data;
            }).catch(function(error) {
                message.apiError(error);
            }).finally(function(){
                loadTurns(date);
            });
    };

    var loadTurns = function(date) {
        service.getTurns(date)
            .then(function(response) {
                var turns = response.data.data;
                listHours(turns);
                listDurations();
            }).catch(function(error) {
                message.apiError(error);
            }).finally(function() {
                vm.tablesBlockValid();
            });
    };

    var listHours = function(turns) {
        service.getHours(turns)
            .then(function(data) {
                vm.hours = data.hours;
                vm.reservation.hour = data.default;
            }).catch(function(error) {
                message.apiError(error);
            });
    };

    var listDurations = function() {
        service.getDurations()
            .then(function(durations) {
                vm.durations = durations;
                vm.reservation.duration = "01:30:00";
            }).catch(function(error) {
                message.apiError(error);
            });
    };

    var loadZones = function() {
            var date = $stateParams.date;
            var valid = moment(date , 'YYYY-MM-DD', true).isValid();

            if (!valid) {
                return alert("Fecha invalida no se puede cargar las zonas");
            }

            service.getZones(date)
                .then(function(response) {
                    loadTablesEdit(response.data.data.zones);
                }).catch(function(error) {
                    message.apiError(error);
                }).finally(function() {
                    loadBlocks(date);
                    listGuest();
                    listServers();
                    listStatuses();
                });
    };

    var loadTablesEdit = function(dataZones) {
        vm.zones = helper.loadTable(dataZones);
        defaultView();
    };

    var defaultView = function() {
        zoneIndexMax =  vm.zones.length - 1;
        if (zoneIndexMax >= 0) {
            setZoneName(0);
        }
    };

    vm.nextZone = function() {
        if (zoneIndexMax >= 0){
            if (vm.zoneIndex + 1 > zoneIndexMax) {
                vm.zoneIndex = 0;
            } else {
                vm.zoneIndex++;
            }
        }
        setZoneName(vm.zoneIndex);
    };

    vm.prevZone = function() {
        if (zoneIndexMax >= 0){
            if (vm.zoneIndex - 1 >= 0) {
                vm.zoneIndex --;
            } else {
                vm.zoneIndex = zoneIndexMax ;
            }
        }
        setZoneName(vm.zoneIndex);
    };

    var setZoneName = function(i) {
        if(vm.zones.length) vm.zoneName = vm.zones[i].name;
    };


    angular.element($window).bind('resize', function(){
        var size = screenHelper.size(screenSize);
        vm.size = size;
        vm.fontSize = 14 *  size / screenSize.minSize + "px";
        vm.$digest();
    });

    // Search guest list
    var auxiliar;
    vm.searchGuest = function(name) {
        if (auxiliar)$timeout.cancel( auxiliar );
        if (name == "") {
            vm.guestList = [];
            return;
        }
        var search = function() {
            service.getGuestList(name)
                .then(function(response) {
                    vm.guestList = response.data.data.data;
                }).catch(function(error) {
                    message.apiError(error);
                });
        };

        auxiliar = $timeout(search, 500);
    };

    vm.selectGuest = function(guest) {
        vm.reservation.guest_id = guest.id;
        vm.guest = guest;
        vm.addGuest = false;
    };

    vm.removeGuest = function() {
        vm.reservation.guest_id = null;
        vm.newGuest = null;
        vm.guestList = [];
        vm.addGuest = false;
    };

    // End

    (function Init() {
        loadZones();

        vm.size = screenHelper.size(screenSize);
        vm.fontSize = 14 *  vm.size / screenSize.minSize+ "px";
    })();
}]);
angular.module('reservation.service', [])
.factory("reservationService", ["$http", "ApiUrlMesas", "ApiUrlRoot", "quantityGuest", "$q",
     function(http, ApiUrlMesas, ApiUrlRoot, quantityGuest, $q) {
    return {
        getZones: function(date) {
            return http.get(ApiUrlMesas + "/calendar/" + date + "/zones");
        },
        getServers: function() {
            return http.get(ApiUrlMesas + "/servers");
        },
        getStatuses: function() {
            return http.get(ApiUrlRoot + "/reservation/status");
        },
        getTurns: function(date) {
            return http.get(ApiUrlMesas + "/calendar/" + date + "/shifts");
        },
        getBlocks: function(date) {
            return http.get(ApiUrlMesas + "/blocks/tables", {params: {date: date}});
        },
        getGuestList: function(name) {
            return http.get(ApiUrlMesas + "/guests", {params: {name: name, page_size: 8}});
        },
        getGuest: function() {
            var deferred = $q.defer();

            var guests = [];
            guests.push({id:1, name:"1 Invitado"});
            for (var i = 2; i < quantityGuest; i++) {
                guests.push({id: i, name: (i +" Invitados")});
            }
            deferred.resolve(guests);
            return deferred.promise;
        },
        getDurations: function() {
            var deferred = $q.defer();

            var durations = [];

            var date_ini = moment("2000-01-01 00:00:00");

            for (var i = 1; i < 33; i++) {
                date_ini.add(15, "minutes");
                var duration = {};
                duration.time = date_ini.format("HH:mm:ss");

                if (date_ini.hour() > 0) {
                    if (date_ini.minute() === 0) {
                        duration.name = date_ini.format("H[hr]");
                    } else {
                        duration.name = date_ini.format("H[hr] mm[min]");
                    }
                } else {
                    duration.name = date_ini.format("mm[min]");
                }

                durations.push(duration);
            }

            deferred.resolve(durations);
            return deferred.promise;
        },
        getHours: function(turns) {
            var deferred = $q.defer();

            var hours = [];
            var timeDefault  = "";
            var data = {};

            var now = moment().add((15 - (parseInt(moment().format("mm")) % 15)), "minutes").second(0);
            var timeDefaultIsEstablished = false;

            var addHour = function(date_ini, item,minutes) {
                date_ini.add(minutes, "minutes");
                var hour = {};

                hour.turn = item.name;
                hour.time = date_ini.format("HH:mm:ss");
                hour.name = date_ini.format("H:mmA");
                hours.push(hour);

                if (!timeDefaultIsEstablished) {
                    if (date_ini.isAfter(now)) {
                        timeDefault = hour.time;
                        timeDefaultIsEstablished = true;
                    }
                }
            };

            angular.forEach(turns, function(item){
                    if (item.turn !== null) {
                        var date_ini = moment(item.turn.hours_ini, "HH:mm:ss");
                        var date_end = moment(item.turn.hours_end, "HH:mm:ss");
                        addHour(date_ini, item, 0);

                        for (var i = 1; i < 95; i++) {
                                addHour(date_ini, item, 15);
                                if (date_ini.isSame(date_end)) break;
                        }
                    }
            });

            data.hours = hours;
            data.default = timeDefault;
            deferred.resolve(data);
            return deferred.promise;
        }
    };
}])
.factory("reservationHelper", ["TableFactory", "screenSize", function(TableFactory, screenSize){
    var loadTable = function(zones) {
        var itemZones = [];

        angular.forEach(zones, function(zone) {
            var item = {};
            var tables = [];
            angular.forEach(zone.tables, function(data) {
                var position = data.config_position.split(",");
                var left = (parseInt(position[0])  / screenSize.minSize ) * 100 + "%";
                var top = (parseInt(position[1]) / screenSize.minSize ) * 100 + "%";
                var size = TableFactory.getLabelSize(data.config_size) + "-relative";
                var dataTable = {
                    name: data.name,
                    minCover: data.min_cover,
                    maxCover: data.max_cover,
                    left: left,
                    top: top,
                    shape: TableFactory.getLabelShape(data.config_forme),
                    size: size,
                    rotate: data.config_rotation,
                    id: data.id,
                    status: data.status,
                    suggested: false,
                    selected: false,
                    block: false,
                    occupied: false, 
                };

                if (data.status == 1) {
                    tables.push(dataTable);
                }
            });
            item.name = zone.name;
            item.tables = tables;
            itemZones.push(item);
        });

        return itemZones;
    };

    return {
        loadTable: loadTable
    };
}])
.factory("screenHelper", ["$window", function($window) {
    var size = function(screenSize) {

        var width = $window.innerWidth;
        var height = $window.innerHeight;
        var size;
        
        if (width - screenSize.menu >= height){
            height -= screenSize.header;
            if (height  < screenSize.minSize) {
                size =  screenSize.minSize;
            } else {
                size = height ;
            }
        } else if (height - screenSize.header >= width){
            width -= screenSize.menu;
            if (width  < screenSize.minSize) {
                size =  screenSize.minSize;
            } else {
                size = width;
            }
        } else {
            size = screenSize.minSize;
        }

        return size - 30;
    };

    return {
        size: size,
    };
}]);
angular.module('turn.app', ['turn.controller', 'turn.service', 'turn.directive'])
        .config(function($stateProvider, $urlRouterProvider) {
                $stateProvider
                        .state('mesas.turn', {
                                url: '/config/turn',
                                views: {
                                        '@': {
                                                templateUrl: '/js/app/tables/turn/view/index.html',
                                                controller: 'TurnCtrl',
                                        }
                                },
                                resolve: {
                                        $title: function() {
                                                return 'Lista de turnos';
                                        }
                                }
                        })
                        .state('mesas.turn.create', {
                                url: '/new',
                                views: {
                                        '@': {
                                                templateUrl: '/js/app/tables/turn/view/turn-create.html',
                                                controller: 'TurnCreateCtrl',
                                        }
                                },
                                resolve: {
                                        $title: function() {
                                                return 'Crear turno';
                                        }
                                }
                        })
                        .state('mesas.turn.edit', {
                                url: '/:turn/edit',
                                views: {
                                        '@': {
                                                templateUrl: '/js/app/tables/turn/view/turn-edit.html',
                                                controller: 'TurnCreateCtrl',
                                        }
                                },
                                resolve: {
                                        $title: function() {
                                                return 'Editar turno';
                                        }
                                }
                        });

        });
angular.module('turn.controller', ['form.directive', 'localytics.directives'])

.controller('TurnCtrl', function($scope, $stateParams, TurnFactory, MenuConfigFactory) {

		$scope.turns = {};

		var init = function() {
			MenuConfigFactory.menuActive(1);
			getTurns({
				with: "zones|type_turn"
			});
		};

		var getTurns = function(options) {

			options = getAsUriParameters(options);

			TurnFactory.listTurns(options).then(function success(response) {
				$scope.turns = response;
			}, function error(response) {
				messageErrorApi(response.data, "Error", "warning", 0, true, response.status);
			});
		};

		init();
	})
	.controller('TurnCreateCtrl', function($scope, $stateParams, $state, $filter, $uibModal, TurnFactory, TypeTurnFactory,
		DateFactory, MenuConfigFactory, $timeout) {

		$scope.turnData = {
			id: '',
			name: '',
			hours_ini: '',
			hours_end: '',
			res_type_turn_id: '',
			status: 1,
			turn_zone: [],
			days: []
		};

		$scope.dayHide = false;

		$scope.days = [];

		$scope.turnDataClone = {}; //para validar si ha ocurrido algun cambio en la data (editar)

		$scope.turnForm = {
			hours_ini: '',
			hours_end: '',
			type_turn: '',
			saveClick: false, // validamos que no se haga dbClik al guardar
			days: []
		};

		$scope.zonesTable = false; //validar si se oculta la lista de zonas (cuando estamos en mesas)

		$scope.typeTurns = {
			data: ''
		};

		$scope.turnsList = {};

		$scope.turnZoneAdd = {
			zones_id: [],
			zones_data: [],
			zonesTables: [], //van las tablas y sus reglas, zone_id , tables -> rules
			zonesDeleted: [] // las zonas eliminadas
		};

		$scope.zoneSelected = {
			id: '',
			name: '',
			rule: 1,
			tables: [],
			timesDefault: [],
			tablesId: [], //cuando marcamos check en la mesa se agrega
			chkRulesAll: {
				online: true,
				local: true,
				disabled: true
			}
		};

		$scope.mesasCheckAll = false;

		$scope.formDataDefault = {
			hours_ini: [],
			hours_end: [],
			listAvailability: []
		};

		var init = function() {
			$scope.formDataDefault.listAvailability = TurnFactory.initAvailability();

			listHourIni();
			listHourEnd("create");

			loadDataTurnoEdit();
			getTypeTurns();

			if ($stateParams.turn === undefined) {
				$scope.generatedTimeTable(false, "create");
			}

			listDays();
			angular.element("#box-tables div ").addClass("fadeOut");
			MenuConfigFactory.menuActive(1);
		};

		var listDays = function() {
			$scope.days = getDaysWeek();
		};

		var checkedRulesDefault = function(rule) {
			switch (rule) {
				case 0:
					$scope.zoneSelected.chkRulesAll.online = true;
					$scope.zoneSelected.chkRulesAll.disabled = false;
					$scope.zoneSelected.chkRulesAll.local = true;
					break;
				case 1:
					$scope.zoneSelected.chkRulesAll.online = true;
					$scope.zoneSelected.chkRulesAll.disabled = true;
					$scope.zoneSelected.chkRulesAll.local = false;
					break;
				case 2:
					$scope.zoneSelected.chkRulesAll.online = false;
					$scope.zoneSelected.chkRulesAll.disabled = true;
					$scope.zoneSelected.chkRulesAll.local = true;
					break;
				case '-1':
					$scope.zoneSelected.chkRulesAll.online = true;
					$scope.zoneSelected.chkRulesAll.disabled = true;
					$scope.zoneSelected.chkRulesAll.local = true;
					break;
				default:
					$scope.zoneSelected.chkRulesAll.online = true;
					$scope.zoneSelected.chkRulesAll.disabled = true;
					$scope.zoneSelected.chkRulesAll.local = false;
					break;
			}
		};

		var listHourIni = function() {
			$scope.formDataDefault.hours_ini = TurnFactory.listHour(0, 95, $scope.formDataDefault.listAvailability);
			$scope.turnForm.hours_ini = $scope.formDataDefault.hours_ini[64];
		};

		var listHourEnd = function(option) {

			var hourIniIndex = parseInt($scope.turnForm.hours_ini.index) + 1;

			$scope.formDataDefault.hours_end = TurnFactory.listHour(hourIniIndex, 120, $scope.formDataDefault.listAvailability);

			if (option == "create") {
				$scope.turnForm.hours_end = $scope.formDataDefault.hours_end[0];
			}
		};

		var getTypeTurns = function() {
			TypeTurnFactory.getTypeTurns().success(function(data) {

				$scope.typeTurns.data = data.data;
				$scope.turnForm.type_turn = data.data[0];

			}).error(function(data, status, headers) {
				messageErrorApi(data, "Error", "warning");
			});
		};

		var saveTurn = function(option) {

			$scope.turnData = TurnFactory.constructStructureSave($scope.turnData, $scope.turnForm, $scope.turnZoneAdd);

			console.log("saveTurn " + angular.toJson($scope.turnData, true));

			TurnFactory.saveTurn($scope.turnData, option).then(
				function success(response) {
					messageAlert("Success", "Turno registrado", "success");
					$state.reload();
				},
				function error(response) {
					$scope.turnForm.saveClick = false;
					messageErrorApi(response, "Error", "warning");
				}
			);
		};

		var loadDataTurnoEdit = function() {
			if ($stateParams.turn != undefined) {

				var params = "with=turn_zone.zone|turn_zone.rule|turn_zone.zone.tables|turn_zone.zone.turns";

				TurnFactory.getTurn($stateParams.turn, params, $scope.formDataDefault.listAvailability).then(
					function success(data) {

						$scope.turnData = data.turnData;
						$scope.turnForm = data.turnForm;
						$scope.turnDataClone = data.turnDataClone;

						$scope.turnZoneAdd.zones_id = data.zonesId;
						$scope.turnZoneAdd.zones_data = data.dataZones;

						$scope.generatedTimeTable(true, "edit");

						if ($scope.turnData.days.length <= 0) {
							$scope.dayHide = true;
						}

						console.log("turnData " + angular.toJson($scope.turnData, true));
						console.log("turnData " + angular.toJson($scope.turnForm, true));
					},
					function error(data) {
						messageErrorApi(data, "Error", "warning");
					}
				);
			}
		};

		$scope.activeDay = function() {
			if ($scope.dayHide === true) {
				$scope.dayHide = false;
			} else {
				$scope.dayHide = true;
			}
		};

		$scope.checkDay = function(dayId) {
			TurnFactory.checkDay($scope.turnData.days, dayId);
			console.log("checkDay " + angular.toJson($scope.turnData.days, true));
		};

		$scope.generatedTimeTable = function(hourEnd, option) {

			if (hourEnd === true) {
				listHourEnd(option);
			}

			$scope.turnData.hours_ini = $scope.turnForm.hours_ini.time;
			$scope.turnData.hours_end = $scope.turnForm.hours_end.time;

			$scope.zoneSelected.timesDefault = TurnFactory.listHour($scope.turnForm.hours_ini.index, $scope.turnForm.hours_end.index, $scope.formDataDefault.listAvailability);
		};

		$scope.validateSaveTurn = function(option, frmTurn) {

			$scope.turnForm.saveClick = true;

			if (frmTurn.$valid) {
				TurnFactory.validateTurn($scope.turnData, $scope.turnForm, $scope.turnDataClone).then(
					function success(response) {

						$scope.turnForm.saveClick = false;

						if (response === true) {
							messageAlert("Mensaje del sistema", "Ya existe este horario", "info");
						}

						if ($scope.turnZoneAdd.zones_id.length === 0) {
							messageAlert("Mensaje del sistema", "Necesitas asignar minimo una zona", "info");
						}

						if (response === false && $scope.turnZoneAdd.zones_id.length > 0) {
							saveTurn(option);
						}
					},
					function error(response) {
						$scope.turnForm.saveClick = false;
						messageErrorApi(response, "Error", "warning");
					}
				);
			} else {
				messageAlert("Mensaje del sistema", "Faltan datos", "info");
				$scope.turnForm.saveClick = false;
			}
		};

		$scope.showZones = function(option) {
			$uibModal.open({
				animation: true,
				templateUrl: 'myModalZones.html',
				size: 'lg',
				controller: 'ModalTurnZoneCtrl',
				resolve: {
					turnZoneAdd: function() {
						return $scope.turnZoneAdd;
					},
					optionForm: function() {
						return option;
					}
				}
			});
		};

		$scope.returnBoxZones = function() {

			$scope.zonesTable = false;

			TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);

			console.log("returnBoxZones " + angular.toJson($scope.turnZoneAdd, true));

			$scope.zoneSelected.tablesId.length = 0;
			$scope.zoneSelected.rule = 1;
		};

		$scope.deleteZone = function(zone, option) {
			var jsonZone = angular.toJson(zone);
			var zoneRule = (option == "edit" && jsonZone.indexOf("rule") != -1) ? zone.rule.id : "";

			TurnFactory.deleteZone($scope.turnZoneAdd, zone.id, zoneRule, option);
		};

		$scope.showTables = function(zone, option) {
			$scope.zonesTable = true;

			$scope.zoneSelected.id = zone.id;
			$scope.zoneSelected.name = zone.name;

			angular.element("#box-zones .table").addClass("fadeOut");

			$timeout(function() {
				angular.element("#box-zones").css("display", "none");
				angular.element("#box-tables").css("display", "block");
			}, 1000);

			if (option == "edit") {
				$scope.zoneSelected.rule = zone.rule.id;
			}

			TurnFactory.getTurnZoneTables(zone.id, $stateParams.turn, option, $scope.turnZoneAdd, $scope.turnForm, $scope.zoneSelected, $scope.formDataDefault.listAvailability).then(
				function success(response) {

					$scope.zoneSelected.tables = response;

					//console.log("showTables " + angular.toJson($scope.zoneSelected.tables,true));

					var tableRuleId = TurnFactory.getTurnRuleId($scope.turnZoneAdd.zonesTables, zone.id);
					var oneRule = TurnFactory.ruleExitsOne($scope.zoneSelected.tables, tableRuleId, $scope.turnForm);

					tableRuleId = (oneRule == 1) ? tableRuleId : '-1';

					//console.log("tableRuleId -  oneRule " + tableRuleId + " "+ oneRule);

					checkedRulesDefault(tableRuleId);
				},
				function error(response) {
					messageErrorApi(response, "Error", "warning");
				}
			);
		};

		$scope.selectedAllTables = function() {

			TurnFactory.checkAllTableZone($scope.zoneSelected.tablesId, $scope.zoneSelected.tables, $scope.mesasCheckAll);

			console.log("selectedAllTables ", angular.toJson($scope.zoneSelected.tablesId, true));
		};

		$scope.editTableAvailability = function() {
			$uibModal.open({
				animation: true,
				templateUrl: 'myModalTableTime.html',
				size: 'lg',
				controller: 'ModalTableTimeCtrl',
				resolve: {
					timesDefault: function() {
						return $scope.zoneSelected.timesDefault;
					},
					tablesId: function() {
						return $scope.zoneSelected.tablesId;
					},
					tablesData: function() {
						return $scope.zoneSelected.tables;
					},
					turnForm: function() {
						return $scope.turnForm;
					},
					listAvailability: function() {
						return $scope.formDataDefault.listAvailability;
					},
					turnZoneAdd: function() {
						return $scope.turnZoneAdd;
					},
					zoneSelected: function() {
						return $scope.zoneSelected;
					}
				}
			});
		};

		$scope.checkTableZone = function(table) {

			TurnFactory.checkTableZone($scope.zoneSelected.tablesId, table.id);
			TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);
		};

		$scope.checkRuleTableAll = function(rule) {
			$scope.zoneSelected.rule = rule;
			checkedRulesDefault(rule);

			TurnFactory.checkRuleTableAll($scope.zoneSelected.tables, rule, $scope.turnForm);
			TurnFactory.addRulesTable($scope.zoneSelected, $scope.turnZoneAdd);
		};

		init();
	})
	.controller('ModalTableTimeCtrl', function($scope, $uibModalInstance, timesDefault, tablesId,
		tablesData, turnForm, listAvailability, turnZoneAdd, zoneSelected, TurnFactory) {
		$scope.timesTables = [];

		$scope.rules = {};
		$scope.rules.online = [];
		$scope.rules.disabled = [];
		$scope.rules.local = [];
		$scope.rules.value = 1;
		$scope.rules.dataTemp = [];
		$scope.rulesAll = {
			online: false,
			disabled: false,
			local: false
		};

		var tableItem = [];

		var init = function() {
			listTime();
			showRulesTable();
		};

		var listTime = function() {
			$scope.timesTables = timesDefault;
		};

		var getRuleZone = function(option) {

			var zone = TurnFactory.searchZoneByZoneAdd(turnZoneAdd.zonesTables, zoneSelected.id);
			var oneRule = TurnFactory.ruleExitsOne(zoneSelected.tables, zone.res_turn_rule_id, turnForm);

			if (oneRule == 1 || option == 2) {

				switch (zone.res_turn_rule_id) {
					case 0:
						$scope.rulesAll.disabled = true;

						updateCheckRuleAll($scope.rules.local, false);
						updateCheckRuleAll($scope.rules.disabled, true);
						updateCheckRuleAll($scope.rules.online, false);

						break;
					case 1:
						$scope.rulesAll.local = true;

						updateCheckRuleAll($scope.rules.local, true);
						updateCheckRuleAll($scope.rules.disabled, false);
						updateCheckRuleAll($scope.rules.online, false);

						break;
					case 2:
						$scope.rulesAll.online = true;

						updateCheckRuleAll($scope.rules.local, false);
						updateCheckRuleAll($scope.rules.disabled, false);
						updateCheckRuleAll($scope.rules.online, true);

						break;
					default:
						$scope.rulesAll.local = true;

						updateCheckRuleAll($scope.rules.local, true);
						updateCheckRuleAll($scope.rules.disabled, false);
						updateCheckRuleAll($scope.rules.online, false);

						break;
				}

			}
		};

		var setModalRulesTables = function(table, turnForm, ruleId) {

			for (var i = turnForm.hours_ini.index; i <= turnForm.hours_end.index; i++) {

				ruleId = table[0].availability[i].rule_id;

				if (ruleId != null) {
					ruleId = ruleId;
				}

				switch (ruleId) {
					case 0:
						$scope.rules.disabled[i] = true;
						break;
					case 1:
						$scope.rules.local[i] = true;
						break;
					case 2:
						$scope.rules.online[i] = true;
						break;
					default:
						$scope.rules.local[i] = true;
						break;
				}
			}
		};

		var showRulesTable = function() {

			var zoneRuleId = TurnFactory.getTurnRuleId(turnZoneAdd.zonesTables, zoneSelected.id);

			$scope.rules.value = zoneRuleId;

			if (tablesId.length == 1) {

				tableItem.push(TurnFactory.getTableZoneTime(tablesData, tablesId[0]));
				setModalRulesTables(tableItem, turnForm, null);

				getRuleZone(1);

			} else {

				angular.forEach(tablesId, function(value, key) {
					tableItem.push(TurnFactory.getTableZoneTime(tablesData, value));
				});

				getRuleZone(2);
			}
		};

		var updateTableRules = function(rulesTable) {

			angular.forEach(tablesData, function(value, key) {

				angular.forEach(rulesTable, function(table, key) {
					if (table.id == value.id) {
						value = table;
					}
				});
			});

			tablesData = TurnFactory.setAvailabilityText(tablesData, turnForm, listAvailability);

			var zoneData = TurnFactory.searchZoneByZoneAdd(turnZoneAdd.zonesTables, zoneSelected.id);

			if (tablesId.length == tablesData.length) {

				angular.forEach(turnZoneAdd.zonesTables, function(zone, key) {
					if (zone.zone_id == zoneSelected.id) {
						zone.res_turn_rule_id = $scope.rules.value;
					}
				});
			}
		};

		var updateCheckRuleAll = function(rule, value) {
			var hoursIni = turnForm.hours_ini.index;
			var hoursEnd = turnForm.hours_end.index;

			for (var i = hoursIni; i <= hoursEnd; i++) {
				rule[i] = value;
			}
		};

		$scope.checkRuleAll = function(option) {

			switch (option) {
				case "local":

					updateCheckRuleAll($scope.rules.local, true);
					updateCheckRuleAll($scope.rules.disabled, false);
					updateCheckRuleAll($scope.rules.online, false);

					$scope.rules.value = 1;
					break;
				case "disabled":

					updateCheckRuleAll($scope.rules.local, false);
					updateCheckRuleAll($scope.rules.disabled, true);
					updateCheckRuleAll($scope.rules.online, false);

					$scope.rules.value = 0;
					break;
				case "online":

					updateCheckRuleAll($scope.rules.local, false);
					updateCheckRuleAll($scope.rules.disabled, false);
					updateCheckRuleAll($scope.rules.online, true);

					$scope.rules.value = 2;
					break;
			}

			angular.forEach($scope.timesTables, function(value, key) {
				TurnFactory.checkRuleTable(value.index, $scope.rules.value, tableItem, $scope.rules.dataTemp);
			});

			//console.log("checkRule " + angular.toJson($scope.rules.dataTemp, true));
		};

		$scope.checkRule = function(timeIndex, value) {
			TurnFactory.checkRuleTable(timeIndex, value, tableItem, $scope.rules.dataTemp);
			console.log("checkRule " + angular.toJson($scope.rules.dataTemp, true));
		};

		$scope.saveRules = function() {
			var rulesTable = TurnFactory.saveRuleTable(tableItem, $scope.rules.dataTemp);

			updateTableRules(rulesTable);

			$uibModalInstance.close();
		};

		$scope.closeModal = function() {
			$uibModalInstance.dismiss('cancel');
		};

		init();
	})
	.controller('ModalTurnZoneCtrl', function($scope, $uibModalInstance, TurnFactory, turnZoneAdd, optionForm) {

		$scope.cancel = function() {
			$uibModalInstance.dismiss('cancel');
		};

		$scope.zonesList = [];

		var listZones = function() {
			TurnFactory.listZones().then(
				function succes(response) {
					var vZones = [];

					angular.forEach(response, function(value, key) {
						value.checked = false;

						if (turnZoneAdd.zones_id.indexOf(value.id) != -1) {
							value.checked = true;
						}

						vZones.push(value);
					});

					$scope.zonesList = vZones;

				},
				function error(response) {
					messageErrorApi(response, "Error", "warning");
				}
			);
		};

		$scope.assignZone = function(zone) {
			var index = turnZoneAdd.zones_id.indexOf(zone.id);

			if (index == -1) {
				turnZoneAdd.zones_id.push(zone.id);
				turnZoneAdd.zones_data.push(zone);

			} else {
				turnZoneAdd.zones_id.splice(index, 1);
				turnZoneAdd.zones_data.splice(index, 1);
			}

			if (optionForm == "edit") {
				angular.forEach(turnZoneAdd.zonesDeleted, function(value, key) {
					if (value.res_zone_id == zone.id) {
						turnZoneAdd.zonesDeleted.splice(key, 1);
					}
				});
			}
		};

		listZones();
	});
angular.module('turn.directive', []);
angular.module('turn.service', [])

.factory('TurnDataFactory', function($http, ApiUrlMesas, ApiUrlRoot) {
		return {
			getTurns: function(vOptions) {
				return $http.get(ApiUrlMesas + "/turns?" + vOptions);
			},
			getTurn: function(vTurn, vOptions) {
				return $http.get(ApiUrlMesas + "/turns/" + vTurn + "?" + vOptions);
			},
			createTurn: function(vData) {
				return $http.post(ApiUrlMesas + "/turns", vData);
			},
			updateTurn: function(vData) {
				return $http.put(ApiUrlMesas + "/turns/" + vData.id, vData);
			},
			getTurnsAvailables: function(vDate) {
				return $http.get(ApiUrlMesas + "/turns/" + vDate + "/availables");
			},
			searchTurn: function(vData) {
				return $http.get(ApiUrlMesas + "/turns/search?" + vData);
			},
			getTurnZoneTables: function(vZone, vTurn) {
				return $http.get(ApiUrlMesas + "/turns/" + vTurn + "/zones/" + vZone + "/tables");
			}
		};
	})
	.factory('TypeTurnFactory', function($http, ApiUrlMesas, ApiUrlRoot) {

		return {
			getTypeTurns: function() {
				return $http.get(ApiUrlRoot + "/type-turns");
			},
			getDaysTypeTurn: function(vTypeTurn) {
				return $http.get(ApiUrlMesas + "/type-turn/" + vTypeTurn + "/days");
			}

		};
	})
	.factory('DateFactory', function($http, $filter) {

		return {
			timeFormat: function(time) {
				return $filter('date')(time, 'HH:mm:ss');
			}
		};
	})
	.factory('TurnFactory', function(TurnDataFactory, DateFactory, ZoneFactory, BookDateFactory, $q) {

		return {
			listTurns: function(options) {
				var defered = $q.defer();

				TurnDataFactory.getTurns(options).success(function(data) {

					var vTurns = [];

					angular.forEach(data.data, function(turns) {
						var vZones = [];

						angular.forEach(turns.zones, function(zones) {
							vZones.push(zones.name);
						});

						turns.zones = vZones.join(", ");

						vTurns.push(turns);

					});

					defered.resolve(vTurns);

				}).error(function(data, status, headers) {
					var response = {
						data: data,
						status: status,
						headers: headers
					};
					defered.reject(response);
				});

				return defered.promise;
			},
			validateTurn: function(turnData, turnForm, turnDataClone) {
				var valTime = {
					hours_ini: DateFactory.timeFormat(turnForm.hours_ini),
					hours_end: DateFactory.timeFormat(turnForm.hours_end),
					type_turn: turnForm.type_turn.id
				};

				var defered = $q.defer();

				var vParams = getAsUriParameters(valTime);

				TurnDataFactory.searchTurn(vParams).success(function(data) {

					if (data.data.length === 0 || (turnDataClone.hours_ini === valTime.hours_ini && turnDataClone.hours_end == valTime.hours_end)) {
						defered.resolve(false);
					} else {
						defered.resolve(true);
					}

				}).error(function(data, status, headers) {
					defered.reject(data);
				});

				return defered.promise;
			},
			listZones: function() {
				var defered = $q.defer();
				var params = "with=turns";

				ZoneFactory.getZones(params).success(function(data) {

					var zones = [];

					angular.forEach(data.data, function(value, key) {
						var turnsData = [];
						angular.forEach(value.turns, function(turns, key) {
							turnsData.push(turns.name);
						});

						value.turns_asign = turnsData.join(", ");
						zones.push(value);
					});

					defered.resolve(zones);

				}).error(function(data, status, headers) {
					defered.reject(data);
				});

				return defered.promise;
			},
			saveTurn: function(turnData, option) {
				var defered = null;
				var me = this;

				if (option == "create") {
					defered = me.createTurn(turnData);
				} else {
					defered = me.editTurn(turnData);
				}

				return defered;
			},
			createTurn: function(turnData) {
				var defered = $q.defer();

				TurnDataFactory.createTurn(turnData).success(function(data) {
					console.log("createTurn " + angular.toJson(data, true));
					defered.resolve(data);
				}).error(function(data, status, headers) {
					defered.reject(data);
				});

				return defered.promise;
			},
			editTurn: function(turnData) {
				var defered = $q.defer();

				TurnDataFactory.updateTurn(turnData).success(function(data) {
					console.log("editTurn " + angular.toJson(data, true));
					defered.resolve(data);
				}).error(function(data, status, headers) {
					defered.reject(data);
				});

				return defered.promise;
			},
			constructStructureSave: function(turnData, turnForm, turnZoneAdd) {
				turnData.hours_ini = turnForm.hours_ini.time_original;
				turnData.hours_end = turnForm.hours_end.time_original;

				turnData.res_type_turn_id = turnForm.type_turn.id;

				var turnZones = [];
				var self = this;

				angular.forEach(turnZoneAdd.zones_id, function(zones, key) {

					var turnRuleId = self.getTurnRuleId(turnZoneAdd.zonesTables, zones);

					if (turnRuleId === null || turnRuleId === "") {
						turnZones.push({
							res_zone_id: zones,
							res_turn_rule_id: 1,
							tables: []
						});
					} else {
						turnZones.push({
							res_zone_id: zones,
							res_turn_rule_id: turnRuleId,
							tables: self.getTablesZoneRules(turnZoneAdd.zonesTables, zones)
						});
					}

				});

				angular.forEach(turnZoneAdd.zonesDeleted, function(zones, key) {
					turnZones.push(zones);
				});

				turnData.turn_zone = turnZones;

				return turnData;
			},
			getTurnRuleId: function(zonesTables, zoneId) {
				var turnRuleId = null;
				angular.forEach(zonesTables, function(value, key) {
					if (value.zone_id == zoneId) {
						turnRuleId = value.res_turn_rule_id;
					}
				});
				return turnRuleId;
			},
			getTablesZoneRules: function(zonesTables, zoneId) {
				var data = {};
				angular.forEach(zonesTables, function(value, key) {
					if (value.zone_id == zoneId) {

						/*angular.forEach(value.tables, function(tables){
							delete tables.rules_disabled;
							delete tables.rules_local;
							delete tables.rules_online;
							delete tables.res_turn_rule_id;
						});*/

						data = value.tables;
					}
				});
				return data;
			},
			deleteZone: function(turnZoneAdd, zoneId, zoneRule, option) {

				var index = turnZoneAdd.zones_id.indexOf(zoneId);

				if (index != -1) {
					turnZoneAdd.zones_id.splice(index, 1);
					turnZoneAdd.zones_data.splice(index, 1);
				}

				angular.forEach(turnZoneAdd.zonesTables, function(zone, key) {
					if (zone.zone_id == zoneId) {
						turnZoneAdd.zonesTables.splice(key, 1);
					}
				});

				if (option == "edit") {

					var vData = {
						res_zone_id: zoneId,
						res_turn_rule_id: zoneRule,
						unlink: true,
						tables: []
					};

					var validaDelete = 0;

					angular.forEach(turnZoneAdd.zonesDeleted, function(zone, key) {
						if (zone.zone_id == zoneId) {
							validaDelete = 1;
						}
					});

					if (validaDelete === 0) {
						turnZoneAdd.zonesDeleted.push(vData);
					}

					console.log("deleteZone " + angular.toJson(turnZoneAdd, true));
				}
			},
			getTurn: function(idTurn, options, listAvailability) {
				var defered = $q.defer();
				var self = this;

				TurnDataFactory.getTurn(idTurn, options).success(function(data) {
					data = data.data;

					var turnData = {
						id: data.id,
						name: data.name,
						hours_ini: data.hours_ini,
						hours_end: data.hours_end,
						days: data.days
					};

					var nextDay = self.getHourNextDay(data.hours_ini, data.hours_end);

					var hour_ini = self.getIndexHour(data.hours_ini);
					var hour_end = self.getIndexHour(data.hours_end, nextDay); //esto pendiente

					var turnForm = {
						hours_ini: {
							index: hour_ini,
							time_original: data.hours_ini,
							time: listAvailability[hour_ini].time
						},
						hours_end: {
							index: hour_end,
							time_original: data.hours_end,
							time: listAvailability[hour_end].time
						},
						type_turn: {
							id: data.res_type_turn_id,
							label: ''
						},
						days: self.activeCheckDays(data.days)
					};

					//turnForm.days[0] = true;
					//self.activeCheckDays(turnForm);

					var turnDataClone = turnData;
					var zonesId = [];
					var dataZones = [];

					angular.forEach(data.turn_zone, function(zones) {
						zonesId.push(zones.zone.id);

						var turnsData = [];

						angular.forEach(zones.zone.turns, function(turns, key) {
							turnsData.push(turns.name);
						});

						zones.zone.turns_asign = turnsData.join(", ");
						zones.zone.rule = zones.rule;
						dataZones.push(zones.zone);
					});

					var responseData = {
						turnData: turnData,
						turnForm: turnForm,
						turnDataClone: turnDataClone,
						zonesId: zonesId,
						dataZones: dataZones
					};

					defered.resolve(responseData);

				}).error(function(data, status, headers) {
					defered.reject(data);
				});

				return defered.promise;
			},
			activeCheckDays: function(days) {
				var daysData = [];

				for (var i = 1; i <= 7; i++) {
					var checked = (days.indexOf(i) != -1) ? true : false;
					daysData.push({
						id: i,
						checked: checked
					});
				}
				return daysData;
			},
			getTurnZoneTables: function(idZone, idTurn, option, turnZoneAdd, turnForm, zoneSelected, listAvailability) {
				var defered = $q.defer();
				var self = this;

				var tablesZoneExists = self.searchZoneByZoneAdd(turnZoneAdd.zonesTables, idZone);

				if (tablesZoneExists !== null) {
					defered.resolve(tablesZoneExists.tables);
				} else {

					self.addRulesTable(zoneSelected, turnZoneAdd);

					if (option == "edit") {
						TurnDataFactory.getTurnZoneTables(idZone, idTurn).success(function(data) {

							var rulesTables = self.setAvailabilityText(data.data, turnForm, listAvailability);
							defered.resolve(rulesTables);

						}).error(function(data, status, headers) {
							defered.reject(data);
						});
					} else {
						ZoneFactory.getTables(idZone).success(function(data) {

							data = self.checkRuleTableAll(data.data, 1, turnForm);
							defered.resolve(data);

						}).error(function(data, status, headers) {
							defered.reject(data);
						});
					}
				}

				return defered.promise;
			},
			setAvailabilityText: function(tables, turnForm, listAvailability) {

				var self = this;

				angular.forEach(tables, function(data, key) {

					var vData = {};
					var rulesData = [];

					for (var i = turnForm.hours_ini.index; i <= turnForm.hours_end.index; i++) {

						var ruleId = self.getAvailabilityRuleId(data.availability, i);
						var ruleIdOld = self.getAvailabilityRuleId(data.availability, i - 1);
						var ruleIdNext = self.getAvailabilityRuleId(data.availability, i + 1);

						if (ruleIdOld != ruleId || i == turnForm.hours_ini.index) {

							vData.hours_ini = listAvailability[i].time;
							vData.hours_end = vData.hours_ini;
							vData.rule_id = ruleId;

						} else if (ruleIdOld == ruleId) {
							vData.hours_end = listAvailability[i].time;
						}

						if (ruleIdNext != ruleId || i == turnForm.hours_end.index) {
							rulesData.push(vData);
							vData = {};
						}
					}

					data = self.setRuleTextTable(data, rulesData);

				});

				return tables;
			},
			setRuleTextTable: function(table, rulesData) {

				var rulesTable = {
					rulesDisabled: [],
					rulesOnline: [],
					rulesLocal: []
				};

				angular.forEach(rulesData, function(rules, key) {

					var vData = rules.hours_ini + " - " + rules.hours_end;

					switch (rules.rule_id) {
						case 0:
							rulesTable.rulesDisabled.push(vData);
							break;
						case 1:
							rulesTable.rulesLocal.push(vData);
							break;
						case 2:
							rulesTable.rulesOnline.push(vData);
							break;
					}

				});

				table.rules_disabled = rulesTable.rulesDisabled.toString();
				table.rules_local = rulesTable.rulesLocal.toString();
				table.rules_online = rulesTable.rulesOnline.toString();

				return table;
			},
			getAvailabilityRuleId: function(availability, index) {
				var ruleId = -1;

				ruleId = availability[index].rule_id;

				return ruleId;
			},
			searchZoneByZoneAdd: function(zonesTablesAdd, idZone) {
				var tablesZone = null;

				angular.forEach(zonesTablesAdd, function(data, key) {
					if (data.zone_id == idZone) {
						tablesZone = data;
						//console.log("searchZoneByZoneAdd " + angular.toJson(data,true));
					}

				});

				return tablesZone;
			},
			getIndexHour: function(value, nextDay = 0) {
				var hourIndex = value.indexOf(":");
				var min = value.substr(hourIndex);

				hourIndex = parseInt(value.substr(0, hourIndex));

				min = min.replace(":", "");
				min = min.replace("AM", "");
				min = min.replace("PM", "");
				min = parseInt(min);

				var index = hourIndex * 4;

				if (min == 15) {
					index += 1;
				} else if (min == 30) {
					index += 2;
				} else if (min == 45) {
					index += 3;
				}

				index = index + 96 * nextDay;
				return index;
			},
			getHourNextDay: function(hoursIni, hoursEnd) {
				var nextDay = 0;
				var xHourIni = hoursIni.split(":");
				var xHourEnd = hoursEnd.split(":");

				if (xHourEnd[0] < xHourIni[0]) {
					nextDay = 1;
				}

				return nextDay;
			},
			checkTableZone: function(tablesId, idTable) {
				var index = tablesId.indexOf(idTable);

				if (index == -1) {
					tablesId.push(idTable);
				} else {
					tablesId.splice(index, 1);
				}
			},
			checkAllTableZone: function(tablesId, tables, option) {

				if (option === true) {
					tablesId.length = 0;
				}

				angular.forEach(tables, function(table, key) {
					var index = tablesId.indexOf(table.id);
					if (index == -1) {
						tablesId.push(table.id);
					} else {
						tablesId.splice(index, 1);
					}
				});
			},
			getTableZoneTime: function(tables, idTable) {
				var data = "";

				angular.forEach(tables, function(table, key) {
					if (table.id == idTable) {
						data = table;
					}
				});

				return data;
			},
			checkRuleTable: function(indexTime, rule, tableItem, rulesDataTemp) {

				var jsonData = angular.toJson(rulesDataTemp);

				if (rulesDataTemp.length === 0 || jsonData.indexOf(indexTime) == -1) {
					rulesDataTemp.push({
						rule_id: rule,
						index_time: indexTime
					});
				} else {
					angular.forEach(rulesDataTemp, function(rules, key) {
						if (rules.index_time == indexTime) {
							rules.rule_id = rule;
						}
					});
				}
			},
			saveRuleTable: function(tableItem, rulesDataTemp) {
				angular.forEach(tableItem, function(table, key) {
					angular.forEach(table.availability, function(rules, key) {
						angular.forEach(rulesDataTemp, function(rulesTemp) {

							if (key == rulesTemp.index_time) {
								rules.rule_id = rulesTemp.rule_id;
								//console.log("saveRuleTable " + angular.toJson(rules,true));
							}

						});

					});
				});

				return tableItem;
			},
			listHour: function(hourIni, hourEnd, availabilityTime) {

				var listTime = [];

				angular.forEach(availabilityTime, function(value, key) {

					if (value.index >= hourIni && value.index <= hourEnd) {
						listTime.push({
							time: value.time,
							time_original: value.time_original,
							index: value.index
						});
					}

				});

				return listTime;
			},
			initAvailability: function() {
				var times = [];

				for (i = 0; i < 120; i++) {
					var time = i * 60 * 15;
					var nextday = (i < 96) ? 0 : 1;

					var time_original = moment.utc(time * 1000).format('HH:mm');

					if (i >= 52 && i < 96) {
						var a = (i - 48) * 60 * 15;
						time = moment.utc(a * 1000).format('HH:mm') + " PM";
					} else if (i < 52) {
						time = moment.utc(time * 1000).format('HH:mm') + " AM";
					} else {
						time = moment.utc(time * 1000).format('HH:mm') + " AM";
					}

					times.push({
						time: time,
						time_original: time_original,
						rule_id: "-1",
						nextday: nextday,
						index: i
					});
				}

				return times;
			},
			checkRuleTableAll: function(tables, rule, turnForm) {
				var self = this;

				angular.forEach(tables, function(data) {

					data = self.updateTextAvailabilityTable(data, rule, turnForm);

					angular.forEach(data.availability, function(rules) {
						rules.rule_id = rule;
					});

				});

				return tables;
			},
			updateTextAvailabilityTable: function(table, rule, turnForm) {

				table.rules_disabled = "";
				table.rules_local = "";
				table.rules_online = "";

				table.res_turn_rule_id = rule;

				switch (rule) {
					case 0:
						table.rules_disabled = turnForm.hours_ini.time + " - " + turnForm.hours_end.time;
						break;
					case 1:
						table.rules_local = turnForm.hours_ini.time + " - " + turnForm.hours_end.time;
						break;
					case 2:
						table.rules_online = turnForm.hours_ini.time + " - " + turnForm.hours_end.time;
						break;
				}

				return table;
			},
			addRulesTable: function(zoneSelected, turnZoneAdd) {
				var vData = {
					zone_id: zoneSelected.id,
					res_turn_rule_id: zoneSelected.rule,
					tables: []
				};

				angular.forEach(zoneSelected.tables, function(value, key) {
					vData.tables.push(value);
				});

				if (turnZoneAdd.zonesTables.length === 0) {
					turnZoneAdd.zonesTables.push(vData);
				} else {

					var existeZone = 0;

					angular.forEach(turnZoneAdd.zonesTables, function(value, key) {
						if (value.zone_id == zoneSelected.id) {
							//value = vData;
							turnZoneAdd.zonesTables.splice(key, 1);
							turnZoneAdd.zonesTables.push(vData);

							existeZone += 1;
						}
					});

					if (existeZone === 0) {
						turnZoneAdd.zonesTables.push(vData);
					}
				}
			},
			ruleExitsOne: function(tables, ruleId, turnForm) {
				var rule = 1;

				angular.forEach(tables, function(table, key) {
					for (var i = turnForm.hours_ini.index; i <= turnForm.hours_end.index; i++) {
						if (table.availability[i].rule_id != ruleId) {
							rule += 1;
						}
					}
				});

				return rule;
			},
			checkDay: function(days, dayId) {
				var index = days.indexOf(dayId);

				if (index == -1) {
					days.push(dayId);
				} else {
					days.splice(index, 1);
				}
			}

		};

	});
angular.module('zone.app', ['zone.controller', 'zone.service', 'zone.directive'])
	.config(function($stateProvider, $urlRouterProvider, $httpProvider) {

		$stateProvider
			.state('mesas.zone', {
				url: '/config/zone',
				views: {
					'@': {
						templateUrl: '/js/app/tables/zone/view/index.html',
						controller: 'ZoneCtrl',
					}

				},
				resolve: {
					$title: function() {
						return 'Lista de zonas';
					}
				}
			})
			.state('mesas.zone.active', {
				url: '/zone-active',
				templateUrl: '/js/app/tables/zone/view/zone-active.html',
				resolve: {
					$title: function() {
						return 'Lista de zonas activas';
					}
				}
			})
			.state('mesas.zone.inactive', {
				url: '/zone-inactive',
				templateUrl: '/js/app/tables/zone/view/zone-inactive.html',
				resolve: {
					$title: function() {
						return 'Lista de zonas inactivas';
					}
				}
			})
			.state('mesas.zone.create', {
				url: '/new',
				views: {
					'@': {
						templateUrl: '/js/app/tables/zone/view/zone-create.html',
						controller: 'ZoneCreateCtrl',
					}

				},
				resolve: {
					$title: function() {
						return 'Crear zona';
					}
				}
			})
			.state('mesas.zone.edit', {
				url: '/:id',
				views: {
					'@': {
						templateUrl: '/js/app/tables/zone/view/zone-edit.html',
						controller: 'ZoneCreateCtrl',
					}

				},
				resolve: {
					$title: function() {
						return 'Editar zona';
					}
				}
			})
			.state('mesas.zone.clone', {
				url: '/:id/clone',
				views: {
					'@': {
						templateUrl: '/js/app/tables/zone/view/zone-clone.html',
						controller: 'ZoneCreateCtrl',
					}

				},
				resolve: {
					$title: function() {
						return 'Clonar zona';
					}
				}
			});

	});
angular.module('zone.controller', ['ngDraggable'])

.controller('ZoneCtrl', function($scope, ZoneFactory, MenuConfigFactory, $uibModal) {

        $scope.zonesActive = {};
        $scope.zonesInactive = {};

        $scope.idZoneDelete = 0;
        $scope.indexRow = 0;

        $scope.zones = {
            numTablesActive: 0,
            numTablesInactive: 0,
            minCoversActive: 0,
            maxCoversActive: 0,
            minCoversInactive: 0,
            maxCoversInactive: 0
        };

        var init = function() {
            $scope.getZones();
            MenuConfigFactory.menuActive(0);
        };

        $scope.getZones = function() {

            ZoneFactory.getZones("with=turns").success(function(data) {

                console.log("zones " + angular.toJson(data, true));

                var vZonesActive = [];
                var vZonesInactive = [];

                angular.forEach(data.data, function(zones) {

                    var zonesTables = getTablesCount(zones);
                    var zonesTurn = zones.turns;

                    console.log("getZones " + angular.toJson(zones.turns, true));

                    if (zones.status == "0" || zones.status == "2" || zonesTurn.length === 0) {
                        $scope.zones.numTablesInactive += zonesTables.tables_count;
                        $scope.zones.minCoversInactive += zonesTables.min_covers;
                        $scope.zones.maxCoversInactive += zonesTables.max_covers;
                        vZonesInactive.push(zonesTables);
                    } else {
                        $scope.zones.numTablesActive += zonesTables.tables_count;
                        $scope.zones.minCoversActive += zonesTables.min_covers;
                        $scope.zones.maxCoversActive += zonesTables.max_covers;
                        vZonesActive.push(zonesTables);
                    }

                });

                $scope.zonesActive = vZonesActive;
                $scope.zonesInactive = vZonesInactive;

            }).error(function(data, status, headers) {

                messageErrorApi(data, "Error", "warning", 0, true, status);
            });
        };

        $scope.deleteZoneConfirm = function(idZone, indexRow) {

            $scope.idZoneDelete = idZone;
            $scope.indexRow = indexRow;

            console.log("indexRow " + indexRow);

            var modalDeleteZone = $uibModal.open({
                animation: true,
                templateUrl: 'myModalDeleteZone.html',
                size: 'lg',
                controller: 'ModalZoneDeleteCtrl',
                resolve: {
                    idZone: function() {
                        return $scope.idZoneDelete;
                    },
                    indexRow: function() {
                        return $scope.indexRow;
                    },
                    zonesInactive: function() {
                        return $scope.zonesInactive;
                    }
                }
            });
        };

        var getTablesCount = function(zones) {
            var vTables = 0;
            var vMinCovers = 0;
            var vMaxCovers = 0;

            angular.forEach(zones.tables, function(tables) {
                if (tables.status == 1) {
                    vTables += 1;
                    vMinCovers += tables.min_cover;
                    vMaxCovers += tables.max_cover;
                }
            });

            zones.tables_count = vTables;
            zones.min_covers = vMinCovers;
            zones.max_covers = vMaxCovers;

            return zones;
        };

        init();
    })
    .controller('ZoneCreateCtrl', function($scope, $state, $stateParams, $document, ZoneFactory, ZoneLienzoFactory, TableFactory,
        $uibModal, IdMicroSitio, MenuConfigFactory) {

        $scope.sizeTableList = {
            data: [{
                id: "1",
                label: "small"
            }, {
                id: "2",
                label: "medium"
            }, {
                id: "3",
                label: "large"
            }],
            selectedOption: {
                id: "1",
                label: "small"
            }
        };

        $scope.coversList = {
            dataMin: [],
            selectedMin: '',
            dataMax: [],
            selectedMax: ''
        };

        $scope.headerZone = {
            tables: 0,
            minCovers: 0,
            maxCovers: 0
        };

        $scope.itemTables = [];
        $scope.itemTablesDeleted = [];

        $scope.boxTables = {
            items: true,
            item: false
        };

        $scope.typeDrag = "";

        $scope.indexTable = null;
        $scope.selectedTable = false; //validar al hacer click en el lienzo

        $scope.typeForm = "create"; // or edit

        $scope.saveClick = false; //valida click en guardar - no doble click

        var init = function() {
            detectedForm();

            listCovers("min");
            listCovers("max");

            MenuConfigFactory.menuActive(0);
        };

        $scope.onDragComplete = function(data, evt, type) {
            $scope.typeDrag = type;
            selectTableTypeDrag(data, type);
        };

        $scope.onDropComplete = function(data, evt) {

            var position = ZoneLienzoFactory.positionTable(evt);

            data.top = position.y;
            data.left = position.x;
            data.rotate_text = "top";
            data.name = $scope.itemTables.length + 1;

            selectTableTypeDrop(data);

            $scope.typeDrag = "";
        };

        $scope.onLienzo = function() {

            if ($scope.indexTable !== null && $scope.selectedTable === false) {
                console.log("onLienzo");
                $scope.activarTablesItems();
            }

            $scope.selectedTable = false;
        };

        $scope.rotateTextTable = function(option) {
            ZoneLienzoFactory.changeRotationText(option, $scope.itemTables[$scope.indexTable], $scope.indexTable);
        };

        $scope.changeShapeTable = function(shape) {

            $scope.itemTables[$scope.indexTable].shape = shape;
            var rotateTable = $scope.itemTables[$scope.indexTable].rotate;

            if (shape == "square" && (rotateTable == 90 || rotateTable == 135)) {
                $scope.itemTables[$scope.indexTable].rotate = 0;
            }

            /*angular.element(".text-rotate .btn-group .shape").removeClass("active");
            angular.element(".shape." + shape + "s").addClass("active");*/
        };

        $scope.changeSizeTable = function() {
            $scope.itemTables[$scope.indexTable].size = $scope.sizeTableList.selectedOption.label;
        };

        $scope.editNameTable = function() {
            var texto = angular.element("#name-table").val();
            ZoneLienzoFactory.changeNameTable($scope.itemTables[$scope.indexTable], $scope.itemTables, texto);
        };

        $scope.tableCapacity = function(option) {

            if (option == "min") {
                $scope.itemTables[$scope.indexTable].minCover = $scope.coversList.selectedMin.id;
            } else {

                $scope.itemTables[$scope.indexTable].maxCover = $scope.coversList.selectedMax.id;
            }

            if ($scope.coversList.selectedMax.id < $scope.coversList.selectedMin.id) {

                $scope.itemTables[$scope.indexTable].minCover = $scope.coversList.selectedMax.id;
                $scope.itemTables[$scope.indexTable].maxCover = $scope.coversList.selectedMax.id;

                getDataTableSelected($scope.indexTable);
            }

            updateHeaderZone();
        };

        $scope.rotateShapeTable = function() {

            console.log("rotateShapeTable ", $scope.itemTables[$scope.indexTable].rotate);

            console.log(angular.toJson($scope.itemTables[$scope.indexTable], true));

            var rotateTable = $scope.itemTables[$scope.indexTable].rotate;
            var shapeTable = $scope.itemTables[$scope.indexTable].shape;

            if (rotateTable == "0") {
                $scope.itemTables[$scope.indexTable].rotate = "45";
            } else {
                if (rotateTable == "45" && shapeTable == "recta") {
                    $scope.itemTables[$scope.indexTable].rotate = "90";
                } else if (rotateTable == "90" && shapeTable == "recta") {
                    $scope.itemTables[$scope.indexTable].rotate = "135";
                } else {
                    $scope.itemTables[$scope.indexTable].rotate = "0";
                }

            }
        };

        $scope.draggableTable = function() {
            console.log("draggableTable prueba");
        };

        $scope.activarTableOptions = function(index, vthis) {

            $scope.selectedTable = true;
            getDataTableSelected(index);

            setTimeout(function() {
                $scope.$apply(function() {

                    if ($scope.boxTables.item === false || ($scope.boxTables.item === true && $scope.selectedTable === true && angular.element('.item-drag-table').hasClass('selected-table') === false)) {

                        $scope.boxTables.item = true;
                        $scope.boxTables.items = false;
                    } else {

                        if (angular.element('.item-drag-table').hasClass('selected-table') === false) {

                            $scope.boxTables.item = false;
                            $scope.boxTables.items = true;
                        }

                    }
                });
            }, 100);
        };

        $scope.doneTableSelected = function() {
            $scope.activarTablesItems();
        };

        var listCovers = function(option) {

            var coverList = "";

            if (option == "min") {
                coverList = $scope.coversList.dataMin;
            } else {
                coverList = $scope.coversList.dataMax;
            }

            for (var i = 1; i <= 30; i++) {
                var data = {
                    label: i + " covers",
                    id: i
                };

                coverList.push(data);
            }

            if (option == "min") {
                $scope.coversList.selectedMin = coverList[0];
            } else {
                $scope.coversList.selectedMax = coverList[0];
            }
        };

        var getDataTableSelected = function(index) {
            $scope.indexTable = index;

            angular.element("#name-table").val($scope.itemTables[index].name);
            $scope.changeShapeTable($scope.itemTables[index].shape);

            $scope.itemTables[index].top = angular.element("#tb-item" + index).css("top").replace("px", "");
            $scope.itemTables[index].left = angular.element("#tb-item" + index).css("left").replace("px", "");

            $scope.coversList.selectedMin = {
                id: $scope.itemTables[$scope.indexTable].minCover,
                label: $scope.itemTables[$scope.indexTable].minCover + " covers"
            };

            $scope.coversList.selectedMax = {
                id: $scope.itemTables[$scope.indexTable].maxCover,
                label: $scope.itemTables[$scope.indexTable].maxCover + " covers"
            };

            $scope.sizeTableList.selectedOption = {
                id: TableFactory.getIdSize($scope.itemTables[index].size),
                label: $scope.itemTables[index].size
            };
        };

        $scope.activarTablesItems = function() {
            ZoneLienzoFactory.activarTablesItems($scope.boxTables);
        };

        $scope.deleteSelectTableItem = function() {

            var modalDeleteTable = $uibModal.open({
                animation: true,
                templateUrl: 'myModalDeleteTable.html',
                size: 'lg',
                controller: 'ModalTableDeteleCtrl',
                resolve: {
                    itemTables: function() {
                        return $scope.itemTables;
                    },
                    itemTablesDeleted: function() {
                        return $scope.itemTablesDeleted;
                    },
                    indexTable: function() {
                        return $scope.indexTable;
                    },
                    boxTables: function() {
                        return $scope.boxTables;
                    },
                    headerZone: function() {
                        return $scope.headerZone;
                    },
                    typeForm: function() {
                        return $scope.typeForm;
                    }

                }
            });
        };

        var selectTableTypeDrag = function(data) {
            var index = $scope.itemTables.indexOf(data);
            if (index > -1) {
                $scope.itemTables.splice(index, 1);
            }
        };

        var selectTableTypeDrop = function(data) {
            var index = $scope.itemTables.indexOf(data);
            if (index == -1)
                data.id = 0;
            data.status = 1;

            $scope.itemTables.push(data);
            updateHeaderZone();
        };

        var updateHeaderZone = function() {
            ZoneLienzoFactory.updateHeaderZone($scope.headerZone, $scope.itemTables);
        };

        var getDataTables = function(table) {

            var tableItem = {
                name: table.name,
                min_cover: table.minCover,
                max_cover: table.maxCover,
                config_position: table.left + "," + table.top, //x,y
                config_size: TableFactory.getIdSize(table.size),
                config_rotation: table.rotate,
                config_rotation_text: TableFactory.getIdRotationText(table.rotate_text),
                config_forme: TableFactory.getIdShape(table.shape),
                id: table.id,
                status: table.status
            };

            return tableItem;
        };

        var prepareDataTablesSave = function() {
            var tables = [];

            angular.forEach($scope.itemTables, function(table) {

                var tableItem = getDataTables(table);

                tables.push(tableItem);

            });

            if ($scope.typeForm == "edit") {

                angular.forEach($scope.itemTablesDeleted, function(table) {

                    var tableItem = getDataTables(table);

                    tables.push(tableItem);

                });

            }

            console.log("prepareDataTablesSave " + angular.toJson(tables, true));

            return tables;
        };

        $scope.saveZone = function(option) {
            var dataZone = {
                name: angular.element("#zone_name").val(),
                ms_microsite_id: IdMicroSitio,
                tables: prepareDataTablesSave()
            };

            $scope.saveClick = true;

            if (option == "create") {

                ZoneFactory.createZone(dataZone).success(function(response) {
                    messageAlert("Success", "Zona creada correctamente", "success", 0, true);
                    $state.reload();
                }).error(function(data, status, headers) {
                    $scope.saveClick = false;
                    messageErrorApi(data, "Error", "warning", 0, true);
                });

            } else {
                dataZone.id = $stateParams.id;
                ZoneFactory.editZone(dataZone).success(function(response) {
                    messageAlert("Success", "Zona actualizada correctamente", "success", 0, true);
                    $state.go('mesas.zone.active');
                }).error(function(data, status, headers) {
                    $scope.saveClick = false;
                    messageErrorApi(data, "Error", "warning", 0, true);
                });
            }

            console.log("saveZone " + angular.toJson(dataZone, true));
        };

        var detectedForm = function() {
            if ($stateParams.id !== undefined) {

                $scope.typeForm = "edit";

                ZoneFactory.getZone($stateParams.id).success(function(zone) {

                    angular.element("#zone_name").val(zone.data.name);

                    loadTablesEdit(zone.data.tables);
                });
            }
        };

        var loadTablesEdit = function(tables) {

            angular.forEach(tables, function(data) {

                var position = data.config_position.split(",");
                var dataTable = {
                    name: data.name,
                    minCover: data.min_cover,
                    maxCover: data.max_cover,
                    left: position[0],
                    top: position[1],
                    shape: TableFactory.getLabelShape(data.config_forme),
                    size: TableFactory.getLabelSize(data.config_size),
                    rotate: data.config_rotation,
                    rotate_text: TableFactory.getRotationText(data.config_rotation_text),
                    id: data.id,
                    status: data.status
                };

                if (data.status == 1) {
                    $scope.itemTables.push(dataTable);
                } else {
                    $scope.itemTablesDeleted.push(dataTable);
                }

            });

            console.log("loadTablesEdit " + angular.toJson($scope.itemTables, true));

            updateHeaderZone();
        };

        init();
    })
    .controller('ModalTableDeteleCtrl', function($scope, $uibModalInstance, itemTables, itemTablesDeleted, indexTable, boxTables, headerZone, typeForm, ZoneLienzoFactory) {

        $scope.ok = function() {
            //show tables items
            ZoneLienzoFactory.activarTablesItems(boxTables);

            removeTableItem();

            ZoneLienzoFactory.updateHeaderZone(headerZone, itemTables);

            $uibModalInstance.close();
        };

        var removeTableItem = function() {

            //add table in tables removes

            if (typeForm == "edit") {

                itemTables[indexTable].status = 2;

                itemTablesDeleted.push(itemTables[indexTable]);
            }

            //delete item table selected
            itemTables.splice(indexTable, 1);
            angular.element('.item-drag-table').removeClass('selected-table');

        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };
    })
    .controller('ModalZoneDeleteCtrl', function($scope, ZoneFactory, $uibModalInstance, idZone, indexRow, zonesInactive) {

        $scope.deleteZone = function() {
            ZoneFactory.deleteZone(idZone).success(function(response) {
                console.log("deleteZone msg " + response);

                messageAlert("Success", "Zone deleted", "success");

                zonesInactive.splice(indexRow, 1);
                $uibModalInstance.close();

            }).error(function(data, status, headers) {
                messageErrorApi(data, "Error", "warning");
            });
        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };
    })
    .controller('ZoneAssignTurnCtrl', function($scope, TypeTurnFactory, TurnFactory, $uibModal, $filter) {

        $scope.typeTurns = {};

        $scope.days = getDaysWeek();

        $scope.turns = [];

        $scope.turnDay = {
            id: 0,
            name: 'Selected turn'
        };

        $scope.getTurnsByType = function(typeTurn) {

            var vTurns = [$scope.turnDay];

            angular.forEach($scope.turns, function(data) {
                if (data.type.id == typeTurn) {
                    //data.name = data.name +" ("+data.hours_ini +" "+ data.hours_end +")";
                    vTurns.push(data);
                }
            });

            return vTurns;
        };

        $scope.selectTurno = function(typeTurn, turn, day) {

            var vData = {
                day: day,
                res_turn_id: turn.id,
                res_type_turn: typeTurn.id
            };

            console.log("selectTurno " + angular.toJson(vData, true));
        };

        var getTypeTurns = function() {

            TypeTurnFactory.getTypeTurns().success(function(data) {

                $scope.typeTurns = data;

            }).error(function(data, status, headers) {

                messageErrorApi(data, "Error", "warning");

            });
        };

        var getTurns = function() {

            TurnFactory.getTurns().success(function(data) {

                console.log("getTurnss " + angular.toJson(data.data, true));

                $scope.turns = data.data;

            }).error(function(data, status, headers) {

                messageErrorApi(data, "Error", "warning");

            });
        };

        getTurns();
        getTypeTurns();
    });
angular.module('zone.directive', [])

.directive('ngDragTable', function() {
  var parentWidth = angular.element('.lienzo').width();
  var parentHeight = angular.element('.lienzo').height();

  function updatePositionLabel(element, ui) {
    var draggableWidth = element.context.offsetWidth;
    var draggableHeight = element.context.offsetHeight;

    var draggableRight = ui.position.left + draggableWidth;
    var draggableLeft = ui.position.left;
    var draggableTop = ui.position.top;

    var eRotate = element.attr("rotate");
    var eLabel = angular.element(element.context);
    var eTextRotate = eLabel.context.lastElementChild.classList[1];

    //Left

    if (draggableRight >= parentWidth && eRotate == "0") {
      if (eTextRotate == "right") {
        angular.element(eLabel.context.lastElementChild).removeClass("right");
        angular.element(eLabel.context.lastElementChild).addClass("left");
      }
    } else {
      if ((eTextRotate == "top" && (eRotate == "45" || eRotate == "135")) && draggableRight >= (parentWidth - draggableWidth * 0.35)) {
        angular.element(eLabel.context.lastElementChild).removeClass("top");
        angular.element(eLabel.context.lastElementChild).addClass("left");
      }
      if (eTextRotate == "right" && eRotate == "45" && draggableRight >= (parentWidth - draggableWidth * 0.35)) {
        angular.element(eLabel.context.lastElementChild).removeClass("right");
        angular.element(eLabel.context.lastElementChild).addClass("bottom");
      }
    }

    if (draggableLeft <= 0 && eRotate == "0") {
      if (eTextRotate == "left") {
        angular.element(eLabel.context.lastElementChild).removeClass("left");
        angular.element(eLabel.context.lastElementChild).addClass("right");
      }

    } else {
      if (eTextRotate == "left" && eRotate == "45" && (draggableLeft - draggableWidth * 0.35) <= 0) {
        angular.element(eLabel.context.lastElementChild).removeClass("left");
        angular.element(eLabel.context.lastElementChild).addClass("top");
      }
      if (eTextRotate == "bottom" && eRotate == "45" && (draggableLeft - draggableWidth * 0.35) <= 0) {
        angular.element(eLabel.context.lastElementChild).removeClass("bottom");
        angular.element(eLabel.context.lastElementChild).addClass("right");
      }
    }

    //Top

    if (draggableTop <= 0 && (eRotate == "0" || eRotate == "90")) {
      if (eTextRotate == "top") {
        angular.element(eLabel.context.lastElementChild).removeClass("top");
        angular.element(eLabel.context.lastElementChild).addClass("bottom");
      }
    }

    if ((draggableTop + draggableHeight) >= parentHeight && (eRotate == "0" || eRotate == "90")) {
      if (eTextRotate == "bottom") {
        angular.element(eLabel.context.lastElementChild).removeClass("bottom");
        angular.element(eLabel.context.lastElementChild).addClass("top");
      }
    }
  }

  function dragTable(scope, element, attr, ctrl) {

    element.on('click', function(event) {
      event.preventDefault();
      scope.onClickFn();

      angular.element('.item-drag-table').removeClass('selected-table');
      angular.element(this).toggleClass("selected-table");

    });

    element.draggable({
      containment: "parent",
      grid: [10, 10],
      drag: function(event, ui) {

        element.attr("top", ui.position.top);
        element.attr("left", ui.position.left);
        updatePositionLabel(element, ui);
        //element.draggable("disable");
      },
      start: function(event, ui) {
        angular.element('#lienzo').addClass('drag');
      },
      stop: function(event, ui) {
        angular.element('#lienzo').removeClass('drag');
      }
    });
  }

  return {
    link: dragTable,
    scope: {
      onClickFn: '&',
      onDragFn: '&'
    }
  };
});
angular.module('zone.service', [])
	.factory('ZoneFactory', function($http, ApiUrlMesas) {
		return {
			getZones: function(vOptions) {
				return $http.get(ApiUrlMesas + "/zones?" + vOptions, {
					ignoreLoadingBar: true
				});
			},
			getZone: function(vId) {
				return $http.get(ApiUrlMesas + "/zones/" + vId);
			},
			createZone: function(vData) {
				return $http.post(ApiUrlMesas + '/zones', vData);
			},
			editZone: function(vData) {
				return $http.put(ApiUrlMesas + '/zones/' + vData.id, vData);
			},
			deleteZone: function(vId) {
				return $http.delete(ApiUrlMesas + '/zones/' + vId);
			},
			getTables: function(vId) {
				return $http.get(ApiUrlMesas + "/zones/" + vId + "/tables");
			}
		};

	})

.factory('ZoneTurnFactory', function($http, ApiUrl) {

	/*return {
		create : function(vData){

		}
	}*/

	//config_rotate_text : 1 = top , 2 = rigth , 3 = bottom , 4 = left
})

.factory('ZoneLienzoFactory', function($document, TableFactory) {
	return {
		activarTablesItems: function(boxTables) {
			boxTables.item = false;
			boxTables.items = true;

			angular.element('.item-drag-table').removeClass('selected-table');
		},
		updateHeaderZone: function(headerZone, itemTables) {
			headerZone.tables = itemTables.length;

			var minCovers = 0;
			var maxCovers = 0;

			angular.forEach(itemTables, function(data) {

				minCovers += parseInt(data.minCover);
				maxCovers += parseInt(data.maxCover);

			});

			headerZone.minCovers = minCovers;
			headerZone.maxCovers = maxCovers;
		},
		positionTable: function(evt) {
			var offset = $("#lienzo").offset();

			var divPos = {
				left: evt.x - offset.left,
				top: evt.y - offset.top
			};

			var documentWidth = $document.width();
			var documentHeight = $document.height();

			var lienzoWidth = $(".lienzo").innerWidth();
			var lienzoHeight = $(".lienzo").innerHeight();

			var ContentX = (documentWidth - lienzoWidth) / 2;
			var ContentY = 145; //205
			var SizeObjectDrag = 75;

			var x = divPos.left - (SizeObjectDrag * 0.5) + (SizeObjectDrag / 2 - evt.element.centerX);
			var y = divPos.top - (SizeObjectDrag * 0.5) + (SizeObjectDrag / 2 - evt.element.centerX);
			console.log(x + " " + y);
			x = x - x % 10;
			y = y - y % 10;

			console.log(x + " " + y);

			var position = {
				x: x,
				y: y
			};

			return position;
		},
		changeRotationText: function(option, element, index) {

			//var rotate_actual = element.rotate_text;

			var table = angular.element("#tb-item" + index);
			var rotate_actual = table[0].firstElementChild.classList[1];
			var rotate = rotate_actual || "top";

			switch (rotate_actual) {
				case 'top':
					rotate = (option == "right") ? "right" : "left";
					break;
				case 'left':
					rotate = (option == "right") ? "top" : "bottom";
					break;
				case 'bottom':
					rotate = (option == "right") ? "left" : "right";
					break;
				case 'right':
					rotate = (option == "right") ? "bottom" : "top";
					break;
			}

			angular.element(table[0].firstElementChild).removeClass(rotate_actual);
			//angular.element(table[0].firstElementChild).addClass(rotate);

			//element.rotate_text = TableFactory.getIdRotationText(rotate);
			element.rotate_text = rotate;
			console.log("changeRotationText ", angular.toJson(element, true));
		},
		changeNameTable: function(element, itemTables, texto) {
			var valida = false;
			angular.forEach(itemTables, function(value, key) {

				if (value.name == texto && value.name !== "") {
					valida = true;
					alertMultiple("Alerta:", "Ya existe este nombre", "danger", "fa fa-comments");
				}
			});

			if (valida === false) {
				element.name = texto;
			}
		}
	};
})

.factory('TableFactory', function() {
	return {
		getIdShape: function(label) {
			var id = "";

			switch (label) {
				case "round":
					id = "1";
					break;
				case "square":
					id = "2";
					break;
				case "recta":
					id = "3";
					break;
			}
			return id;
		},
		getIdSize: function(label) {
			var id = "";

			switch (label) {
				case "small":
					id = "1";
					break;
				case "medium":
					id = "2";
					break;
				case "large":
					id = "3";
					break;
			}

			return id;
		},
		getLabelShape: function(id) {
			var label = "";

			switch (id) {
				case 1:
					label = "round";
					break;
				case 2:
					label = "square";
					break;
				case 3:
					label = "recta";
					break;
			}
			return label;
		},
		getLabelSize: function(id) {
			var label = "";

			switch (id) {
				case 1:
					label = "small";
					break;
				case 2:
					label = "medium";
					break;
				case 3:
					label = "large";
					break;
			}

			return label;
		},
		getRotationText: function(id) {
			var label = "top";
			switch (id) {
				case 1:
					label = "top";
					break;
				case 2:
					label = "right";
					break;
				case 3:
					label = "bottom";
					break;
				case 4:
					label = "left";
					break;
			}
			return label;
		},
		getIdRotationText: function(label) {
			var id = 1;
			switch (label) {
				case 'top':
					id = 1;
					break;
				case 'right':
					id = 2;
					break;
				case 'bottom':
					id = 3;
					break;
				case 'left':
					id = 4;
					break;
			}
			return id;
		}
	};
})

;
/************
Inyectamos nuestra aplicacion
example.app = nombre de la aplicacion
************/
angular.module('bookersnap',
[
"bookersnap.directives",
'tables.app',
]);
angular.module("bookersnap.directives", [])
    .constant("loadTime", 5000)
    .directive("loadingBox", ["$interval", "loadTime", function($interval, loadTime) {
        return {
            restrict: 'E',
            scope: {
                waitLoad: "=wait",
                time: "=?"
            },
            template: '<div class="load-parent" ng-show="waitLoad">\
                              <div class="load-child" ng-class="[with]">\
                                     <div class="preloader" ng-class="[size]">\
                                          <svg class="pl-circular" viewBox="25 25 50 50">\
                                                <circle class="plc-path" cx="50" cy="50" r="20"></circle>\
                                          </svg>\
                                      </div>\
                              </div>\
                        </div>',
            link: function(vm, element, attrs) {
                vm.with = attrs.size || "size-default";
                vm.size = attrs.size ? "pl-"+attrs.size: null;

                var timeoutId;
                vm.time = vm.time || loadTime;

                vm.$watch("waitLoad", function(value) {
                    if (value === true) {
                        destroy();
                        setTime();
                    } else {
                        cancelLoad();
                    }
                });

                function setTime() {
                    timeoutId = $interval(function() {
                        cancelLoad();
                    }, vm.time);
                }

                function cancelLoad() {
                    destroy();
                    vm.waitLoad = false;
                }

                function destroy() {
                    if (timeoutId) {
                        $interval.cancel(timeoutId);
                    }
                }
            }
        };
    }]);
angular.module("bookersnap.services", [])

.factory('MenuConfigFactory', function($timeout) {
	return {
		menuActive: function(index) {

			$timeout(function() {
				angular.element("#menu-config li").removeClass("active");
				angular.element("#menu-config li").eq(index).addClass("active");
			}, 500);

		}
	};

});